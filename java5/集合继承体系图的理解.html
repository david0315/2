<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修集合继承体系图的理解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>集合继承体系图的理解</center></div><div class='banquan'>原文出处:本文由博客园博主MrHH提供。<br/>
原文连接:https://www.cnblogs.com/HuiH/p/11825006.html</div><br>
    <p>　　<img src="./images/集合继承体系图的理解0.png" alt="" width="548" height="278" /></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">一、Collection、Collections的区别？</span></strong></span></p>
<p>　<span style="font-size: 16px;">　1. java.util.<strong>Collection是一个集合的顶级接口</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java类库中有很多具体的实现，其直接继承接口有List与Set。</span></p>
<p><span style="font-size: 16px;">　　2. <strong>Collections是集合类的一个工具类</strong>，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等操作。</span></p>
<p><span style="font-size: 16px;">　　　　1）排序（sort）：使用sort方法可以根据元素的自然顺序对指定列表按升序进行排序。列表中的所有元素都必须实现Comparable接口。此列表内的所有元素都必须是使用指定比较器可相互比较的。</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;"> 1</span> List&lt;Integer&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;Integer&gt;<span style="color: #000000;">();
</span><span style="color: #008080;"> 2</span>         <span style="color: #0000ff;">int</span> array[] = {112, 111, 23, 456, 231<span style="color: #000000;"> };
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; array.length; i++<span style="color: #000000;">) {
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">            list.add(array[i]);
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        Collections.sort(list);
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; array.length; i++<span style="color: #000000;">) {
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">            System.out.println(list.get(i));
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">10</span> 结果：23  111  112  231  456</span></code></pre>

<p><span style="font-size: 16px;">　　　　2）混排（shuffling）：混排算法所做的正好与sort相反，它打乱在一个List中可能有的任何排列的踪迹。也就是说，基于随机源的输入重排该list，这样的排列具有相同的可能性（假设随机源是公正的）。这个算法在实现一个碰运气的游戏中是非常有用的。例如，它可被用来混派代表一副牌的card对象的一个list。另外，在生成测试案例时，它也是十分有用的。</span></p>
<p><span style="font-size: 16px;">　　　　3）反转（reverse）：使用reverse方法可以根据元素的自然顺序对指定列表按降序进行排序。Collections.reverse(list)</span></p>
<p><span style="font-size: 16px;">　　　　4）替换所有的元素（fill）：使用指定元素替换指定列表中的所有元素。Collections.fill(li,"aaa");</span></p>
<p><span style="font-size: 16px;">　　　　5）拷贝（copy）：用两个参数，一个目标list和一个源list，将源的元素拷贝到目标，并覆盖它的内容。目标list至少与源一样长。如果它更长，则在目标list中的剩余元素不受影响。</span></p>
<p><span style="font-size: 16px;">　　　　　　Collections.copy(list,li)：前面一个参数是目标列表，后一个是源列表</span></p>
<p><span style="font-size: 16px;">　　　　6）返回Collections中的最小元素（min）：根据指定比较器产生的顺序，返回给定collection的最小元素。collection中的所有元素都必须是通过指定比较器可相互比较的。</span></p>
<p><span style="font-size: 16px;">　　　　　　Collections.min(list)</span></p>
<p><span style="font-size: 16px;">　　　　7）返回Collections中的最大元素（max）：根据指定比较器产生的顺序，返回给顶collection的最大元素。Collections.max(list)</span></p>
<p><span style="font-size: 16px;">　　　　8）lastIndexOfSubList：返回值定源列表中最后一次出现指定目标列表的起始位置。 int count = Collections.lastIndexOfSubList(list,li);</span></p>
<p><span style="font-size: 16px;">　　　　9）Rotate：根据指定的距离循环移动指定列表中的元素。　　Collections.rotate(list,-1); //如果是负数，则正向移动，正数则反向移动。</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">二、List、Set的区别？</span></strong></span></p>
<p><span style="font-size: 16px;">　　List与Set都继承于Collection，Collection是集合的顶级接口；</span></p>
<p><span style="font-size: 16px;">　　List为有序可重复的集合接口，ArrayList、LinkedList、Vector为其实现类；Set是无序不重复的集合接口，HashSet、LinkedHashSet、TreeSet为其实现类。</span></p>
<p><strong><span style="font-size: 16px; color: #ff0000;">三、ArrayList、LinkedList、Vector的区别?</span></strong></p>
<p><span style="font-size: 16px;">　　ArrayList、Vector：底层均为数组，查询快、增删慢；ArrayList效率高、是线程不安全的；Vector效率低、线程安全，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性。</span></p>
<p><span style="font-size: 16px;">　　LinkedList：底层为链表结构，查询慢、增删快；</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">四、HashMap、HashTable</span></strong></span></p>
<p><span style="font-size: 16px;">　　hashmap的效率高、是线程不安全的，允许键/值为空；<br /></span></p>
<p><span style="font-size: 16px;">　　hashtable是线程安全的，效率低，不允许键/值为空；</span></p>
<p><strong><span style="font-size: 16px; color: #ff0000;">五、HashSet</span></strong></p>
<p><span style="font-size: 16px;">　　哈希表存放的是哈希值。hashset存储元素的顺序并不是按照存入时的顺序（和list显然不同）而是按照哈希值来存的所以取数也是按照哈希值取得。元素的哈希值是通过元素的hashcode方法来获取的，hashset首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法，如果equals结果为true，hashset就视为同一个元素。如果equals为false就不是同一个元素。</span></p>
<p><span style="font-size: 16px;">　　哈希值相同equals为false的元素是怎么存储呢？就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中），也就是哈希一样的存一列。</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">六、TreeSet</span></strong></span></p>
<p><span style="font-size: 16px;">　　1. treeset是使用二叉树的原理对add的对象按照指定的顺序排序，每增加一个对象都会进行排序，将对象插入到二叉树指定的位置；</span></p>
<p><span style="font-size: 16px;">　　2. Integer和String对象都可以进行默认的treeset排序，而自定义的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆盖相应的compareTo()函数，才可以正常使用。</span></p>
<p><span style="font-size: 16px;">　　3.在重写compareTo()函数时，要返回相应的值才能使treeset按照一定的规则进行排序。</span></p>
<p><span style="font-size: 16px;">　　4.比较此对象与指定对象顺序，如果该对象小于、等于或大与指定对象，则分别返回负整数、零或正整数。</span></p>
<p><strong><span style="font-size: 16px; color: #ff0000;">七、TreeMap（可排序）</span></strong></p>
<p><span style="font-size: 16px;">　　treeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用iterator遍历treeMap时，得到的记录是排过序的。</span></p>
<p><span style="font-size: 16px;">　　如果使用排序的映射，建议使用treeMap。<br /></span></p>
<p><span style="font-size: 16px;">　　在使用treeMap时，key必须实现Comparable接口或在构造treeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</span></p>
<p><strong><span style="font-size: 16px; color: #ff0000;">八、LinkedHashMap（记录插入顺序)</span></strong></p>
<p><span style="font-size: 16px;">　　LinkedHashMap是hashMap的一个子类，保存了记录的插入顺序，在用iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造函数时带参数，按照访问次序排序。</span></p>
<p><strong><span style="font-size: 16px; color: #ff0000;">九、Map接口与Collection接口的区别？</span></strong></p>
<p><span style="font-size: 16px;">　　Map是双列的，Collection是单列的；</span></p>
<p><span style="font-size: 16px;">　　Map的键值唯一，Collection的子接口set是唯一的；<br /></span></p>
<p><span style="font-size: 16px;">　　Map的数据结构只针对键有效，Collection针对元素有效；</span></p>
<table style="height: 115px; width: 737px;" border="0" align="left">
<tbody>
<tr>
<td><span style="font-size: 15px; background-color: #ffffff; color: #0000ff;">集合</span></td>
<td><span style="font-size: 15px; background-color: #ffffff; color: #0000ff;">初始容量</span></td>
<td><span style="font-size: 15px; background-color: #ffffff; color: #0000ff;">扩容因子</span></td>
<td><span style="font-size: 15px; background-color: #ffffff; color: #0000ff;">负载因子</span></td>
<td><span style="font-size: 15px; background-color: #ffffff; color: #0000ff;">底层结构</span></td>
<td><span style="font-size: 15px; background-color: #ffffff; color: #0000ff;">线程是否安全</span></td>

</tr>
<tr>
<td><span style="font-size: 15px; background-color: #ffffff;">ArrayList</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">10</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">1.5</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">无（满了扩容）</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">数组</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">否</span></td>

</tr>
<tr>
<td><span style="font-size: 15px; background-color: #ffffff;">Vector</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">10</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">2</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">无（满了扩容）</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">数组</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">是</span></td>

</tr>
<tr>
<td><span style="font-size: 15px; background-color: #ffffff;">HashMap</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">16</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">2</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">0.75</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">数组+链表+红黑树</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">否</span></td>

</tr>
<tr>
<td><span style="font-size: 15px; background-color: #ffffff;">HashSet</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">16</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">2</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">0.75</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">数组+链表+红黑树</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">否</span></td>

</tr>
<tr>
<td><span style="font-size: 15px; background-color: #ffffff;">HashTable</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">11</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">2*1+1</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">0.75</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">数组+链表</span></td>
<td><span style="font-size: 15px; background-color: #ffffff;">是</span></td>

</tr>

</tbody>

</table>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>