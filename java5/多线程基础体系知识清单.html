<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修多线程基础体系知识清单' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>多线程基础体系知识清单</center></div><div class='banquan'>原文出处:本文由博客园博主Java知音*提供。<br/>
原文连接:https://www.cnblogs.com/javazhiyin/p/11670356.html</div><br>
    <h2>前言</h2>
<p>本文会介绍Java中多线程与并发的基础，适合初学者食用。</p>
<h2>线程与进程的区别</h2>
<p>在计算机发展初期，每台计算机是串行地执行任务的，如果碰上需要IO的地方，还需要等待长时间的用户IO，后来经过一段时间有了批处理计算机，其可以批量串行地处理用户指令，但本质还是串行，还是不能并发执行。</p>
<p><strong>如何解决并发执行的问题呢？</strong><strong>于是引入了进程的概念，每个进程独占一份内存空间，进程是内存分配的最小单位，相互间运行互不干扰且可以相互切换，现在我们所看到的多个进程&ldquo;同时"在运行，实际上是进程高速切换的效果。</strong></p>
<p>那么有了线程之后，我们的计算机系统看似已经很完美了，为什么还要进入线程呢？如果一个进程有多个子任务，往往一个进程需要逐个去执行这些子任务，但往往这些子任务是不相互依赖的，可以并发执行，所以需要CPU进行更细粒度的切换。所以就引入了线程的概念，线程隶属于某一个进程，它共享进程的内存资源，相互间切换更快速。</p>
<p><strong>进程与线程的区别：</strong></p>
<ol class="list-paddingleft-2">
<li>
<p>进程是资源分配的最小单位，线程是CPU调度的最小单位。所有与进程相关的资源，均被记录在PCB中。</p>
</li>
<li>
<p>线程隶属于某一个进程，共享所属进程的资源。线程只由堆栈寄存器、程序计数器和TCB构成。</p>
</li>
<li>
<p>进程可以看作独立的应用，线程不能看作独立的应用。</p>
</li>
<li>
<p>进程有独立的地址空间，相互不影响，而线程只是进程的不同执行路径，如果线程挂了，进程也就挂了。所以多进程的程序比多线程程序健壮，但是切换消耗资源多。</p>
</li>
</ol>
<p><strong>Java中进程与线程的关系：</strong></p>
<ol class="list-paddingleft-2">
<li>
<p>运行一个程序会产生一个进程，进程至少包含一个线程。</p>
</li>
<li>
<p>每个进程对应一个JVM实例，多个线程共享JVM中的堆。</p>
</li>
<li>
<p>Java采用单线程编程模型，程序会自动创建主线程 。</p>
</li>
<li>
<p>主线程可以创建子线程，原则上要后于子线程完成执行。</p>
</li>
</ol><hr />
<h2>线程的start方法和run方法的区别</h2>
<h3>区别</h3>
<p>Java中创建线程的方式有两种，不管使用继承Thread的方式还是实现Runnable接口的方式，都需要重写run方法。调用start方法会创建一个新的线程并启动，run方法只是启动线程后的回调函数，如果调用run方法，那么执行run方法的线程不会是新创建的线程，而如果使用start方法，那么执行run方法的线程就是我们刚刚启动的那个线程。</p>
<h3>程序验证</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread thread </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> SubThread());
        thread.run();
        thread.start();
    }

}
</span><span style="color: #0000ff;">class</span> SubThread <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
        System.out.println("执行本方法的线程:"+<span style="color: #000000;">Thread.currentThread().getName());
    }

}</span></code></pre>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单0.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单0.png" /></p>
<hr />
<h2>Thread和Runnable的关系</h2>
<h3>Thread源码</h3>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单1.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单1.png" /></p>
<h3>Runnable源码</h3>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单2.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单2.png" /></p>
<p><strong>区别</strong></p>
<p>通过上述源码图，不难看出，Thread是一个类，而Runnable是一个接口，Runnable接口中只有一个没有实现的run方法，可以得知，Runnable并不能独立开启一个线程，而是依赖Thread类去创建线程，执行自己的run方法，去执行相应的业务逻辑，才能让这个类具备多线程的特性。</p>
<h3>使用继承Thread方式和实现Runable接口方式分别创建子线程</h3>
<p><strong>使用继承Thread类方式创建子线程</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Main <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Main main </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Main();
        main.start();
    }
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        System.out.println(</span>"通过继承Thread接口方式创建子线程成功,当前线程名："+<span style="color: #000000;">Thread.currentThread().getName());
    }

}</span></code></pre>

<p>&nbsp;</p>
<p>运行结果:</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单3.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单3.png" /></p>
<p><strong>使用实现Runnable接口方式创建子线程</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        SubThread subThread </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> SubThread();
        Thread thread </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(subThread);
        thread.start();
    }

}
</span><span style="color: #0000ff;">class</span> SubThread <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
        System.out.println("通过实现Runnable接口创建子线程成功，当前线程名:"+<span style="color: #000000;">Thread.currentThread().getName());
    }

}</span></code></pre>

<p>&nbsp;</p>
<p>运行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单4.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单4.png" /></p>
<p><strong>使用匿名内部类方式创建子线程</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread thread </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
                System.out.println("使用匿名内部类方式创建线程成功,当前线程名:"+<span style="color: #000000;">Thread.currentThread().getName());
            }
        });
        thread.start();
    }
}</span></code></pre>

<p>&nbsp;</p>
<p>运行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单5.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单5.png" /></p>
<h3>关系</h3>
<ol class="list-paddingleft-2">
<li>
<p>Thread是实现了Runnable接口的类，使得run支持多线程。</p>
</li>
<li>
<p>因类的单一继承原则，推荐使用Runnable接口，可以使程序更加灵活。</p>
</li>
</ol><hr />
<h2>如何实现处理多线程的返回值</h2>
<p>通过刚才的学习，我们知道多线程的逻辑需要放到run方法中去执行，而run方法是没有返回值的，那么遇到需要返回值的状况就不好解决，那么如何实现子线程返回值呢？</p>
<h3>主线程等待法</h3>
<p>通过让主线程等待，直到子线程运行完毕为止。</p>
<p>实现方式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">static</span><span style="color: #000000;"> String str;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread thread </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                str</span>="子线程执行完毕"<span style="color: #000000;">;
            }
        });
        thread.start();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果子线程还未对str进行赋值，则一直轮转</span>
        <span style="color: #0000ff;">while</span>(str==<span style="color: #0000ff;">null</span><span style="color: #000000;">) {}
        System.out.println(str);
    }
}</span></code></pre>

<p>&nbsp;</p>
<h3>使用Thread中的join()方法</h3>
<p>join()方法可以阻塞当前线程以等待子线程处理完毕。</p>
<p>实现方式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">static</span><span style="color: #000000;"> String str;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread thread </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                str</span>="子线程执行完毕"<span style="color: #000000;">;
            }
        });
        thread.start();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果子线程还未对str进行赋值，则一直轮转</span>
        <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            thread.join();
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        System.out.println(str);
    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong>join方法能做到比主线程等待法更精准的控制，但是join方法的控制粒度并不够细。</strong>比如，我需要控制子线程将字符串赋一个特定的值时，再执行主线程，这种操作join方法是没有办法做到的。</p>
<h3>通过Callable接口实现：通过FutureTask或者线程池获取</h3>
<p>在JDK1.5之前，线程是没有返回值的，通常程序猿需要获取子线程返回值颇费周折，<strong>现在Java有了自己的返回值线程，即实现了Callable接口的线程，执行了实现Callable接口的线程之后，可以获得一个Future对象，在该对象上调用一个get方法，就可以执行子线程的逻辑并获取返回的Object。</strong></p>
<p>实现方式1（错误示例）：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Main <span style="color: #0000ff;">implements</span> Callable&lt;String&gt;<span style="color: #000000;">{

    @Override
    </span><span style="color: #0000ff;">public</span> String call() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
        String str = "我是带返回值的子线程"<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Main main </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Main();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            String str </span>=<span style="color: #000000;"> main.call();
            System.out.println(str);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
    }
}</span></code></pre>

<p>&nbsp;</p>
<p>运行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单6.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单6.png" /></p>
<p>实现方式2（使用FutureTask）：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Main <span style="color: #0000ff;">implements</span> Callable&lt;String&gt;<span style="color: #000000;">{

    @Override
    </span><span style="color: #0000ff;">public</span> String call() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
        String str = "我是带返回值的子线程"<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        FutureTask</span>&lt;String&gt; task = <span style="color: #0000ff;">new</span> FutureTask&lt;String&gt;(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Main());
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(task).start();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">task.isDone()) {
                System.out.println(</span>"任务没有执行完成"<span style="color: #000000;">);
            }
            System.out.println(</span>"等待中..."<span style="color: #000000;">);
            Thread.sleep(</span>3000<span style="color: #000000;">);
            System.out.println(task.get());

        } </span><span style="color: #0000ff;">catch</span> (InterruptedException |<span style="color: #000000;"> ExecutionException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
    }
}</span></code></pre>

<p>&nbsp;</p>
<p>运行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单7.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单7.png" /></p>
<p>实现方法3（使用线程池配合Future获取）：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Main <span style="color: #0000ff;">implements</span> Callable&lt;String&gt;<span style="color: #000000;">{

    @Override
    </span><span style="color: #0000ff;">public</span> String call() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
        String str = "我是带返回值的子线程"<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException, ExecutionException {
        ExecutorService newCacheThreadPool </span>=<span style="color: #000000;"> Executors.newCachedThreadPool(); 
        Future</span>&lt;String&gt; future = newCacheThreadPool.submit(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Main());
        </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">future.isDone()) {
            System.out.println(</span>"线程尚未执行结束"<span style="color: #000000;">);
        }
        System.out.println(</span>"等待中"<span style="color: #000000;">);
        Thread.sleep(</span>300<span style="color: #000000;">);
        System.out.println(future.get());
        newCacheThreadPool.shutdown();
    }
}</span></code></pre>

<p>&nbsp;</p>
<p>运行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单8.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单8.png" /></p>
<hr />
<h2>线程的状态</h2>
<p>Java线程主要分为以下六个状态：<strong>新建态（new），运行态（Runnable），无限期等待（Waiting），限期等待（TimeWaiting），阻塞态（Blocked)，结束（Terminated)</strong>。</p>
<h3>新建（new）</h3>
<p>新建态是线程处于已被创建但没有被启动的状态，在该状态下的线程只是被创建出来了，但并没有开始执行其内部逻辑。</p>
<h3>运行（Runnable）</h3>
<p>运行态分为Ready和Running，当线程调用start方法后，并不会立即执行，而是去争夺CPU，当线程没有开始执行时，其状态就是Ready，而当线程获取CPU时间片后，从Ready态转为Running态。</p>
<h3>等待（Waiting）</h3>
<p>处于等待状态的线程不会自动苏醒，而只有等待被其它线程唤醒，在等待状态中该线程不会被CPU分配时间，将一直被阻塞。以下操作会造成线程的等待：</p>
<ol class="list-paddingleft-2">
<li>
<p>没有设置timeout参数的Object.wait()方法。</p>
</li>
<li>
<p>没有设置timeout参数的Thread.join()方法。</p>
</li>
<li>
<p>LockSupport.park()方法（实际上park方法并不是LockSupport提供的，而是在Unsafe中，LockSupport只是对其做了一层封装，可以看我的另一篇博客《锁》，里面对于ReentrantLock的源码解析有提到这个方法）。</p>
</li>
</ol>
<h3>&nbsp;</h3>
<blockquote class="js_blockquote_wrap">
<p>锁：https://juejin.im/post/5d8da403f265da5b5d203bf4</p>
</blockquote>
<h3>限期等待（TimeWaiting）</h3>
<p>处于限期等待的线程，CPU同样不会分配时间片，但存在于限期等待的线程无需被其它线程显式唤醒，而是在等待时间结束后，系统自动唤醒。以下操作会造成线程限时等待：</p>
<ol class="list-paddingleft-2">
<li>
<p>Thread.sleep()方法。</p>
</li>
<li>
<p>设置了timeout参数的Object.wait()方法。</p>
</li>
<li>
<p>设置了timeout参数的Thread.join()方法。</p>
</li>
<li>
<p>LockSupport.parkNanos()方法。</p>
</li>
<li>
<p>LockSupport.parkUntil()方法。</p>
</li>
</ol>
<h3>阻塞（Blocked）</h3>
<p>当多个线程进入同一块共享区域时，例如Synchronized块、ReentrantLock控制的区域等，会去整夺锁，成功获取锁的线程继续往下执行，而没有获取锁的线程将进入阻塞状态，等待获取锁。</p>
<h3>结束（Terminated)</h3>
<p>已终止线程的线程状态，线程已结束执行。</p>
<hr />
<h2>Sleep和Wait的区别</h2>
<p><strong>Sleep和Wait者两个方法都可以使线程进入限期等待的状态，那么这两个方法有什么区别呢？</strong></p>
<ol class="list-paddingleft-2">
<li>
<p>sleep方法由Thread提供，而wait方法由Object提供。</p>
</li>
<li>
<p>sleep方法可以在任何地方使用，而wait方法只能在synchronized块或synchronized方法中使用（因为必须获wait方法会释放锁，只有获取锁了才能释放锁）。</p>
</li>
<li>
<p>sleep方法只会让出CPU，不会释放锁，而wait方法不仅会让出CPU，还会释放锁。</p>
</li>
</ol>
<p>测试代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread threadA </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadA());
        Thread threadB </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadB());

        threadA.setName(</span>"threadA"<span style="color: #000000;">);
        threadB.setName(</span>"threadB"<span style="color: #000000;">);

        threadA.start();
        threadB.start();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> print() {
        System.out.println(</span>"当前线程:"+Thread.currentThread().getName()+"执行Sleep"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>1000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        System.out.println(</span>"当前线程:"+Thread.currentThread().getName()+"执行Wait"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Main.</span><span style="color: #0000ff;">class</span>.wait(1000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        System.out.println(</span>"当前线程:"+Thread.currentThread().getName()+"执行完毕"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span> ThreadA <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">        Main.print();
    }

}
</span><span style="color: #0000ff;">class</span> ThreadB <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">        Main.print();
    }

}</span></code></pre>

<p>&nbsp;</p>
<p>执行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单9.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单9.png" /></p>
<p>从上面的结果可以分析出：当线程A执行sleep后，等待一秒被唤醒后继续持有锁，执行之后的代码，而执行wait之后，立即释放了锁，不仅让出了CPU还让出了锁，而后线程B立即持有锁开始执行，和线程A执行了同样的步骤，当线程B执行wait方法之后，释放锁，然后线程A拿到锁打印了第一个执行完毕，然后线程B打印执行完毕。</p>
<hr />
<h2>notify和notifyAll的区别</h2>
<h3>notify</h3>
<p>notify可以唤醒一个处于等待状态的线程，上代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Object lock </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
        Thread threadA </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;"> (lock) {
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        lock.wait();
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">                        e.printStackTrace();
                    }
                    print();

                }
            }
        });
        Thread threadB </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;"> (lock) {
                    print();
                    lock.notify();
                }

            }
        });

        threadA.setName(</span>"threadA"<span style="color: #000000;">);
        threadB.setName(</span>"threadB"<span style="color: #000000;">);

        threadA.start();
        threadB.start();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> print() {
            System.out.println(</span>"当前线程:"+Thread.currentThread().getName()+"执行print"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                Thread.sleep(</span>1000<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">                e.printStackTrace();
            }
            System.out.println(</span>"当前线程:"+Thread.currentThread().getName()+"执行完毕"<span style="color: #000000;">);

    }
}</span></code></pre>

<p>&nbsp;</p>
<p>执行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单10.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单10.png" /></p>
<p><strong>代码解释：</strong>线程A在开始执行时立即调用wait进入无限等待状态，如果没有别的线程来唤醒它，它将一直等待下去，所以此时B持有锁开始执行，并且在执行完毕时调用了notify方法，该方法可以唤醒wait状态的A线程，于是A线程苏醒，开始执行剩下的代码。</p>
<h3>notifyAll</h3>
<p>notifyAll可以用于唤醒所有等待的线程，使所有处于等待状态的线程都变为ready状态，去重新争夺锁。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Object lock </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
        Thread threadA </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;"> (lock) {
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        lock.wait();
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">                        e.printStackTrace();
                    }
                    print();

                }
            }
        });
        Thread threadB </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;"> (lock) {
                    print();
                    lock.notifyAll();
                }

            }
        });

        threadA.setName(</span>"threadA"<span style="color: #000000;">);
        threadB.setName(</span>"threadB"<span style="color: #000000;">);

        threadA.start();
        threadB.start();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> print() {
            System.out.println(</span>"当前线程:"+Thread.currentThread().getName()+"执行print"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                Thread.sleep(</span>1000<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">                e.printStackTrace();
            }
            System.out.println(</span>"当前线程:"+Thread.currentThread().getName()+"执行完毕"<span style="color: #000000;">);

    }
}</span></code></pre>

<p>&nbsp;</p>
<p>执行结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单11.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单11.png" /></p>
<p>要唤醒前一个例子中的线程A，不光notify方法可以做到，调用notifyAll方法同样也可以做到，那么两者有什么区别呢？</p>
<h3>区别</h3>
<p>要说清楚他们的区别，首先要简单的说一下Java synchronized的一些原理，在openjdk中查看java的源码可以看到，java对象中存在monitor锁，monitor对象中包含锁池和等待池。</p>
<p><strong>锁池</strong>，假设有多个对象进入synchronized块争夺锁，而此时已经有一个对象获取到了锁，那么剩余争夺锁的对象将直接进入锁池中。</p>
<p><strong>等待池</strong>，假设某个线程调用了对象的wait方法，那么这个线程将直接进入等待池，而等待池中的对象不会去争夺锁，而是等待被唤醒。</p>
<p>下面可以说notify和notifyAll的区别了：</p>
<p><strong>notifyAll会让所有处于等待池中的线程全部进入锁池去争夺锁，而notify只会随机让其中一个线程去争夺锁。</strong></p>
<hr />
<h2>yield方法</h2>
<h3>概念</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
     * A hint to the scheduler that the current thread is willing to yield
     * its current use of a processor. The scheduler is free to ignore this
     * hint.
     *
     * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
     * between threads that would otherwise over-utilise a CPU. Its use
     * should be combined with detailed profiling and benchmarking to
     * ensure that it actually has the desired effect.
     *
     * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
     * for debugging or testing purposes, where it may help to reproduce
     * bugs due to race conditions. It may also be useful when designing
     * concurrency control constructs such as the ones in the
     * {</span><span style="color: #808080;">@link</span><span style="color: #008000;"> java.util.concurrent.locks} package.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">native</span> <span style="color: #0000ff;">void</span> yield();</code></pre>

<p>&nbsp;</p>
<p>yield源码上有一段长长的注释，其大意是说：<strong>当前线程调用yield方法时，会给当前线程调度器一个暗示，当前线程愿意让出CPU的使用，但是它的作用应结合详细的分析和测试来确保已经达到了预期的效果，因为调度器可能会无视这个暗示，使用这个方法是不那么合适的，或许在测试环境中使用它会比较好。</strong></p>
<p>测试：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread threadA </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                System.out.println(</span>"ThreadA正在执行yield"<span style="color: #000000;">);
                Thread.yield();
                System.out.println(</span>"ThreadA执行yield方法完成"<span style="color: #000000;">);
            }
        });
        Thread threadB </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                System.out.println(</span>"ThreadB正在执行yield"<span style="color: #000000;">);
                Thread.yield();
                System.out.println(</span>"ThreadB执行yield方法完成"<span style="color: #000000;">);

            }
        });

        threadA.setName(</span>"threadA"<span style="color: #000000;">);
        threadB.setName(</span>"threadB"<span style="color: #000000;">);

        threadA.start();
        threadB.start();
    }</span></code></pre>

<p>&nbsp;</p>
<p>测试结果：</p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单12.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单12.png" /></p>
<p><img title="多线程基础体系知识清单" src="./images/多线程基础体系知识清单13.png" alt="多线程基础体系知识清单" data-original="./images/多线程基础体系知识清单13.png" /></p>
<p>可以看出，存在不同的测试结果，这里选出两张。</p>
<p><strong>第一种结果：</strong>线程A执行完yield方法，让出cpu给线程B执行。然后两个线程继续执行剩下的代码。</p>
<p><strong>第二种结果：</strong>线程A执行yield方法，让出cpu给线程B执行，但是线程B执行yield方法后并没有让出cpu，而是继续往下执行，此时就是系统无视了这个暗示。</p>
<hr />
<h2>interrupt方法</h2>
<h3>中止线程</h3>
<p>interrupt函数可以中断一个线程，在interrupt之前，通常使用stop方法来终止一个线程，但是stop方法过于暴力，它的特点是，不论被中断的线程之前处于一个什么样的状态，都无条件中断，这会导致被中断的线程后续的一些清理工作无法顺利完成，引发一些不必要的异常和隐患，还有可能引发数据不同步的问题。</p>
<h3>温柔的interrupt方法</h3>
<p>interrupt方法的原理与stop方法相比就显得温柔的多，当调用interrupt方法去终止一个线程时，它并不会暴力地强制终止线程，而是通知这个线程应该要被中断了，和yield一样，这也是一种暗示，至于是否应该中断，由被中断的线程自己去决定。当对一个线程调用interrupt方法时：</p>
<ol class="list-paddingleft-2">
<li>
<p>如果该线程处于被阻塞状态，则立即退出阻塞状态，抛出InterruptedException异常。</p>
</li>
<li>
<p>如果该线程处于running状态，则将该线程的中断标志位设置为true，被设置的线程继续运行，不受影响，当运行结束时由线程决定是否被中断。</p>
</li>
</ol><hr />
<h2>线程池</h2>
<p>线程池的引入是用来解决在日常开发的多线程开发中，如果开发者需要使用到非常多的线程，那么这些线程在被频繁的创建和销毁时，会对系统造成一定的影响，有可能系统在创建和销毁这些线程所耗费的时间会比完成实际需求的时间还要长。</p>
<p>另外，在线程很多的状况下，对线程的管理就形成了一个很大的问题，开发者通常要将注意力从功能上转移到对杂乱无章的线程进行管理上，这项动作实际上是非常耗费精力的。</p>
<h3>利用Executors创建不同的线程池满足不同场景的需求</h3>
<p><code>newFixThreadPool(int nThreads)</code><br />指定工作线程数量的线程池。</p>
<p><code>newCachedThreadPool()</code><br />处理大量中断事件工作任务的线程池，</p>
<ol class="list-paddingleft-2">
<li>
<p>试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程。</p>

</li>
<li>
<p>如果线程闲置的时间超过阈值，则会被终止并移出缓存。</p>

</li>
<li>
<p>系统长时间闲置的时候，不会消耗什么资源。</p>

</li>

</ol>
<p><code>newSingleThreadExecutor()</code><br />创建唯一的工作线程来执行任务，如果线程异常结束，会有另一个线程取代它。可保证顺序执行任务。</p>
<p><code>newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize)</code><br />定时或周期性工作调度，两者的区别在于前者是单一工作线程，后者是多线程</p>
<p><code>newWorkStealingPool()</code><br />内部构建ForkJoinPool，利用working-stealing算法，并行地处理任务，不保证处理顺序。</p>
<p><strong>Fork/Join框架：</strong>把大任务分割称若干个小任务并行执行，最终汇总每个小任务后得到大任务结果的框架。</p>
<h3>为什么要使用线程池</h3>
<p>线程是稀缺资源，如果无限制地创建线程，会消耗系统资源，而线程池可以代替开发者管理线程，一个线程在结束运行后，不会销毁线程，而是将线程归还线程池，由线程池再进行管理，这样就可以对线程进行复用。</p>
<p>所以线程池不但可以降低资源的消耗，还可以提高线程的可管理性。</p>
<h3>使用线程池启动线程</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        ExecutorService newFixThreadPool </span>= Executors.newFixedThreadPool(10<span style="color: #000000;">);
        newFixThreadPool.execute(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
                System.out.println("通过线程池启动线程成功"<span style="color: #000000;">);
            }
        });
        newFixThreadPool.shutdown();
    }
}</span></code></pre>

<p>&nbsp;</p>
<h3>新任务execute执行后的判断</h3>
<p>要知道这个点首先要先说说ThreadPoolExecutor的构造函数，其中有几个参数：</p>
<ol class="list-paddingleft-2">
<li>
<p><strong>corePoolSize：</strong>核心线程数量。</p>
</li>
<li>
<p><strong>maximumPoolSize：</strong>线程不够用时能创建的最大线程数。</p>
</li>
<li>
<p><strong>workQueue：</strong>等待队列。</p>
</li>
</ol>
<p>那么新任务提交后会执行下列判断：</p>
<ol class="list-paddingleft-2">
<li>
<p>如果运行的线程少于corePoolSize,则创建新线程来处理任务，即时线程池中的其它线程是空闲的。</p>
</li>
<li>
<p>如果线程池中的数量大于等于corePoolSize且小于maximumPoolSize，则只有当workQueue满时，才创建新的线程去处理任务。</p>
</li>
<li>
<p>如果设置的corePoolSize和maximumPoolSize相同，则创建的线程池大小是固定的，如果此时有新任务提交，若workQueue未满，则放入workQueue，等待被处理。</p>
</li>
<li>
<p>如果运行的线程数大于等于maximumPoolSize，maximumPoolSize,这时如果workQueue已经满了，则通过handler所指定的策略来处理任务。</p>
</li>
</ol>
<h3>handler 线程池饱和策略</h3>
<ul class="list-paddingleft-2">
<li>
<p>AbortPolicy:直接抛出异常，默认。</p>
</li>
<li>
<p>CallerRunsPolicy:用调用者所在的线程来执行任务。</p>
</li>
<li>
<p>DiscardOldestPolicy:丢弃队列中靠最前的任务，并执行当前任务。</p>
</li>
<li>
<p>DiscardPolicy:直接丢弃任务</p>
</li>
<li>
<p>自定义。</p>
</li>
</ul>
<h3>线程池的大小如何选定</h3>
<p>这个问题并不是什么秘密，在网上各大技术网站均有文章说明，我就拿一个最受认可的写上吧</p>
<ul class="list-paddingleft-2">
<li>
<p>CPU密集型：线程数 = 核心数或者核心数+1</p>
</li>
<li>
<p>IO密集型：线程数 = CPU核数*（1+平均等待时间/平均工作时间）</p>
</li>
</ul>
<p>当然这个也不能完全依赖这个公式，更多的是要依赖平时的经验来操作，这个公式也只是仅供参考而已。</p>
<hr />
<h2>结语</h2>
<p>本文提供了一些Java多线程和并发方面最最基础的知识，适合初学者了解Java多线程的一些基本知识，如果想了解更多的关于并发方面的内容可以看：</p>
<blockquote class="js_blockquote_wrap">
<p>https://juejin.im/post/5d8da403f265da5b5d203bf4</p>
</blockquote>
<p>&nbsp;</p>
<p>作者：Object，首发：Java知音</p>
<p><em><strong>推荐阅读(点击即可跳转阅读)</strong></em></p>
<p><strong>1.</strong><a href="https://www.javazhiyin.com/go?url=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488811&amp;idx=2&amp;sn=0d054027651bef114ae6bec5a8f62359&amp;chksm=ebd62a07dca1a3111269692dd9b0a5ab8af7d2038b8ec6600a057573364e76db1332adc5fd46&amp;scene=21#wechat_redirect" rel="nofollow" target="_blank">SpringBoot内容聚合</a></p>
<p><strong>2.</strong><a href="https://www.javazhiyin.com/go?url=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488811&amp;idx=3&amp;sn=b04d8fdacf575c7ec959de4107f31091&amp;chksm=ebd62a07dca1a31186f7f62de60ba7c7a88db26233562ed7183c6f609c5e7f4ffb448f30375f&amp;scene=21#wechat_redirect" rel="nofollow" target="_blank">面试题内容聚合</a></p>
<p><strong>3.</strong><a href="https://www.javazhiyin.com/go?url=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488811&amp;idx=4&amp;sn=ec20f59a5b67a59d98d221bd20d78448&amp;chksm=ebd62a07dca1a31188dafea0e6984b4883fa972a32ff31da2df6f52fcc73b56c6c9454751d73&amp;scene=21#wechat_redirect" rel="nofollow" target="_blank">设计模式内容聚合</a></p>
<p><strong>4.</strong><a href="https://www.javazhiyin.com/go?url=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488945&amp;idx=2&amp;sn=2c0326af621ac51f33720e2608121cef&amp;chksm=ebd62a9ddca1a38b8e284b413a8eea08aa452fdeda3c4740325803514d30029a2ab4af5bdfed&amp;scene=21#wechat_redirect" rel="nofollow" target="_blank">Mybatis内容聚合</a></p>
<p><strong>5.</strong><a href="https://www.javazhiyin.com/go?url=http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488811&amp;idx=6&amp;sn=a769526cf5c4dfc5b0f8e5a40f984cff&amp;chksm=ebd62a07dca1a3116cc6c45ceb7a81d47293b9811c8df97b5ca363c6370ffccfd913bab3599f&amp;scene=21#wechat_redirect" rel="nofollow" target="_blank">多线程内容聚合</a></p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>