<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【Struts2】简介及入门' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【Struts2】简介及入门</center></div><div class='banquan'>原文出处:本文由博客园博主这个世界~提供。<br/>
原文连接:https://www.cnblogs.com/haoworld/p/struts2-jian-jie-ji-ru-men.html</div><br>
    <ul>
<li>
<a href="#toc_0">一、概述</a>
</li>
<li>
<a href="#toc_1">二、Struts2 快速入门程序</a>
<ul>
<li>
<a href="#toc_2">2.1 开发流程比较</a>
</li>
<li>
<a href="#toc_3">2.2 引入依赖</a>
</li>
<li>
<a href="#toc_4">2.2 创建jsp页面</a>
</li>
<li>
<a href="#toc_5">2.3 在web.xml中配置前端控制器</a>
</li>
<li>
<a href="#toc_6">2.4 创建struts.xml配置文件</a>
</li>
<li>
<a href="#toc_7">2.4 创建一个HelloAction类</a>
</li>
<li>
<a href="#toc_8">2.5 在struts.xml文件中配置HelloAction</a>
</li>
<li>
<a href="#toc_9">2.6 在index.jsp中添加连接，测试</a>
</li>
<li>
<a href="#toc_10">2.7 测试</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">三、对入门程序进行流程分析</a>
<ul>
<li>
<a href="#toc_12">3.1 创建项目，引入Maven依赖</a>
</li>
<li>
<a href="#toc_13">3.2 自定义StrusFilter 过滤器</a>
</li>
<li>
<a href="#toc_14">3.3 流程分析</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">四、Struts2配置</a>
<ul>
<li>
<a href="#toc_16">4.1 Struts2 配置文件加载顺序</a>
</li>
<li>
<a href="#toc_17">4.2 关于Action的配置</a>
</li>
<li>
<a href="#toc_18">4.3 关于action配置其它细节：</a>
</li>
<li>
<a href="#toc_19">4.4 关于常量配置</a>
</li>
<li>
<a href="#toc_20">3.5 struts.xml文件的分离:</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">五、Action</a>
<ul>
<li>
<a href="#toc_22">5.1 Action类的创建方式</a>
</li>
<li>
<a href="#toc_23">5.2 关于action的访问</a>
</li>
<li>
<a href="#toc_24">5.3 在struts2框架中获取servlet api</a>
</li>
<li>
<a href="#toc_25">5.4 Result结果类型</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">一、概述</h2>

<ol>
<li>问题:什么是框架，框架有什么用?
<ul>
<li>框架 是 实现部分功能的代码 （半成品），使用框架简化企业级软件开发 ,提高开发效率。</li>
<li>学习框架 ，要清楚的知道框架能做什么，还有哪些工作需要自己编码实现 </li>
</ul></li>
<li>问题:什么是Struts2框架，它有什么用?
<ul>
<li>Struts2 是Struts的下一代产品，是在 Struts1 和 WebWork 的技术基础上进行了合并的全新的Struts2框架。其全新的Struts2的体系结构与Struts1的体系结构差别巨大。Struts2以WebWork为核心,Struts2=Struts1+Webwork </li>
<li>Struts2框架是Apache产品。</li>
<li>Struts2是一个标准的MVC框架。</li>
<li>JavaWeb中的 Model2 模式就是一个mvc模式</li>
<li>Model2=Servlet+Jsp+JavaBean</li>
<li>Struts2框架是在Javaweb开发中使用的。</li>
<li>使用Struts2框架，可以简化我们的web开发，并且降低程序的耦合度。</li>
</ul></li>
<li>类似于struts2框架的产品 : 
<ul>
<li>Struts1  Webwork  Jsf  Springmvc</li>
<li>SSH --- Struts2 + Spring + Hibernate</li>
<li>SSM --- SpringMVC + Spring + Mbatis</li>
</ul></li>
<li>XWork --- 它是WebWork核心
<ul>
<li>Xwork提供了很多核心功能：前端拦截机（interceptor），运行时表单属性验证，类型转换，强大的表达式语言（OGNL – the Object Graph Navigation Language），IoC（Inversion of Control反转控制）容器等</li>
</ul></li>
</ol>

<h2 id="toc_1">二、Struts2 快速入门程序</h2>

<h3 id="toc_2">2.1 开发流程比较</h3>

<ul>
<li>Web开发流程：index.jsp------&gt;HelloServlet--------&gt;hello.jsp<br/></li>
<li>Struts2流程：index.jsp------&gt;HelloAction---------&gt;hello.jsp<br/></li>
</ul>

<h3 id="toc_3">2.2 引入依赖</h3>

<pre><code><code class="language-markup">&lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;
    &lt;artifactId&gt;struts2-core&lt;/artifactId&gt;
    &lt;version&gt;2.3.16.3&lt;/version&gt;
&lt;/dependency&gt;
</code></code></pre>

<h3 id="toc_4">2.2 创建jsp页面</h3>

<ul>
<li>创建index.jsp页面(后面修改)</li>
<li>创建hello.jsp页面(内容如下)</li>
</ul>

<pre><code><code class="language-jsp">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
  &lt;head&gt; 
    &lt;title&gt;My JSP &#39;index.jsp&#39; starting page&lt;/title&gt;
  &lt;/head&gt;
  
  &lt;body&gt;
    &lt;h1&gt;hello Struts2&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></code></pre>

<h3 id="toc_5">2.3 在web.xml中配置前端控制器</h3>

<ul>
<li>在web.xml文件中配置前端控制器(核心控制器)-----就是一个Filter</li>
</ul>

<pre><code><code class="language-markup">&lt;filter&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></code></pre>

<h3 id="toc_6">2.4 创建struts.xml配置文件</h3>

<ul>
<li>在src下(classes下)创建一个struts.xml配置文件 ,这个是struts2框架配置文件。</li>
</ul>

<h3 id="toc_7">2.4 创建一个HelloAction类</h3>

<ul>
<li>要求，在HelloAction类中创建一个返回值是String类型的方法，注意，无参数。</li>
</ul>

<pre><code><code class="language-java">public class HelloAction {
    
    public String say() {
        return &quot;good&quot;;
    }
}
</code></code></pre>

<h3 id="toc_8">2.5 在struts.xml文件中配置HelloAction</h3>

<pre><code><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;

&lt;struts&gt;

    &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;
        &lt;action name=&quot;hello&quot; class=&quot;com.hao.action.HelloAction&quot;
            method=&quot;say&quot;&gt;
            &lt;result name=&quot;good&quot;&gt;/hello.jsp&lt;/result&gt;
        &lt;/action&gt;
    &lt;/package&gt;
    
&lt;/struts&gt;
</code></code></pre>

<h3 id="toc_9">2.6 在index.jsp中添加连接，测试</h3>

<pre><code><code class="language-jsp">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
  &lt;head&gt;  
    &lt;title&gt;My JSP &#39;index.jsp&#39; starting page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;a href=&quot;${pageContext.request.contextPath}/hello&quot;&gt;第一次使用struts2&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></code></pre>

<h3 id="toc_10">2.7 测试</h3>

<ul>
<li>在地址栏中输入:<code>http://localhost:8080/Struts2-001-EntryP/index.jsp</code> 访问连接，就可以看到 HelloAction类中的say方法执行了，也跳转到了hello.jsp.</li>
</ul>

<h2 id="toc_11">三、对入门程序进行流程分析</h2>

<ul>
<li>模仿struts2流程完成入门程序:</li>
</ul>

<h3 id="toc_12">3.1 创建项目，引入Maven依赖</h3>

<pre><code><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;
    &lt;artifactId&gt;struts2-core&lt;/artifactId&gt;
    &lt;version&gt;2.3.16.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.0-alpha-1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/dom4j/dom4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;dom4j&lt;/groupId&gt;
    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;
    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;
    &lt;version&gt;1.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></code></pre>

<h3 id="toc_13">3.2 自定义StrusFilter 过滤器</h3>

<ul>
<li>1.创建一个Filter----StrutsFilter</li>
<li>2.在web.xml文件中配置StrutsFilter</li>
</ul>

<pre><code><code class="language-markup">&lt;!DOCTYPE web-app PUBLIC
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
 &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app&gt;
  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;StrutsFilter&lt;/filter-name&gt;
    &lt;display-name&gt;StrutsFilter&lt;/display-name&gt;
    &lt;description&gt;&lt;/description&gt;
    &lt;filter-class&gt;com.hao.filter.StrutsFilter&lt;/filter-class&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;StrutsFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></code></pre>

<ul>
<li>3.在StrutsFilter中完成拦截操作，并访问Action中的方法，跳转到hello.jsp页面操作.</li>
</ul>

<pre><code><code class="language-java">public class StrutsFilter implements Filter {

    public void init(FilterConfig filterConfig) throws ServletException {

    }

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)
            throws IOException, ServletException {

        // 1.强转
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;

        // 2.操作

        // 2.1 得到请求资源路径
        String uri = request.getRequestURI();
        String contextPath = request.getContextPath();
        String path = uri.substring(contextPath.length() + 1);

        // System.out.println(path); // hello

        // 2.2 使用path去struts.xml文件中查找某一个&lt;action name=path&gt;这个标签
        SAXReader reader = new SAXReader();

        try {
            // 得到struts.xml文件的document对象。
            Document document = reader.read(new File(this.getClass().getResource(&quot;/struts.xml&quot;).getPath()));

            Element actionElement = (Element) document.selectSingleNode(&quot;//action[@name=&#39;&quot; + path + &quot;&#39;]&quot;); // 查找&lt;action
                                                                                                            // name=&#39;hello&#39;&gt;这样的标签

            if (actionElement != null) {
                // 得到&lt;action&gt;标签上的class属性以及method属性
                String className = actionElement.attributeValue(&quot;class&quot;); // 得到了action类的名称
                String methodName = actionElement.attributeValue(&quot;method&quot;);// 得到action类中的方法名称。

                // 2.3通过反射，得到Class字节码对象，得到Method对象
                Class&lt;?&gt; actionClass = Class.forName(className);
                Method method = actionClass.getDeclaredMethod(methodName);

                // 处理请求参数封装:

                Object actionObj = actionClass.newInstance();

                // 2.模型驱动
                if (actionObj instanceof MyModelDriven) {
                    MyModelDriven mmd = (MyModelDriven) actionObj;

                    BeanUtils.populate(mmd.getModel(), request.getParameterMap());
                } else {
                    // 1.属性驱动
                    BeanUtils.populate(actionObj, request.getParameterMap());//
                }

                // 2.4 让method执行.
                String returnValue = (String) method.invoke(actionObj); // 是让action类中的方法执行，并获取方法的返回值。

                // 2.5
                // 使用returnValue去action下查找其子元素result的name属性值，与returnValue做对比。
                Element resultElement = actionElement.element(&quot;result&quot;);
                String nameValue = resultElement.attributeValue(&quot;name&quot;);

                if (returnValue.equals(nameValue)) {
                    // 2.6得到了要跳转的路径。
                    String skipPath = resultElement.getText();

                    // System.out.println(skipPath);

                    request.getRequestDispatcher(skipPath).forward(request, response);
                    return;
                }
            }

        } catch (DocumentException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (SecurityException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }

        // 3.放行
        chain.doFilter(request, response);

    }

    public void destroy() {
    }

}
</code></code></pre>

<h3 id="toc_14">3.3 流程分析</h3>

<ul>
<li>请求 ---- StrutsPrepareAndExecuteFilter 核心控制器 ----- Interceptors 拦截器（实现代码功能 ） ----- Action 的execute --- 结果页面 Result </li>
</ul>

<h2 id="toc_15">四、Struts2配置</h2>

<h3 id="toc_16">4.1 Struts2 配置文件加载顺序</h3>

<ul>
<li>Struts2框架要能执行，必须先加载StrutsPrepareAndExecuteFilter.</li>
<li>在StrutsPrepareAndExecuteFilter的init方法中对Dispatcher进行了初始化.</li>
<li>在Dispatcher类中定义的init方法内就描述了struts2配置文件加载的顺序</li>
</ul>

<pre><code><code class="language-java">// [1]   org/apache/struts2/default.properties 
init_DefaultProperties();
// [2]  struts-default.xml,struts-plugin.xml,struts.xml 
init_TraditionalXmlConfigurations(); 
// [3] --- 自定义struts.properties  (源码中的注释没有[4])
init_LegacyStrutsProperties(); 
// [5]  ----- 自定义配置提供
init_CustomConfigurationProviders(); 
// [6] ----- web.xml 
init_FilterInitParameters() ; 
// [7] ---- Bean加载 
init_AliasStandardObjects() ; 
</code></code></pre>

<pre><code><code class="language-txt">1.default.properties文件
    作用:定义了struts2框架中所有常量
    位置: org/apache/struts2/default.properties ,struts2-core.jar包下
    
2.struts-default.xml
    作用:配置了bean,interceptor,result等。
    位置:在struts的core核心jar包.
    
  struts-plugin.xml
    它是struts2框架中所使用的插件的配置文件。
  struts.xml              
    我们使struts2所使用的配置文件。
        
3.自定义的struts.properties
    我们可以自定义常量。
    
4.web.xml
    
在开发中，后加载文件中的配置会将先加载文件中的配置覆盖。我们一般要记住如下顺序即可：
default.properties
struts-default.xml
struts.xml
</code></code></pre>

<h3 id="toc_17">4.2 关于Action的配置</h3>

<ol>
<li><code>&lt;package&gt;</code>  作用:是用于声明一个包。用于管理action。它的常用属性如下
<ul>
<li>name: 它用于声明一个包名，包名不能重复，也就是它是唯一的。 </li>
<li>namespace: 它与action标签的name属性合并确定了一个唯一访问action的路径。</li>
<li>extends: 它代表继承的包名。</li>
<li>abstrace: 它可以取值为true/false,如果为true,代表这个包是用于被继承的。</li>
</ul></li>
<li><code>&lt;action&gt;</code>  用于声明 一个action，它的常用属性如下：
<ul>
<li>name: 就是action的一个名称，它是唯一的(在同包内) 它与package中的namespace确定了访问action的路径。</li>
<li>class: Action类的全名</li>
<li>method: 要访问的Action类中的方法的名称,方法无参数 ，返回值为String.</li>
</ul></li>
<li><code>&lt;result&gt;</code> 用于确定返回结果类型,它的常用属性如下：
<ul>
<li>name  它与action中的方法返回值做对比，确定跳转路径。</li>
</ul></li>
</ol>

<h3 id="toc_18">4.3 关于action配置其它细节：</h3>

<ol>
<li>关于默认值问题
<ul>
<li><code>&lt;package namespace=&quot;默认值&quot;&gt;</code> -- namespace的默认值是 <code>&quot;&quot;</code></li>
<li><code>&lt;action class=&quot;默认值&quot;  method=&quot;默认值&quot;&gt;</code> -- class的默认值是  <code>&quot;com.opensymphony.xwork2.ActionSupport&quot;</code> ，method的默认值是execute</li>
<li><code>&lt;result  name=&quot;默认值&quot;&gt;</code> name的默认值是 <code>&quot;success&quot;</code></li>
</ul></li>
<li><p>关于访问action的路径问题  ,现在的action的配置是: </p>
<pre><code><code class="language-markup">&lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;
&lt;action name=&quot;hello&quot; class=&quot;com.hao.action.DefaultAction&quot;&gt;<br/>
    &lt;result&gt;/hello.jsp&lt;/result&gt;<br/>
&lt;/action&gt;<br/>
&lt;/package&gt;
</code></code></pre>
<ul>
<li>当我们输入:    <code>http://localhost/Struts2-003-ExerConfig/a/b/c/hello</code>, 也可以访问到了action。</li>
<li>原因:struts2中的action被访问时，它会首先查找</li>
<li>
<code>txt
1.namespace=&quot;/a/b/c&quot;   action的name=hello  没有.<br/>
2.namespace=&quot;/a/b      action的name=hello  没有<br/>
3.namespace=&quot;/a&quot;       action的name=hello  没有<br/>
4.namespace=&quot;/&quot;        action的name=hello  查找到了.
</code><br/></li>
<li>如果最后也查找不到，会报404错误.</li>
</ul></li>
<li><p>默认的action。</p>
<ul>
<li>作用:处理其它action处理不了的路径。</li>
<li><code>&lt;default-action-ref name=&quot;action的名称&quot; /&gt;</code> ，配置了这个，当访问的路径，其它的action处理不了时，就会执行name指定的名称的action。</li>
</ul></li>
<li><p>action的默认处理类</p>
<ul>
<li>在action配置时，如果class不写。默认情况下是<code>com.opensymphony.xwork2.ActionSupport</code></li>
<li><code>&lt;default-class-ref class=&quot;com.hao.action.DefaultAction&quot;/&gt;</code>,如果设置这个了，那么在当前包下，默认处理action请的的处理类就为class指定的类。</li>
</ul></li>
</ol>

<h3 id="toc_19">4.4 关于常量配置</h3>

<ul>
<li>default.properties 它声明了struts中的常量。</li>
<li><p>问题:人为设置常量，可以在哪些位置设置 ？</p>
<ul>
<li>1.struts.xml(应用最多)，<code>&lt;constant name=&quot;常量名称&quot; value=&quot;常量值&quot;&gt;&lt;/constant&gt;</code></li>
<li>2.struts.properties（基本不使用）</li>
<li>3.web.xml(了解)，配置常量，是使用StrutsPrepareAndExecuteFilter的初始化参数来配置的.<br/></li>
</ul>
<pre><code><code class="language-markup">&lt;init-param&gt;
    &lt;param-name&gt;struts.action.extension&lt;/param-name&gt;<br/>
    &lt;param-value&gt;do,,&lt;/param-value&gt;<br/>
&lt;/init-param&gt;
</code></code></pre></li>
<li><p>常用常量</p>
<ul>
<li><code>struts.action.extension=action,,</code> -- 这个常量用于指定strus2框架默认拦截的后缀名.</li>
<li><code>&lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;UTF-8&quot;/&gt;</code> -- 相当于<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code> 解决post请求乱码 </li>
<li><code>&lt;constant name=&quot;struts.serve.static.browserCache&quot; value=&quot;false&quot;/&gt;</code> -- false不缓存，true浏览器会缓存静态内容，生产环境设置true、开发环境设置false </li>
<li><code>&lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt;</code> ， 提供详细报错页面，修改struts.xml后不需要重启服务器 </li>
</ul></li>
</ul>

<h3 id="toc_20">3.5 struts.xml文件的分离:</h3>

<ul>
<li>目的:就是为了阅读方便。可以让一个模块一个配置文件，在struts.xml文件中通过<code>&lt;include file=&quot;test.xml&quot;/&gt;</code> 导入其它的配置文件。</li>
</ul>

<h2 id="toc_21">五、Action</h2>

<h3 id="toc_22">5.1 Action类的创建方式</h3>

<ul>
<li><p>三种创建方式</p></li>
</ul>

<ol>
<li>创建一个POJO类.
<ul>
<li>简单的Java对象(Plain Old Java Objects)</li>
<li>指的是没有实现任何接口，没有继承任何父类(除了Object)</li>
<li>优点:无耦合。</li>
<li>缺点：所有工作都要自己实现。</li>
<li>在struts2框架底层是通过反射来操作:
<ul>
<li>struts2框架 读取struts.xml 获得 完整Action类名 </li>
<li>obj = Class.forName(&quot;完整类名&quot;).newInstance();</li>
<li>Method m = Class.forName(&quot;完整类名&quot;).getMethod(&quot;execute&quot;);  m.invoke(obj); 通过反射 执行 execute方法</li>
</ul></li>
</ul></li>
<li><p>创建一个类，实现Action接口.(<code>com.opensymphony.xwork2.Action</code>)</p>
<ul>
<li>优点:耦合低。提供了五种结果视图，定义了一个行为方法。</li>
<li>缺点:所有工作都要自己实现。</li>
</ul>
<pre><code><code class="language-java">public static final String SUCCESS = &quot;success&quot;;  // 数据处理成功 （成功页面）
public static final String NONE = &quot;none&quot;;  // 页面不跳转  return null; 效果一样<br/>
public static final String ERROR = &quot;error&quot;;  // 数据处理发送错误 (错误页面)<br/>
public static final String INPUT = &quot;input&quot;; // 用户输入数据有误，通常用于表单数据校验 （输入页面）<br/>
public static final String LOGIN = &quot;login&quot;; // 主要权限认证 (登陆页面)
</code></code></pre></li>
<li><p>创建一个类，继承自ActionSupport类. (<code>com.opensymphony.xwork2.ActionSupport</code>)</p>
<ul>
<li>ActionSupport类实现了Action接口。</li>
<li>优点:表单校验、错误信息设置、读取国际化信息 三个功能都支持.</li>
<li>缺点:耦合度高。</li>
<li>在开发中，第三种会使用的比较多.</li>
</ul></li>
</ol>

<h3 id="toc_23">5.2 关于action的访问</h3>

<ul>
<li>1.通过设置method的值，来确定访问action类中的哪一个方法.
<ul>
<li><code>&lt;action name=&quot;book_add&quot; class=&quot;com.hao.action.BookAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt;</code></li>
<li>当访问的是book_add,这时就会调用BookAction类中的add方法。</li>
<li><code>&lt;action name=&quot;book_update&quot; class=&quot;com.hao.action.BookAction&quot; method=&quot;update&quot;&gt;&lt;/action&gt;</code></li>
<li>当访问的是book_update,这时就会调用BookAction类中的update方法。</li>
</ul></li>
<li><p>2.使用通配符来简化配置</p>
<ul>
<li>在struts.xml文件 中配置 </li>
<li><code>&lt;action name=&quot;*_*&quot; class=&quot;com.hao.action.{1}Action&quot; method=&quot;{2}&quot;&gt;&lt;/action&gt;</code></li>
<li>jsp页面 </li>
<li>book.jsp</li>
</ul>
<pre><code><code class="language-jsp">&lt;a href=&quot;${pageContext.request.contextPath}/Book_add&quot;&gt;book add&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;${pageContext.request.contextPath}/Book_update&quot;&gt;book update&lt;/a&gt;&lt;br&gt;<br/>
&lt;a href=&quot;${pageContext.request.contextPath}/Book_delete&quot;&gt;book delete&lt;/a&gt;&lt;br&gt;<br/>
&lt;a href=&quot;${pageContext.request.contextPath}/Book_search&quot;&gt;book search&lt;/a&gt;&lt;br&gt;
</code></code></pre>
<ul>
<li>product.jsp</li>
</ul>
<pre><code><code class="language-jsp">&lt;a href=&quot;${pageContext.request.contextPath}/Product_add&quot;&gt;product add&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;${pageContext.request.contextPath}/Product_update&quot;&gt;product update&lt;/a&gt;&lt;br&gt;<br/>
&lt;a href=&quot;${pageContext.request.contextPath}/Product_delete&quot;&gt;product delete&lt;/a&gt;&lt;br&gt;<br/>
&lt;a href=&quot;${pageContext.request.contextPath}/Product_search&quot;&gt;product search&lt;/a&gt;&lt;br&gt;
</code></code></pre>
<ul>
<li>当访问book add时，这时的路径是  Book_add,那么对于struts.xml文件中.</li>
<li>第一个 <code>*</code> 就是 Book</li>
<li>第二个 <code>*</code> 就是 add</li>
<li>对于{1}Action----&gt;BookAction</li>
<li>对于method={2}---&gt;method=add</li>
<li>使用通配符来配置注意事项:</li>
<li>1.必须定义一个统一的命名规范。</li>
<li>2.不建议使用过多的通配符，阅读不方便。</li>
</ul></li>
<li><p>3.动态方法调用  (了解)</p>
<ul>
<li>在struts.xml文件中</li>
<li><code>&lt;action name=&quot;book&quot; class=&quot;com.hao.action.BookAction&quot;&gt;&lt;/action&gt;</code>
访问时路径: <code>http://localhost/Struts2-003-ExerConfig/book!add</code><br/>
就访问到了BookAction类中的add方法。</li>
<li>对于<code>book!add</code> 这就是动态方法调用。</li>
<li>注意：struts2框架支持动态方法调用，是因为在default.properties配置文件中设置了,动态方法调用为true.
<code>struts.enable.DynamicMethodInvocation = true</code><br/></li>
</ul></li>
</ul>

<h3 id="toc_24">5.3 在struts2框架中获取servlet api</h3>

<ul>
<li>对于struts2框架，不建议直接使用servlet api;</li>
<li><p>在struts2中获取servlet api有三种方式:</p></li>
<li><p>1.通过ActionContext来获取</p>
<ul>
<li>获取一个ActionContext对象。
<code>ActionContext context=ActionContext.getContext()</code></li>
<li>获取servlet api</li>
<li>注意:通过ActionContext获取的不是真正的Servlet api,而是一个Map集合。</li>
</ul>
<pre><code><code class="language-java">1.context.getApplication()
2.context.getSession()<br/>
3.context.getParameter();---得到的就相当于request.getParameterMap()<br/>
4.context.put(String,Object) 相当于request.setAttribute(String,String);
</code></code></pre></li>
<li><p>2.注入方式获取(这种方式是真正的获取到了servlet api)</p>
<ul>
<li>要求action类必须实现提定接口。</li>
<li>ServletContextAware ：注入ServletContext对象</li>
<li>ServletRequestAware ：注入 request对象</li>
<li><p>ServletResponseAware ：注入response对象</p></li>
<li><p>重写接口中的方法。         </p></li>
<li><p>声明一个web对象，使用接口中的方法的参数对声明的web对象赋值. </p></li>
</ul>
<pre><code><code class="language-java">//获取servlet api  通过注入方式
public class ServletDemo2Action extends ActionSupport implements<br/>
    ServletRequestAware {<br/>
private HttpServletRequest request;<br/>
@Override<br/>
public String execute() throws Exception {<br/>
    System.out.println(request.getParameter(&quot;username&quot;));<br/>
    return null;<br/>
}<br/>
public void setServletRequest(HttpServletRequest request) {<br/>
    this.request = request;<br/>
}<br/>
}
</code></code></pre>
<ul>
<li>扩展:分析其实现,是使用struts2中的一个interceptor完成的.（ struts-default.xml中的拦截器）</li>
</ul>
<pre><code><code class="language-markup">&lt;interceptor name=&quot;servletConfig&quot; class=&quot;org.apache.struts2.interceptor.ServletConfigInterceptor&quot;/&gt;
</code></code></pre>
<pre><code><code class="language-java">     if (action instanceof ServletRequestAware) { //判断action是否实现了ServletRequestAware接口
        HttpServletRequest request = (HttpServletRequest) context.get(HTTP_REQUEST); //得到request对象.<br/>
        ((ServletRequestAware) action).setServletRequest(request);//将request对象通过action中重写的方法注入。<br/>
    }
</code></code></pre></li>
<li><p>3.通过ServletActionContext获取.在ServletActionContext中方法都是static。</p></li>
</ul>

<pre><code><code class="language-java">//获取servlet api  通过ServletActionContext获取
public class ServletDemo3Action extends ActionSupport {

    @Override
    public String execute() throws Exception {
        HttpServletRequest request = ServletActionContext.getRequest();

        System.out.println(request.getParameter(&quot;username&quot;));
        return SUCCESS;
    }

}
</code></code></pre>

<h3 id="toc_25">5.4 Result结果类型</h3>

<ul>
<li><result>标签</li>
<li>1.name  与action中的method的返回值匹配，进行跳转.</li>
<li>2.type  作用:是用于定义跳转方式</li>
<li>对于type属性它的值有以下几种:在struts-default.xml文件中定义了type可以取的值</li>
</ul>

<pre><code><code class="language-markup">&lt;result-type name=&quot;chain&quot; class=&quot;com.opensymphony.xwork2.ActionChainResult&quot;/&gt;
&lt;result-type name=&quot;dispatcher&quot; class=&quot;org.apache.struts2.dispatcher.ServletDispatcherResult&quot; default=&quot;true&quot;/&gt;
&lt;result-type name=&quot;freemarker&quot; class=&quot;org.apache.struts2.views.freemarker.FreemarkerResult&quot;/&gt;
&lt;result-type name=&quot;httpheader&quot; class=&quot;org.apache.struts2.dispatcher.HttpHeaderResult&quot;/&gt;
&lt;result-type name=&quot;redirect&quot; class=&quot;org.apache.struts2.dispatcher.ServletRedirectResult&quot;/&gt;
&lt;result-type name=&quot;redirectAction&quot; class=&quot;org.apache.struts2.dispatcher.ServletActionRedirectResult&quot;/&gt;
&lt;result-type name=&quot;stream&quot; class=&quot;org.apache.struts2.dispatcher.StreamResult&quot;/&gt;
&lt;result-type name=&quot;velocity&quot; class=&quot;org.apache.struts2.dispatcher.VelocityResult&quot;/&gt;
&lt;result-type name=&quot;xslt&quot; class=&quot;org.apache.struts2.views.xslt.XSLTResult&quot;/&gt;
&lt;result-type name=&quot;plainText&quot; class=&quot;org.apache.struts2.dispatcher.PlainTextResult&quot; /&gt;
</code></code></pre>

<ul>
<li>必会: chain  dispatcher  redirect redirectAction  stream</li>
<li>dispatcher:它代表的是请求转发，也是默认值。它一般用于从action跳转到页面。</li>
<li>chain:它也相当于请求转发。它一般情况下用于从一个action跳转到另一个action。</li>
<li>redirect:它代表的是重定向  它一般用于从action跳转到页面</li>
<li>redirectAction: 它代表的是重定向  它一般用于从action跳转另一个action。</li>
<li><p>stream:代表的是服务器端返回的是一个流，一般用于下载。</p></li>
<li><p>局部结果页面与全局结果页面</p></li>
</ul>

<pre><code><code class="language-markup">&lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;
    &lt;!-- 全局结果页面 --&gt;
    &lt;global-results&gt;
        &lt;result&gt;/demo1_success.jsp&lt;/result&gt;
    &lt;/global-results&gt;

    &lt;action name=&quot;demo1&quot; class=&quot;com.hao.action.ServletDemo1Action&quot;&gt;
        &lt;!-- 局部结果页面 --&gt;
    &lt;/action&gt;

    &lt;action name=&quot;demo2&quot; class=&quot;com.hao.action.ServletDemo2Action&quot;&gt;
        &lt;!-- &lt;result&gt;/demo1_success.jsp&lt;/result&gt; --&gt;
    &lt;/action&gt;

    &lt;action name=&quot;demo3&quot; class=&quot;com.hao.action.ServletDemo3Action&quot;&gt;
        &lt;!-- &lt;result type=&quot;redirect&quot;&gt;/demo1_success.jsp&lt;/result&gt; --&gt;
    &lt;/action&gt;

&lt;/package&gt;
</code></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>