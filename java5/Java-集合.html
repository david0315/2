<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java-集合' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java-集合</center></div><div class='banquan'>原文出处:本文由博客园博主y-zlong提供。<br/>
原文连接:https://www.cnblogs.com/y-zlong/p/11643132.html</div><br>
    <p>　　集合看作一宗容器，保存一组元素；</p>
<p>　　对比数组：</p>
<p>　　　　1，数组使用时必须指定长度；</p>
<p>　　　　2，长度一旦指定，就不能更改</p>
<p>　　　　示例：</p>
<p>　　　　　　Person[] pers = new Person[3];</p>
<p>&nbsp;</p>
<p>　　　　集合示例：</p>
<p>　　　　</p>
<src class="cnblogs_Highlighter">
<pre><code>List list = new ArrayLsit();

list.add(new Person());
list.add(new Person());
list.add(new Person());
</code></pre>

<p>　　面向对象都是对象的形式体现，为了方便对对象的存储，数组对对象的存储就出现了弊端，这时候集合就完美的解决了这个问题，（集合就是在数组的基础上进行了封装提供了好用快捷的方法实现了动态把多个对象放引入到集合中）</p>
<p>&nbsp;</p>
<p>集合的框架体系：</p>
<p>　　　　|----Collection</p>
<p>　　　　　　|----List&nbsp; &nbsp; (可以保存可重复的元素；可以保证插入取出元素顺序的一致性)</p>
<p>　　　　　　　　|----ArrayList</p>
<p>　　　　　　　　|----LinkedList</p>
<p>　　　　　　　　|----Vector</p>
<p>　　　　　　|----Set　 （不可以保存重复元素；不可以保证插入取出顺序的一致性）</p>
<p>　　　　　　　　|----HashSet</p>
<p>　　　　　　　　|----TreeSet</p>
<p>　　　　|----Map</p>
<p>　　　　　　　　|----HashMap</p>
<p>　　　　　　　　|----HashTable</p>
<p>　　　　　　　　|----TreeMap</p>
<p>　　　　　　　　|----Properties</p>
<h3>&nbsp;collection接口的特点和使用：</h3>
<p>　　里面保存了一组对象，有的可以重复，有的不可以重复。有的是有序的，有的是无序的。</p>
<p>　　没有提供直接的实现类，而提供了子接口&nbsp; List 和 set</p>
<h3>常见的方法：</h3>
<table style="border-color: #99ffff; border-width: 0px; height: 110px; width: 576px;" dir="ltr" border="0" align="left">
<tbody>
<tr>
<td>Boolean</td>
<td>&nbsp;add（E,O）;添加方法，向集合中添加对象元素</td>
</tr>
<tr>
<td>Boolean</td>
<td>remove（Object，o）；删除集合中的对象元素</td>
</tr>
<tr>
<td>Boolean</td>
<td>contains（Object，o）；查找集合中的对象元素</td>
</tr>
<tr>
<td>Boolean</td>
<td>addAll（collecton c）；批量向集合对象中添加元素</td>
</tr>
<tr>
<td>int</td>
<td>
<p>size（）；获取实际元素个数</p>
</td>
</tr>
<tr>
<td>Boolean</td>
<td>
<p>removeAll（conllection c）；批量删除集合中的元素</p>
</td>
</tr>
<tr>
<td>Boolean</td>
<td>
<p>isEmpty（）；判断集合是否为空，如果为空返回true，否则返回false</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>&nbsp;迭代器iterator遍历集合元素：</h3>
<p>　　工作原理和特点：</p>
<ol>
<li>当调用iterator遍历集合元素的时候，默认指向集合的最上方；</li>
<li>每次调用next（）方法进行下移，并且不能下移；</li>
<li>一般使用迭代器可以进行读取操作，不能进行删除，若要删除可以使用迭代器本身的方法【remove（）方法】；增加不可以，修改只能修改对象的属性，不能修改内存地址；<br />
<table style="height: 92px; width: 437px;" border="0" align="left">
<tbody>
<tr>
<td>增</td>
<td>&times;&nbsp; &nbsp;不能增加</td>















</tr>
<tr>
<td>删</td>
<td>&radic;&nbsp; &nbsp;自能使用迭代器自带的remove方法删除</td>















</tr>
<tr>
<td>改</td>
<td>&radic;&nbsp; &nbsp;只能修改元素对象的属性，地址不能修改</td>















</tr>
<tr>
<td>查</td>
<td>&radic;&nbsp; &nbsp;&nbsp;</td>















</tr>















</tbody>















</table>















</li>















</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　调用next（）方法之前会调用hasnext（）方法判断下一个元素是否存在，如果有下一个元素返回true，没有则返回false；　</p>
<p>　　</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 2</span>         Collection col = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
</span><span style="color: #008080;"> 3</span>         col.add(<span style="color: #0000ff;">new</span> Book("西游记", 12.0, "吴承恩"<span style="color: #000000;">));
</span><span style="color: #008080;"> 4</span>         col.add(<span style="color: #0000ff;">new</span> Book("水浒", 12.0, "施耐庵"<span style="color: #000000;">));
</span><span style="color: #008080;"> 5</span>         col.add(<span style="color: #0000ff;">new</span> Book("三国", 12.0, "罗贯中"<span style="color: #000000;">));
</span><span style="color: #008080;"> 6</span>         col.add(<span style="color: #0000ff;">new</span> Book("红楼梦", 12.0, "曹雪芹"<span style="color: #000000;">));
</span><span style="color: #008080;"> 7</span>         <span style="color: #008000;">//</span><span style="color: #008000;">col.add(new Book("西游记", 12.0, "吴承恩"));</span>
<span style="color: #008080;"> 8</span>         
<span style="color: #008080;"> 9</span>         Iterator iterator =<span style="color: #000000;"> col.iterator();
</span><span style="color: #008080;">10</span>         
<span style="color: #008080;">11</span>         <span style="color: #0000ff;">while</span><span style="color: #000000;">(iterator.hasNext()) {
</span><span style="color: #008080;">12</span>             Object next =<span style="color: #000000;"> iterator.next();
</span><span style="color: #008080;">13</span> <span style="color: #000000;">            System.out.println(next);
</span><span style="color: #008080;">14</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">15</span>         
<span style="color: #008080;">16</span>     }</code></pre>

<p>&nbsp;</p>
<hr />
<table style="height: 88px; width: 636px;" border="0" align="left">
<tbody>
<tr>
<td>boolean</td>
<td>hasnext();判断下一个对象元素是否存在，存在返回true，不存在返回false。</td>
</tr>
<tr>
<td>E</td>
<td>next（）；下一个</td>
</tr>
<tr>
<td>default void</td>
<td>remove（）；删除元素对象</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>方式二：使用增强for循环遍历</p>
<p>　　增强for循环时JDK1.5推出的用来代替iterator迭代器的，主要用于遍历集合和数组，其简化了iterator，但其实本质也是iterator；</p>
<p>　　因为foreach循环迭代的本质是iterator，所以符合迭代器的特性；如上所示；（迭代过程中的删除建议使用iterator）；</p>
<p>&nbsp;</p>
<h3>LIst接口</h3>
<h4>特点</h4>
<p>　　1.有序(插入和读取的顺序一致)因为支持索引，索引从0开始；</p>
<p>　　2.允许重复元素；</p>
<h4>常见方法</h4>
<table style="height: 101px; width: 610px;" border="0" align="left">
<tbody>
<tr>
<td>增</td>
<td>add(int index,Object element);在指定索引的位置处增加元素</td>
</tr>
<tr>
<td>删</td>
<td>remove(int index);根据集合下标索引删除对象元素</td>
</tr>
<tr>
<td>改</td>
<td>set(int index,Object element);根据对象索引修改集合元素</td>
</tr>
<tr>
<td>查</td>
<td>indexOf(Object element); 根据对象查找</td>
</tr>
<tr>
<td>获取</td>
<td>get(int index);根据索引获取对象元素</td>
</tr>
</tbody>
</table>
<h4>&nbsp;</h4>
<h4>&nbsp;</h4>
<h4>&nbsp;</h4>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #000000;">@Test
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test1() {
</span><span style="color: #008080;"> 3</span>         List list = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
</span><span style="color: #008080;"> 4</span>         list.add(100<span style="color: #000000;">);
</span><span style="color: #008080;"> 5</span>         list.add(200<span style="color: #000000;">);
</span><span style="color: #008080;"> 6</span>         list.add(200<span style="color: #000000;">);
</span><span style="color: #008080;"> 7</span>         list.add(300<span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>         
<span style="color: #008080;"> 9</span> <span style="color: #000000;">        System.out.println(list);
</span><span style="color: #008080;">10</span>         list.remove(200<span style="color: #000000;">);
</span><span style="color: #008080;">11</span> <span style="color: #000000;">        System.out.println(list);
</span><span style="color: #008080;">12</span>     }<br />//会报下标越界错误；<br />/*<br />　　因为add方法是重载的collection的add方法，传入100，200，300属于int类型，程序默认会找同等类型的方法【add（int，index）】<br />　　<br />*/<br />使用list.remove(new Integer(200));<br /><br /><br /></code></pre>

<p>&nbsp;</p>
<h4>遍历方式<br /><br /></h4>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 2</span>         List list = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
</span><span style="color: #008080;"> 3</span>         list.add("wwer"<span style="color: #000000;">);
</span><span style="color: #008080;"> 4</span>         list.add("wwedfr"<span style="color: #000000;">);
</span><span style="color: #008080;"> 5</span>         list.add("dfwwer"<span style="color: #000000;">);
</span><span style="color: #008080;"> 6</span>         list.add("wdwwwer"<span style="color: #000000;">);
</span><span style="color: #008080;"> 7</span>         list.add("wwdfwer"<span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>         
<span style="color: #008080;"> 9</span> <span style="color: #000000;">        printList3(list);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span>     <span style="color: #008000;">//</span><span style="color: #008000;">方式一：</span>
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printList1(List list) {
</span><span style="color: #008080;">13</span>         Iterator iterator =<span style="color: #000000;"> list.iterator();
</span><span style="color: #008080;">14</span>         <span style="color: #0000ff;">while</span><span style="color: #000000;"> (iterator.hasNext()) {
</span><span style="color: #008080;">15</span>             Object object =<span style="color: #000000;"> (Object) iterator.next();
</span><span style="color: #008080;">16</span> <span style="color: #000000;">            System.out.println(object);
</span><span style="color: #008080;">17</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">18</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">19</span>     <span style="color: #008000;">//</span><span style="color: #008000;">方式二</span>
<span style="color: #008080;">20</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printList2(List list) {
</span><span style="color: #008080;">21</span>         <span style="color: #0000ff;">for</span><span style="color: #000000;"> (Object object : list) {
</span><span style="color: #008080;">22</span> <span style="color: #000000;">            System.out.println(object);
</span><span style="color: #008080;">23</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">25</span>     <span style="color: #008000;">//</span><span style="color: #008000;">方式三</span>
<span style="color: #008080;">26</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printList3(List list) {
</span><span style="color: #008080;">27</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0; i&lt;list.size(); i++<span style="color: #000000;">) {
</span><span style="color: #008080;">28</span>             Object object =<span style="color: #000000;"> list.get(i);
</span><span style="color: #008080;">29</span> <span style="color: #000000;">            System.out.println(object);
</span><span style="color: #008080;">30</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">31</span>     }</code></pre>

<p>&nbsp;</p>
<p>List的实现类</p>
<p>　　ArrayList&nbsp; 底层：可变数组</p>
<p>　　1，ArrayList底层维护了一个object[] elementDate的可变数组，在jdk8中初始化容量为0，在降低版本中初始化容量为10；</p>
<p>　　</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>  <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> ensureCapacityInternal(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
</span><span style="color: #008080;"> 2</span>         <span style="color: #0000ff;">if</span> (elementData ==<span style="color: #000000;"> DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
</span><span style="color: #008080;"> 3</span>             minCapacity =<span style="color: #000000;"> Math.max(DEFAULT_CAPACITY, minCapacity);
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #000000;">        ensureExplicitCapacity(minCapacity);
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> ensureExplicitCapacity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
</span><span style="color: #008080;">10</span>         modCount++<span style="color: #000000;">;
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> overflow-conscious code</span>
<span style="color: #008080;">13</span>         <span style="color: #0000ff;">if</span> (minCapacity - elementData.length &gt; 0<span style="color: #000000;">)
</span><span style="color: #008080;">14</span> <span style="color: #000000;">            grow(minCapacity);
</span><span style="color: #008080;">15</span>     }</code></pre>

<p>&nbsp;</p>
<p>　　2，在添加元素时，先进行判断是否需要扩容，如果不需要扩容直接添加元素对象到第一个空位上；</p>
<p>　　&nbsp;　　　　如果是第一次添加直接扩容到容量为10；</p>
<p>　　　　　　如果为其他次添加则直接扩容1.5倍；</p>
<p>　　</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> grow(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
</span><span style="color: #008080;"> 2</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> overflow-conscious code</span>
<span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">int</span> oldCapacity =<span style="color: #000000;"> elementData.length;
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1<span style="color: #000000;">);
</span><span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">if</span> (newCapacity - minCapacity &lt; 0<span style="color: #000000;">)
</span><span style="color: #008080;"> 6</span>             newCapacity =<span style="color: #000000;"> minCapacity;
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0<span style="color: #000000;">)
</span><span style="color: #008080;"> 8</span>             newCapacity =<span style="color: #000000;"> hugeCapacity(minCapacity);
</span><span style="color: #008080;"> 9</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> minCapacity is usually close to size, so this is a win:</span>
<span style="color: #008080;">10</span>         elementData =<span style="color: #000000;"> Arrays.copyOf(elementData, newCapacity);
</span><span style="color: #008080;">11</span>     }</code></pre>

<p>&nbsp;</p>
<p>　　3，进行数组元素的复制；</p>
<p>　　　elementDate = Array.copyOf（elementDate ,newCapycity）；</p>
<p>　　4,将新元素放在elementDate第一个空位上；</p>
<p>&nbsp;</p>
<p>LinkedList 底层：双向链表</p>
<p>　　1，LinkedList底层维护了两个Node节点 first 和 last 节点，每个节点对应了三个属性，分别是 prev ，item ，next上一个元素对象，当前元素对象，下一个元素对象；</p>
<p>　　</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>  <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> Node&lt;E&gt;<span style="color: #000000;"> {
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">        E item;
</span><span style="color: #008080;"> 3</span>         Node&lt;E&gt;<span style="color: #000000;"> next;
</span><span style="color: #008080;"> 4</span>         Node&lt;E&gt;<span style="color: #000000;"> prev;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>         Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt;<span style="color: #000000;"> next) {
</span><span style="color: #008080;"> 7</span>             <span style="color: #0000ff;">this</span>.item =<span style="color: #000000;"> element;
</span><span style="color: #008080;"> 8</span>             <span style="color: #0000ff;">this</span>.next =<span style="color: #000000;"> next;
</span><span style="color: #008080;"> 9</span>             <span style="color: #0000ff;">this</span>.prev =<span style="color: #000000;"> prev;
</span><span style="color: #008080;">10</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">11</span>     }</code></pre>

<p>&nbsp;</p>
<p>　　2，当进行添加元素时：</p>
<p>　　　　　　①先将last节点保存在临时变量l中；</p>
<p>　　　　　　②创建一个新的Node节点对象 Node newNode = new Node（l，e，null）；将新节点的前一个和后一个都链接上；</p>
<p>　　　　　　③将新节点的引用指向last；last = newNode；</p>
<p>　　　　　　④判断是否为第一次添加</p>
<p>　　　　　　　　如果时第一次添加，</p>
<p>　　　　　　　　　　first = newNode；</p>
<p>　　　　　　　　不是第一次添加，</p>
<p>　　　　　　　　　　l.next=newNode;</p>
<p>　　</p>
<src class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">void</span><span style="color: #000000;"> linkLast(E e) {
        </span><span style="color: #0000ff;">final</span> Node&lt;E&gt; l =<span style="color: #000000;"> last;
        </span><span style="color: #0000ff;">final</span> Node&lt;E&gt; newNode = <span style="color: #0000ff;">new</span> Node&lt;&gt;(l, e, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        last </span>=<span style="color: #000000;"> newNode;
        </span><span style="color: #0000ff;">if</span> (l == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
            first </span>=<span style="color: #000000;"> newNode;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
            l.next </span>=<span style="color: #000000;"> newNode;
        size</span>++<span style="color: #000000;">;
        modCount</span>++<span style="color: #000000;">;
    }</span></code></pre>

<p>&nbsp;</p>
<p>ArrayList和LinkedList的对比：</p>
<table style="height: 93px; width: 811px;" border="0" align="left">
<tbody>
<tr>
<td>&nbsp;</td>
<td>增删</td>
<td>改查</td>
</tr>
<tr>
<td>ArrayList　　可变数组</td>
<td>效率较低：增加和删除必须移动数组元素</td>
<td>效率较高：根据索引修改元素对象查找元素对象</td>
</tr>
<tr>
<td>LinkedList　　双向链表</td>
<td>效率较高：只需修改next 和prev的引用即可</td>
<td>效率较低：链表结构必须从头开始连续调用next进行修改或查找</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>ArrayList和Vector的区别：</p>
<table style="height: 80px; width: 788px;" border="0" align="left">
<tbody>
<tr>
<td>&nbsp;</td>
<td>底层</td>
<td>线程安全同步</td>
<td>效率　　　　扩容机制</td>
</tr>
<tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>不安全</td>
<td>较高　　　　1.5</td>
</tr>
<tr>
<td>vector</td>
<td>可变数组</td>
<td>安全</td>
<td>较低　　　　2</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>set接口</h3>
<p>　　特点：1，无序的，不重复的（至多有一个null）</p>
<p>　　　　　2，不支持索引，大多set接口的实现类是无序的；</p>
<p>　　　　　　　　有些实现类比较特殊：比如LinkedHashSet是有序的；</p>
<p>　　　　　　　　　　　　　　　　　　比如TreeSet是排好序的；</p>
<p>　　</p>
<p>　　常见方法：</p>
<p>　　　　没有特有的方法，（Collection）</p>
<p>&nbsp;</p>
<p>　　源码分析：</p>
<p>　　　　HashSet集合底层其实是一个Map，</p>
<p>　　　　底层维护一个Node[] table，当添加元素的时候，先对改元素进行哈希取值，调用hashCode（）方法，通过运算找到对应的位置；</p>
<p>　　　　如果当前位置没有值就直接添加，如果有值就调用equals（）方法进行比较，如果值相同就直接覆盖，值不同就直接以链表的形式追加节点上；</p>
<p>&nbsp;</p>
<p>　　　　LinkedHashSet底层是LinkedHashMap，是一个链表+哈希表的结构；</p>
<p>　　　　特点：不允许重复；</p>
<p>　　　　　　　有序的（插入和取出的顺序是一致的）</p>
<p>　　　　如何去重：</p>
<p>　　　　　　实现hashCode和equals方法；</p>
<p>　　　　使用：</p>
<p>　　　　　　对象类型和自定义对象类型必须重写hashCode和equals方法；</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>Map接口</h3>
<p>　　特点</p>
<p>　　　　1，内部保存的是kv键值对</p>
<p>　　　　2，key不允许重复，value可以重复</p>
<p>　　　　3，key可以为null</p>
<p>　　常见方法</p>
<p>　　　　put（）；</p>
<p>　　　　putAll（）；</p>
<p>　　　　remove（）；</p>
<p>　　　　get（）；</p>
<p>　　　　containskey（）；</p>
<p>　　　　containsValue（）；</p>
<p>　　　　size（）；</p>
<p>　　　　clear（）；</p>
<p>　　　　isEmpt（）；</p>
<p>　　遍历方式</p>
<p>　　　　</p>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">public class TestMap {
	
	public static void main(String[] args) {
		Map map = new HashMap();
		
		map.put("1", "22");
		map.put("2", "22");
		map.put("3", "22");
		map.put("4", "22");
		map.put("5", "22");
		map.put("12", "22");
		map.put("13", "22");
		prinMap2(map);
	}
	
	public static void printMap(Map map) {
		Set keys = map.keySet();
		Iterator iterator = keys.iterator();
		while (iterator.hasNext()) {
			Object key = (Object) iterator.next();
			Object value = map.get(key);
			System.out.println(key+":"+value);
			
		}
	}
	
	public static void prinMap2(Map map) {
		Set entrys = map.entrySet();
		for (Object object : entrys) {
		Map.Entry entry = (Entry) object;
		Object key = entry.getKey();
		Object value = entry.getValue();
		System.out.println(key+":"+value);
		}
	}
}
</code></pre>

<p>　　</p>
<p>　　实现类</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashMap</p>
<p>　　源码解析</p>
<p>　　　　1，HashMap底层解析，底层为哈希表结构&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;JDK1.8机构为数组+链表+红黑树结构，JDK1.7较低版本为数组+链表</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>　　</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>