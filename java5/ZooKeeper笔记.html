<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ZooKeeper笔记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ZooKeeper笔记</center></div><div class='banquan'>原文出处:本文由博客园博主夏了夏天丶提供。<br/>
原文连接:https://www.cnblogs.com/yuming2018/p/11733874.html</div><br>
    <h1><span style="font-family: 'Microsoft YaHei';">简介:</span></h1>
<h4><span style="font-family: 'Microsoft YaHei';">Zookeeper是一个高可用的分布式管理与协调框架,基于Paxos算法(原子消息广播协议),能够很好地保证分布式环境中数据的一致性</span></h4>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>顺序一致性</strong>:从客户端发起的事务请求,最终会严格地按照其发起的顺序被应用到Zookeeper中</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>原子性</strong>:所有事务请求的结果在集群环境中所有机器上的应用情况应该是一致的,也就是说要么集群中所有的机器都应用了这一事务,要么所有机器都没有应用这一事务.</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>单一视图</strong>:无论客户端连接的是哪一个Zookeeper服务器,其获取的服务端数据都是一致的</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>可靠性</strong>:一旦服务器成功地应用了某一事务,并完成了对客户端的响应,那么该事务引起的服务端状态将被一致地保留下来,除非有另一个事务对其进行更改.</span></p>
<p>&nbsp;</p>
<h3><span style="font-family: 'Microsoft YaHei';">树形结构!</span></h3>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">Zookeeper服务分三种角色:leader,Follower,Observer,其中Follower与Observer又统称为Learner</span></p>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">Leader:负责客户端的writer请求类型</span></p>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">Follower:负责客户端的reader类型请求和leader选举等</span></p>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">Observer:特殊的Follower,可以接受客户端的reader请求,但不参与选举,不接受任何的同步写入请求,只负责与leader同步数据</span></p>
<h1><span style="font-family: 'Microsoft YaHei';">典型应用场景:</span></h1>
<h3><span style="font-family: 'Microsoft YaHei';">配置管理</span></h3>
<h3><span style="font-family: 'Microsoft YaHei';">集群管理</span></h3>
<h3><span style="font-family: 'Microsoft YaHei';">发布订阅</span></h3>
<h3><span style="font-family: 'Microsoft YaHei';">数据库切换</span></h3>
<h3><span style="font-family: 'Microsoft YaHei';">分布式日志收集</span></h3>
<h3><span style="font-family: 'Microsoft YaHei';">分布式锁与队列管理</span></h3>
<h2><span style="font-family: 'Microsoft YaHei';">Zookeeper的安装:</span></h2>
<ol>
<li><span style="font-family: 'Microsoft YaHei';">结构：一共三个节点&nbsp;(zk服务器集群规模不小于3个节点),要求服务器之间系统时间保持一致。</span></li>
<li><span style="font-family: 'Microsoft YaHei';">上传zk&nbsp;&nbsp;进行解压： tar&nbsp;zookeeper-3.4.5.tar.gz&nbsp;</span></li>
<li><span style="font-family: 'Microsoft YaHei';">重命名： mv&nbsp;zookeeper-3.4.5&nbsp;zookeeper</span></li>
<li><span style="font-family: 'Microsoft YaHei';">修改环境变量： vi&nbsp;/etc/profile&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;export&nbsp;ZOOKEEPER_HOME=/usr/local/zookeeper&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;export&nbsp;PATH=.:$ZOOKEEPER_HOME/bin&nbsp; &nbsp; &nbsp; 刷新： source&nbsp;/etc/profile</span></li>
<li><span style="font-family: 'Microsoft YaHei';">到zookeeper下修改配置文件&nbsp;&nbsp;cd&nbsp;/usr/local/zookeeper/conf&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;mv&nbsp;zoo_sample.cfg&nbsp;zoo.cfg</span></li>
<li><span style="font-family: 'Microsoft YaHei';">修改conf:&nbsp; vi&nbsp;zoo.cfg&nbsp;&nbsp;修改两处&nbsp;&nbsp;（1）dataDir=/usr/local/zookeeper/data&nbsp;（2）最后面添加&nbsp;server.0=bhz:2888:3888&nbsp; &nbsp;server.1=hadoop1:2888:3888&nbsp; &nbsp;server.2=hadoop2:2888:3888</span></li>
<li><span style="font-family: 'Microsoft YaHei';">服务器标识配置：&nbsp; &nbsp;创建文件夹：mkdir&nbsp;data&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;创建文件myid并填写内容为0,1,2：vi&nbsp;myid&nbsp;(内容为服务器标识:0,1,2)</span></li>
</ol>
<h2><span style="font-family: 'Microsoft YaHei';">启动zookeeper：</span></h2>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">路径：/usr/local/zookeeper/bin</span></p>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">执行：zkServer.sh&nbsp;start&nbsp;(注意这里3台机器都要进行启动)</span></p>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">状态：zkServer.sh&nbsp;status(在三个节点上检验zk的mode,一个leader和俩个follower)</span></p>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">操作zookeeper&nbsp;(shell)</span></p>
<p><span style="font-size: 18px; font-family: 'Microsoft YaHei';">zkCli.sh&nbsp;进入zookeeper客户端:</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">根据提示命令进行操作：&nbsp;</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">查找：ls&nbsp;/&nbsp;&nbsp;&nbsp;ls&nbsp;/zookeeper</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">创建并赋值：create&nbsp;/ym 1111</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">获取：get&nbsp;/ym&nbsp;</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">设值：set&nbsp;/ym 2222</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">可以看到zookeeper集群的数据一致性</span></p>
<h3>创建节点有俩种类型：短暂（<span style="font-family: Calibri;">ephemeral</span><span style="font-family: 宋体;">）:仅当前连接有效,连接断开,则失效被删除&nbsp;</span></h3>
<h3><span style="font-family: 宋体;">　　　　　　　　　　持久（</span><span style="font-family: Calibri;">persistent</span><span style="font-family: 宋体;">）:永久有效,除非被删除</span></h3>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>zoo.cfg详解</strong>：</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tickTime： 基本事件单元，以毫秒为单位。这个时间是作为&nbsp;Zookeeper&nbsp;服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每隔&nbsp;tickTime时间就会发送一个心跳。</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataDir： 存储内存中数据库快照的位置，顾名思义就是&nbsp;Zookeeper&nbsp;保存数据的目录，默认情况下，Zookeeper&nbsp;将写数据的日志文件也保存在这个目录里。</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientPort：&nbsp;这个端口就是客户端连接&nbsp;Zookeeper&nbsp;服务器的端口，Zookeeper&nbsp;会监听这个端口，接受客户端的访问请求。</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initLimit： 这个配置项是用来配置&nbsp;Zookeeper&nbsp;接受客户端初始化连接时最长能忍受多少个心跳时间间隔数，当已经超过&nbsp;10&nbsp;个心跳的时间（也就是&nbsp;tickTime）长度后&nbsp;Zookeeper&nbsp;服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是&nbsp;10*2000=20&nbsp;秒。</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncLimit： 这个配置项标识&nbsp;Leader&nbsp;与&nbsp;Follower&nbsp;之间发送消息，请求和应答时间长度，最长不能超过多少个&nbsp;tickTime&nbsp;的时间长度，总的时间长度就是&nbsp;5*2000=10&nbsp;秒</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server.A&nbsp;=&nbsp;B:C:D&nbsp;:&nbsp;</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A表示这个是第几号服务器,</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;是这个服务器的&nbsp;ip&nbsp;地址；</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&nbsp;表示的是这个服务器与集群中的&nbsp;Leader&nbsp;服务器交换信息的端口；</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D&nbsp;表示的是万一集群中的&nbsp;Leader&nbsp;服务器挂了，需要一个端口来重新进行选举，选出一个新的&nbsp;Leader</span></p>
<p><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong>Stat详解</strong>:</span></p>
<table style="height: 349px; width: 908px;" border="0" align="left">
<tbody>
<tr>
<td><span style="font-size: 16px;">cZxid</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点创建时的事务ID</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">ctime</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点创建时的时间</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">mZxid</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点最后一次更新时的事务ID</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">mtime</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点最后一次更新时的时间</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">pZxid</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点的子节点列表最后一次被修改（是子节点列表变更，而不是子节点内容变更）时的事务ID</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">cversion</span></td>
<td><span style="font-size: 16px;">&nbsp;子节点的版本号</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">dataVersion</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点的版本号</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">aclVersion</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点的ACL版本号&nbsp;</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">ephemeralOwner&nbsp;</span></td>
<td><span style="font-size: 16px;">&nbsp;如果节点是临时节点，则表示创建该节点的会话的SessionID；如果节点是持久节点，则该属性值为0</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">dataLength</span></td>
<td><span style="font-size: 16px;">&nbsp;数据内容的长度</span></td>
</tr>
<tr>
<td><span style="font-size: 16px;">numChildren</span></td>
<td><span style="font-size: 16px;">&nbsp;数据节点当前的子节点个数</span></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>&nbsp;</h1>
<h1>&nbsp;</h1>
<h1>&nbsp;</h1>
<h1>&nbsp;</h1>
<h1>&nbsp;</h1>
<h1>&nbsp;</h1>
<h1>&nbsp;</h1>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>&nbsp;</h1>
<h1>Zooleeper原生API:</h1>
<ol>
<li><span style="font-size: 16px;">JAVA</span><span style="font-size: 16px;"><span style="font-size: 16px;">想要实现对于Zookeeper操作,需要先新建Zookeeper对象,一般需要三个参数:<strong>zookeeper集群地址,session超时时间,watcher配置(需要重写process方法)监听</strong></span></span>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.129:2181,192.168.238.131:2181,192.168.238.132:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 2000;<span style="color: #008000;">//</span><span style="color: #008000;">ms </span>
<span style="color: #008000;">/**</span><span style="color: #008000;"> 信号量，阻塞程序执行，用于等待zookeeper连接成功，发送成功信号 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> CountDownLatch connectedSemaphore = <span style="color: #0000ff;">new</span> CountDownLatch(1<span style="color: #000000;">);
ZooKeeper zk </span>= <span style="color: #0000ff;">new</span> ZooKeeper(CONNECT_ADDR, SESSION_OUTTIME, <span style="color: #0000ff;">new</span><span style="color: #000000;"> Watcher(){
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> process(WatchedEvent event) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">获取事件的状态</span>
                KeeperState keeperState =<span style="color: #000000;"> event.getState();
                EventType eventType </span>=<span style="color: #000000;"> event.getType();
                </span><span style="color: #008000;">//</span><span style="color: #008000;">如果是建立连接</span>
                <span style="color: #0000ff;">if</span>(KeeperState.SyncConnected ==<span style="color: #000000;"> keeperState){
                    </span><span style="color: #0000ff;">if</span>(EventType.None ==<span style="color: #000000;"> eventType){
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果建立连接成功，则发送信号量，让后续阻塞程序向下执行</span>
<span style="color: #000000;">                        connectedSemaphore.countDown();
                        System.out.println(</span>"zk 建立连接"<span style="color: #000000;">);
                    }
                }
            }
        });

</span><span style="color: #008000;">//</span><span style="color: #008000;">进行阻塞,只有连接zookeeper成功才继续执行主线程<br /></span>connectedSemaphore.await();</code></pre>

<span style="font-size: 16px;"><strong><br /></strong></span></li>
<li><span style="font-size: 16px;"><span style="font-size: 16px;"><span style="font-size: 16px;">利用上文代码中的zk对象<strong>,创建,获取,修改,删除</strong>节点操作.<br /></span></span></span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><span style="font-size: 18px;"><strong>创建</strong>:</span><br />第一个参数为节点路径</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">第二个参数为Byte[]类型的节点值</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">第三个参数为Ids授权策略,OPEN_ACL_UNSAFE为开放状态,CREATOR_ALL_ACL为需要认证状态</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">(此状态时创建节点前需要</span>
<pre><code><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">//添加节点授权</span><br /><span style="font-family: 'Microsoft YaHei';"><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">zk.addAuthInfo("digest","123456".getBytes());其中"digest"为认证方式,"123456"为凭证</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">认证方式有如下几种:</span><br /></span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">IP:ip模式通过ip地址粒度进行权限控制模式，例如配置了：192.168.110.135即表示权限控制都是针对这个ip地址的，同时也支持按网段分配，比如：192.168.110.*<br /></span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">Digest:digest是最常用的权限控制模式，也更符合我们对权限控制的认识，其类似于</span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">"username:password"形式的权限标识进行权限配置。ZK会对形成的权限标识先后进</span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">行两次编码处理，粉笔是SHA-1加密算法和Base64编码。<br /></span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">World：World是一直最开放的权限控制模式。这种模式可以看做为特殊的Digest，他仅仅是</span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">一个标识而已。<br /></span><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">Super：超级用户模式，在超级用户模式下可以对ZK任意进行操作。</span></code></pre>
<span style="font-size: 16px;"><span style="font-size: 16px;">)<br />第四个参数为节点类型,PERSISTENT为持久节点,EPHEMERAL为短暂节点<br /><strong>需要注意:zk.create方法不能递归创建节点.如想创建testRoot下面的a1节点,不能直接创建/testRoot/a1,需要先创建父节点,然后创建子节点,不然会报异常,异常显示节点不存在<br /></strong><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;zk.create的返回值为字符串,内容为创建节点的详细信息(创建时间戳,修改时间戳,修改的版本,初始化的版本,zxid等)</strong><br /></span></span>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">创建父节点
</span><span style="color: #008000;">//</span><span style="color: #008000;">创建持久节点</span>
zk.create("/testRoot", "testRoot111"<span style="color: #000000;">.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
</span><span style="color: #008000;">//</span><span style="color: #008000;">创建临时节点</span>
zk.create("/testRoot1", "testRoot222"<span style="color: #000000;">.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);


</span><span style="color: #008000;">//</span><span style="color: #008000;">创建子节点</span>
zk.create("/testRoot/a1", "1111"<span style="color: #000000;">.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
zk.create(</span>"/testRoot/a2", "2222".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</code></pre>

<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><strong>获取:<br /></strong><span style="font-size: 16px;">zk.getData方法:<br />第一个参数为要获取的节点地址<br /></span><span style="font-size: 16px;">第二个参数为是否设置watcher监听<br />第三个参数为stat节点状态信息<br />返回值为byte[]<br />zk.getChildren方法:<br />第一个参数为要获取的节点地址<br />第二个参数为是否设置watcher监听<br />返回值为List,foreach遍历进行获取<br /><strong>需要注意:若watcher设置为true,则会在获取的节点设置监听,当节点发生变化(增删改)时,会返回event事件,这样的watcher在经过一次后就会失效.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getChildren方法是不能递归获取子节点的,只可以获取当前节点的下一级子节点,孙子节点无法获取.</strong></span></span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">获取父节点</span>
        <span style="color: #0000ff;">byte</span>[] data = zk.getData("/testRoot", <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        System.out.println(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> String(data));
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取子节点</span>
        List&lt;String&gt; children = zk.getChildren("/testRoot", <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String p:children) {
            System.out.println(p);
            System.out.println(</span><span style="color: #0000ff;">new</span> String(zk.getData("/testRoot/"+p,<span style="color: #0000ff;">false</span>,<span style="color: #0000ff;">null</span><span style="color: #000000;">)));
        }            </span></code></pre>

<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><strong>修改:<br /></strong><span style="font-size: 16px;">setData方法:<br />第一个参数为要修改的节点路径<br />第二个参数为要修改的内容<br />第三个参数为要修改的版本(-1为无视版本)<br />返回值为Stat节点状态信息</span></span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">修改节点的值</span>
Stat stat = zk.setData("/testRoot", "modify data root".getBytes(), -1);</code></pre>

<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><strong>删除:</strong></span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">zk.delete方法:</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">第一个参数为要删除的节点路径</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">第二个参数为要修改的版本(-1为无视版本)</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">需要注意:zk.delete仍然是不可以递归删除的,若想删除的节点下面有子节点,则需要先删除子节点再删除父节点,否则报异常</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">无返回值</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">zk.exists方法:判断节点是否存在</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">第一个参数为要删除的节点路径</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">第二个参数为是否设置watcher监听</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">返回值为Stat节点状态信息</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><strong>需要注意:若watcher设置为true,则会在获取的节点设置监听,当节点发生变化(增删改)时,会返回event事件,这样的watcher在经过一次后就会失效.</strong></span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">删除节点</span>
zk.delete("/testRoot/children", -1<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">判断节点是否存在</span>
Stat stat = zk.exists("/testRoot", <span style="color: #0000ff;">false</span>);</code></pre>

</li>
<li>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><strong>自定义watcher实现监听</strong></span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ZooKeeperWatcher <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Watcher {

    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 定义原子变量 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    AtomicInteger seq </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> AtomicInteger();
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 定义session失效时间 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_TIMEOUT = 10000<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper服务器地址 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECTION_ADDR = "192.168.1.121:2181,192.168.1.122:2181,192.168.1.123:2181"<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> zk父路径设置 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String PARENT_PATH = "/p"<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> zk子路径设置 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CHILDREN_PATH = "/p/c"<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 进入标识 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String LOG_PREFIX_OF_MAIN = "【Main】"<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> zk变量 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> ZooKeeper zk = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">用于等待zookeeper连接建立之后 通知阻塞程序继续向下执行 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> CountDownLatch connectedSemaphore = <span style="color: #0000ff;">new</span> CountDownLatch(1<span style="color: #000000;">);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 创建ZK连接
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> connectAddr ZK服务器地址列表
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> sessionTimeout Session超时时间
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> createConnection(String connectAddr, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sessionTimeout) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.releaseConnection();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">this表示把当前对象进行传递到其中去（也就是在主函数里实例化的new ZooKeeperWatcher()实例对象）</span>
            zk = <span style="color: #0000ff;">new</span> ZooKeeper(connectAddr, sessionTimeout, <span style="color: #0000ff;">this</span><span style="color: #000000;">);
            System.out.println(LOG_PREFIX_OF_MAIN </span>+ "开始连接ZK服务器"<span style="color: #000000;">);
            connectedSemaphore.await();
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 关闭ZK连接
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> releaseConnection() {
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.zk != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.zk.close();
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 创建节点
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> path 节点路径
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> data 数据内容
     * </span><span style="color: #808080;">@return</span> 
     <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> createPath(String path, String data, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> needWatch) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">设置监控(由于zookeeper的监控都是一次性的所以 每次必须设置监控)</span>
            <span style="color: #0000ff;">this</span><span style="color: #000000;">.zk.exists(path, needWatch);
            System.out.println(LOG_PREFIX_OF_MAIN </span>+ "节点创建成功, Path: " + 
                               <span style="color: #0000ff;">this</span>.zk.create(    <span style="color: #008000;">/**</span><span style="color: #008000;">路径</span><span style="color: #008000;">*/</span><span style="color: #000000;"> 
                                                   path, 
                                                   </span><span style="color: #008000;">/**</span><span style="color: #008000;">数据</span><span style="color: #008000;">*/</span><span style="color: #000000;">
                                                   data.getBytes(), 
                                                   </span><span style="color: #008000;">/**</span><span style="color: #008000;">所有可见</span><span style="color: #008000;">*/</span><span style="color: #000000;">
                                                   Ids.OPEN_ACL_UNSAFE, 
                                                   </span><span style="color: #008000;">/**</span><span style="color: #008000;">永久存储</span><span style="color: #008000;">*/</span><span style="color: #000000;">
                                                   CreateMode.PERSISTENT ) </span>+     
                               ", content: " +<span style="color: #000000;"> data);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 读取指定节点数据内容
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> path 节点路径
     * </span><span style="color: #808080;">@return</span>
     <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> String readData(String path, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> needWatch) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            System.out.println(</span>"读取数据操作..."<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> String(<span style="color: #0000ff;">this</span>.zk.getData(path, needWatch, <span style="color: #0000ff;">null</span><span style="color: #000000;">));
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
            </span><span style="color: #0000ff;">return</span> ""<span style="color: #000000;">;
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 更新指定节点数据内容
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> path 节点路径
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> data 数据内容
     * </span><span style="color: #808080;">@return</span>
     <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> writeData(String path, String data) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            System.out.println(LOG_PREFIX_OF_MAIN </span>+ "更新数据成功，path：" + path + ", stat: " +
                                <span style="color: #0000ff;">this</span>.zk.setData(path, data.getBytes(), -1<span style="color: #000000;">));
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 删除指定节点
     * 
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> path
     *            节点path
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> deleteNode(String path) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">this</span>.zk.delete(path, -1<span style="color: #000000;">);
            System.out.println(LOG_PREFIX_OF_MAIN </span>+ "删除节点成功，path：" +<span style="color: #000000;"> path);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 判断指定节点是否存在
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> path 节点路径
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> Stat exists(String path, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> needWatch) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.zk.exists(path, needWatch);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 获取子节点
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> path 节点路径
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> List&lt;String&gt; getChildren(String path, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> needWatch) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            System.out.println(</span>"读取子节点操作..."<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.zk.getChildren(path, needWatch);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 删除所有节点
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> deleteAllTestPath(<span style="color: #0000ff;">boolean</span><span style="color: #000000;"> needWatch) {
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.exists(CHILDREN_PATH, needWatch) != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.deleteNode(CHILDREN_PATH);
        }
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.exists(PARENT_PATH, needWatch) != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.deleteNode(PARENT_PATH);
        }        
    }
    
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 收到来自Server的Watcher通知后的处理。
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> process(WatchedEvent event) {
        
        System.out.println(</span>"进入 process 。。。。。event = " +<span style="color: #000000;"> event);
        
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>200<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            e.printStackTrace();
        }
        
        </span><span style="color: #0000ff;">if</span> (event == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 连接状态</span>
        KeeperState keeperState =<span style="color: #000000;"> event.getState();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 事件类型</span>
        EventType eventType =<span style="color: #000000;"> event.getType();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 受影响的path</span>
        String path =<span style="color: #000000;"> event.getPath();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">原子对象seq 记录进入process的次数</span>
        String logPrefix = "【Watcher-" + <span style="color: #0000ff;">this</span>.seq.incrementAndGet() + "】"<span style="color: #000000;">;

        System.out.println(logPrefix </span>+ "收到Watcher通知"<span style="color: #000000;">);
        System.out.println(logPrefix </span>+ "连接状态:\t" +<span style="color: #000000;"> keeperState.toString());
        System.out.println(logPrefix </span>+ "事件类型:\t" +<span style="color: #000000;"> eventType.toString());

        </span><span style="color: #0000ff;">if</span> (KeeperState.SyncConnected ==<span style="color: #000000;"> keeperState) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 成功连接上ZK服务器</span>
            <span style="color: #0000ff;">if</span> (EventType.None ==<span style="color: #000000;"> eventType) {
                System.out.println(logPrefix </span>+ "成功连接上ZK服务器"<span style="color: #000000;">);
                connectedSemaphore.countDown();
            } 
            </span><span style="color: #008000;">//</span><span style="color: #008000;">创建节点</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (EventType.NodeCreated ==<span style="color: #000000;"> eventType) {
                System.out.println(logPrefix </span>+ "节点创建"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    Thread.sleep(</span>100<span style="color: #000000;">);
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                    e.printStackTrace();
                }
            } 
            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新节点</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (EventType.NodeDataChanged ==<span style="color: #000000;"> eventType) {
                System.out.println(logPrefix </span>+ "节点数据更新"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    Thread.sleep(</span>100<span style="color: #000000;">);
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                    e.printStackTrace();
                }
            } 
            </span><span style="color: #008000;">//</span><span style="color: #008000;">更新子节点</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (EventType.NodeChildrenChanged ==<span style="color: #000000;"> eventType) {
                System.out.println(logPrefix </span>+ "子节点变更"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    Thread.sleep(</span>3000<span style="color: #000000;">);
                } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                    e.printStackTrace();
                }
            } 
            </span><span style="color: #008000;">//</span><span style="color: #008000;">删除节点</span>
            <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (EventType.NodeDeleted ==<span style="color: #000000;"> eventType) {
                System.out.println(logPrefix </span>+ "节点 " + path + " 被删除"<span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> ;
        } 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (KeeperState.Disconnected ==<span style="color: #000000;"> keeperState) {
            System.out.println(logPrefix </span>+ "与ZK服务器断开连接"<span style="color: #000000;">);
        } 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (KeeperState.AuthFailed ==<span style="color: #000000;"> keeperState) {
            System.out.println(logPrefix </span>+ "权限检查失败"<span style="color: #000000;">);
        } 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (KeeperState.Expired ==<span style="color: #000000;"> keeperState) {
            System.out.println(logPrefix </span>+ "会话失效"<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> ;

        System.out.println(</span>"--------------------------------------------"<span style="color: #000000;">);

    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * &lt;B&gt;方法名称：&lt;/B&gt;测试zookeeper监控&lt;BR&gt;
     * &lt;B&gt;概要说明：&lt;/B&gt;主要测试watch功能&lt;BR&gt;
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> args
     * </span><span style="color: #808080;">@throws</span><span style="color: #008000;"> Exception
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {

        </span><span style="color: #008000;">//</span><span style="color: #008000;">建立watcher </span><span style="color: #008000;">//</span><span style="color: #008000;">当前客户端可以称为一个watcher 观察者角色</span>
        ZooKeeperWatcher zkWatch = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ZooKeeperWatcher();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建连接 </span>
<span style="color: #000000;">        zkWatch.createConnection(CONNECTION_ADDR, SESSION_TIMEOUT);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println(zkWatch.zk.toString());</span>
<span style="color: #000000;">        
        Thread.sleep(</span>1000<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 清理节点</span>
        zkWatch.deleteAllTestPath(<span style="color: #0000ff;">false</span><span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">-----------------第一步: 创建父节点 /p ------------------------</span><span style="color: #008000;">//
</span>        <span style="color: #0000ff;">if</span> (zkWatch.createPath(PARENT_PATH, System.currentTimeMillis() + "", <span style="color: #0000ff;">true</span><span style="color: #000000;">)) {
            
            Thread.sleep(</span>1000<span style="color: #000000;">);
            
            </span><span style="color: #008000;">//</span><span style="color: #008000;">-----------------第二步: 读取节点 /p 和    读取/p节点下的子节点(getChildren)的区别 --------------</span><span style="color: #008000;">//</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 读取数据</span>
            zkWatch.readData(PARENT_PATH, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
        
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 读取子节点(监控childNodeChange事件)</span>
            zkWatch.getChildren(PARENT_PATH, <span style="color: #0000ff;">true</span><span style="color: #000000;">);

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 更新数据</span>
            zkWatch.writeData(PARENT_PATH, System.currentTimeMillis() + ""<span style="color: #000000;">);
            
            Thread.sleep(</span>1000<span style="color: #000000;">);
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建子节点</span>
            zkWatch.createPath(CHILDREN_PATH, System.currentTimeMillis() + "", <span style="color: #0000ff;">true</span><span style="color: #000000;">);
            
            
            </span><span style="color: #008000;">//</span><span style="color: #008000;">-----------------第三步: 建立子节点的触发 --------------</span><span style="color: #008000;">//</span>
<span style="color: #008000;">//</span><span style="color: #008000;">            zkWatch.createPath(CHILDREN_PATH + "/c1", System.currentTimeMillis() + "", true);
</span><span style="color: #008000;">//</span><span style="color: #008000;">            zkWatch.createPath(CHILDREN_PATH + "/c1/c2", System.currentTimeMillis() + "", true);
            
            </span><span style="color: #008000;">//</span><span style="color: #008000;">-----------------第四步: 更新子节点数据的触发 --------------</span><span style="color: #008000;">//</span>
            <span style="color: #008000;">//</span><span style="color: #008000;">在进行修改之前，我们需要watch一下这个节点：</span>
            Thread.sleep(1000<span style="color: #000000;">);
            zkWatch.readData(CHILDREN_PATH, </span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
            zkWatch.writeData(CHILDREN_PATH, System.currentTimeMillis() </span>+ ""<span style="color: #000000;">);
            
        }
        
        Thread.sleep(</span>10000<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 清理节点</span>
        zkWatch.deleteAllTestPath(<span style="color: #0000ff;">false</span><span style="color: #000000;">);
        
        
        Thread.sleep(</span>10000<span style="color: #000000;">);
        zkWatch.releaseConnection();
        
    }

}</span></code></pre>

<p>输出结果:</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【Main】开始连接ZK服务器
进入 process 。。。。。event = WatchedEvent state:SyncConnected type:None path:null
【Watcher-1】收到Watcher通知
【Watcher-1】连接状态:    SyncConnected
【Watcher-1】事件类型:    None
【Watcher-1】成功连接上ZK服务器
--------------------------------------------
进入 process 。。。。。event = WatchedEvent state:SyncConnected type:NodeCreated path:/p
【Main】节点创建成功, Path: /p, content: 1572246563330
【Watcher-2】收到Watcher通知
【Watcher-2】连接状态:    SyncConnected
【Watcher-2】事件类型:    NodeCreated
【Watcher-2】节点创建
--------------------------------------------
读取数据操作...
读取子节点操作...
进入 process 。。。。。event = WatchedEvent state:SyncConnected type:NodeDataChanged path:/p
【Main】更新数据成功，path：/p, stat: 25769803906,25769803907,1572246563261,1572246564283,1,0,0,0,13,0,25769803906

【Watcher-3】收到Watcher通知
【Watcher-3】连接状态:    SyncConnected
【Watcher-3】事件类型:    NodeDataChanged
【Watcher-3】节点数据更新
--------------------------------------------
进入 process 。。。。。event = WatchedEvent state:SyncConnected type:NodeCreated path:/p/c
【Main】节点创建成功, Path: /p/c, content: 1572246565369
【Watcher-4】收到Watcher通知
【Watcher-4】连接状态:    SyncConnected
【Watcher-4】事件类型:    NodeCreated
【Watcher-4】节点创建
--------------------------------------------
进入 process 。。。。。event = WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/p
【Watcher-5】收到Watcher通知
【Watcher-5】连接状态:    SyncConnected
【Watcher-5】事件类型:    NodeChildrenChanged
【Watcher-5】子节点变更
读取数据操作...
【Main】更新数据成功，path：/p/c, stat: 25769803908,25769803909,1572246565293,1572246566302,1,0,0,0,13,0,25769803908

--------------------------------------------
进入 process 。。。。。event = WatchedEvent state:SyncConnected type:NodeDataChanged path:/p/c
【Watcher-6】收到Watcher通知
【Watcher-6】连接状态:    SyncConnected
【Watcher-6】事件类型:    NodeDataChanged
【Watcher-6】节点数据更新
--------------------------------------------
【Main】删除节点成功，path：/p/c
【Main】删除节点成功，path：/p</span></code></pre>

<p><strong style="font-family: 'Microsoft YaHei'; font-size: 18px;">&nbsp;</strong></p>
</li>
</ol>
<h1>ZkClient API:</h1>
<p><span style="font-size: 18px;"><strong>ZkClient对于Zookeeper原生API进行了封装</strong></span></p>
<p><span style="font-size: 18px;"><strong>主要封装:</strong></span></p>
<ol>
<li><span style="font-size: 18px;"><strong>在session loss和session expire时自动创建新的ZooKeeper实例进行重连</strong></span></li>
<li><span style="font-size: 18px;"><strong>将一次性watcher包装为持久watcher</strong></span></li>
<li><span style="font-size: 18px;"><strong>创建与删除操作,可以进行递归操作</strong></span></li>
</ol><ol>
<li><span style="font-size: 18px;">新建ZkClient对象,第一个参数ZkConnection对象,第二个参数连接超时时间</span><br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.129:2181,192.168.238.131:2181,192.168.238.132:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 5000;<span style="color: #008000;">//</span><span style="color: #008000;">ms </span>
ZkClient zkc = <span style="color: #0000ff;">new</span> ZkClient(<span style="color: #0000ff;">new</span> ZkConnection(CONNECT_ADDR), 10000);</code></pre>

</li>
<li><span style="font-size: 18px;">利用上文代码中的zkc对象<strong>,创建,获取,修改,删除</strong>节点操作.</span><br /><span style="font-size: 18px;">创建:</span><br /><span style="font-size: 18px;">两种创建节点的方式,创建持续节点的时候,第二个参数为是否递归创建,</span><br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">创建暂时节点</span>
zkc.createEphemeral("/temp"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">创建持续节点</span>
zkc.createPersistent("/super/c1", <span style="color: #0000ff;">true</span>);</code></pre>

<span style="font-size: 18px;">获取:</span><br /><span style="font-size: 18px;">zkc.readData方法:</span><br /><span style="font-size: 18px;">zkc.watchForChilds方法:</span><br />
<src class="cnblogs_code">
<pre><code>        zkc.createPersistent("/super", "1234"<span style="color: #000000;">);
        zkc.createPersistent(</span>"/super/c1", "c1内容"<span style="color: #000000;">);
        zkc.createPersistent(</span>"/super/c2", "c2内容"<span style="color: #000000;">);
        List</span>&lt;String&gt; list = zkc.watchForChilds("/super"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(String p : list){
            System.out.println(p);
            String rp </span>= "/super/" +<span style="color: #000000;"> p;
            String data </span>=<span style="color: #000000;"> zkc.readData(rp);
            System.out.println(</span>"节点为：" + rp + "，内容为: " +<span style="color: #000000;"> data);
        }</span></code></pre>

<span style="font-size: 18px;">修改:</span><br />
<src class="cnblogs_code">
<pre><code>zkc.writeData("/super","新内容",-1);</code></pre>

<span style="font-size: 18px;">删除:</span><br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">非递归删除</span>
zkc.delete("/temp"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">递归删除</span>
zkc.deleteRecursive("/super");</code></pre>

</li>
<li><span style="font-size: 18px;"><span style="font-size: 18px;">对父节点添加watcher监听(subscribeDataChanges())</span></span><br /><span style="font-size: 18px;">只监听删除与修改操作</span><br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.131:2181,192.168.238.132:2181,192.168.1.129:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 5000;<span style="color: #008000;">//</span><span style="color: #008000;">ms</span>
ZkClient zkc = <span style="color: #0000ff;">new</span> ZkClient(<span style="color: #0000ff;">new</span> ZkConnection(CONNECT_ADDR), 10000<span style="color: #000000;">);
        
zkc.createPersistent(</span>"/super", "1234"<span style="color: #000000;">);
        
</span><span style="color: #008000;">//</span><span style="color: #008000;">对父节点添加监听变化。</span>
zkc.subscribeDataChanges("/super", <span style="color: #0000ff;">new</span><span style="color: #000000;"> IZkDataListener() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> handleDataDeleted(String path) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                System.out.println(</span>"删除的节点为:" +<span style="color: #000000;"> path);
            }
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> handleDataChange(String path, Object data) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                System.out.println(</span>"变更的节点为:" + path + ", 变更内容为:" +<span style="color: #000000;"> data);
            }
}); </span></code></pre>

</li>
<li><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">对子节点添加watcher监听(subscribeChildChanges())</span></span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">监听子节点的增删改操作</span><br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.131:2181,192.168.238.132:2181,192.168.1.129:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 5000;<span style="color: #008000;">//</span><span style="color: #008000;">ms</span>
<span style="color: #000000;">
ZkClient zkc </span>= <span style="color: #0000ff;">new</span> ZkClient(<span style="color: #0000ff;">new</span> ZkConnection(CONNECT_ADDR), 10000<span style="color: #000000;">);
        
</span><span style="color: #008000;">//</span><span style="color: #008000;">对父节点添加监听子节点变化。</span>
zkc.subscribeChildChanges("/super", <span style="color: #0000ff;">new</span><span style="color: #000000;"> IZkChildListener() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> handleChildChange(String parentPath, List&lt;String&gt; currentChilds) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                System.out.println(</span>"parentPath: " +<span style="color: #000000;"> parentPath);
                System.out.println(</span>"currentChilds: " +<span style="color: #000000;"> currentChilds);
            }
});</span></code></pre>

<p>&nbsp;</p>
</li>
</ol>
<h1>Curator API</h1>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">Curator是Netflix公司开源的一个Zookeeper客户端，后捐献给Apache，Curator框架在zookeeper原生API接口上进行了包装，解决了很多ZooKeeper客户端非常底层的细节开发。提供ZooKeeper各种应用场景( 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装，实现了Fluent风格(链式)的API接口</span><br /><br /></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">特性:</span></p>
<ol>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;"><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">重试机制:提供可插拔的重试机制, 它将给捕获所有可恢复的异常配置一个重试策略，并且内部也提供了几种标准的重试策略(比如指数补偿)</span></li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;"><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">连接状态监控: Curator初始化之后会一直对zk连接进行监听，一旦发现连接状态发生变化将会作出相应的处理</span></li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;"><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">zk客户端实例管理:Curator会对zk客户端到server集群的连接进行管理，并在需要的时候重建zk实例，保证与zk集群连接的可靠性</span></li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;"><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">各种使用场景支持:Curator实现了zk支持的大部分使用场景（甚至包括zk自身不支持的场景），这些实现都遵循了zk的最佳实践，并考虑了各种极端情况</span></li>








</ol>
<p style="font-family: 'Microsoft YaHei'; font-size: 18px;">&nbsp;</p>
<ol>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;">新建CuratorFramework对象<br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.1.171:2181,192.168.1.172:2181,192.168.1.173:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 5000;<span style="color: #008000;">//</span><span style="color: #008000;">ms
</span><span style="color: #008000;">//</span><span style="color: #008000;">1 重试策略：初试时间为1s 重试10次</span>
RetryPolicy retryPolicy = <span style="color: #0000ff;">new</span> ExponentialBackoffRetry(1000, 10<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">2 通过工厂创建连接</span>
CuratorFramework cf =<span style="color: #000000;"> CuratorFrameworkFactory.builder()
                    .connectString(CONNECT_ADDR)
                    .sessionTimeoutMs(SESSION_OUTTIME)
                    .retryPolicy(retryPolicy)
                    .build();
</span><span style="color: #008000;">//</span><span style="color: #008000;">3 开启连接</span>
cf.start();</code></pre>

</li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;">利用上文代码中的cf对象<strong>,创建,获取,修改,删除</strong>节点操作.<br />创建:<br />可以递归创建,但需要添加creatingParentsIfNeeded()<br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">4 建立节点 指定节点类型（不加withMode默认为持久类型节点）、路径、数据内容</span>
cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath("/super/c1","c1内容".getBytes());</code></pre>

获取:<br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">读取节点</span>
String ret1 = <span style="color: #0000ff;">new</span> String(cf.getData().forPath("/super/c2"));</code></pre>

修改:<br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">修改节点</span>
Stat stat = cf.setData().forPath("/super/c2", "修改c2内容".getBytes());</code></pre>

删除:<br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">使用该接口，只能删除叶子节点</span>
cf.delete().forPath("/super"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">删除一个节点，并递归删除其所有子节点</span>
cf.delete().deletingChildrenIfNeeded().forPath("/super"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">删除一个节点，强制指定版本进行删除</span>
cf.delete().withVersion(-1).forPath("/super"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">删除一个节点，强制保证删除</span>
cf.delete().guaranteed().forPath("/super"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">注意，guaranteed()接口是一个保障措施，只要客户端会话有效，那么Curator会在后台持续进行删除操作，直到节点删除成功。</span></code></pre>

<p>读取子节点与判断是否存在:</p>
<src class="cnblogs_code">
<pre><code>List&lt;String&gt; list = cf.getChildren().forPath("/super"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(String p : list){
            System.out.println(p);
        }
        
        Stat stat </span>= cf.checkExists().forPath("/super/c3"<span style="color: #000000;">);
        System.out.println(stat);</span></code></pre>

<p>&nbsp;</p>
</li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;">绑定回调函数<br />
<src class="cnblogs_code">
<pre><code>        ExecutorService pool =<span style="color: #000000;"> Executors.newCachedThreadPool();
        cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT)
        .inBackground(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> BackgroundCallback() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> processResult(CuratorFramework cf, CuratorEvent ce) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                System.out.println(</span>"code:" +<span style="color: #000000;"> ce.getResultCode());
                System.out.println(</span>"type:" +<span style="color: #000000;"> ce.getType());
                System.out.println(</span>"线程为:" +<span style="color: #000000;"> Thread.currentThread().getName());
            }
        }, pool)
        .forPath(</span>"/super/c3","c3内容".getBytes());</code></pre>

</li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;">对父节点添加watcher监听(NodeCache)<br />Curator的watcher是基于缓存实现的,缓存会定期向zookeeper获取最新数据到缓存中,供获取与校验(以空间换时间)<br /><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作</span>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.131:2181,192.168.238.132:2181,192.168.1.129:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 10000;<span style="color: #008000;">//</span><span style="color: #008000;">ms
</span><span style="color: #008000;">        //</span><span style="color: #008000;">1 重试策略：初试时间为1s 重试10次</span>
        RetryPolicy retryPolicy = <span style="color: #0000ff;">new</span> ExponentialBackoffRetry(1000, 10<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2 通过工厂创建连接</span>
        CuratorFramework cf =<span style="color: #000000;"> CuratorFrameworkFactory.builder()
                    .connectString(CONNECT_ADDR)
                    .sessionTimeoutMs(SESSION_OUTTIME)
                    .retryPolicy(retryPolicy)
                    .build();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3 建立连接</span>
<span style="color: #000000;">        cf.start();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4 建立一个cache缓存</span>
        <span style="color: #0000ff;">final</span> NodeCache cache = <span style="color: #0000ff;">new</span> NodeCache(cf, "/super", <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        cache.start(</span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
        cache.getListenable().addListener(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> NodeCacheListener() {
            </span><span style="color: #008000;">/**</span><span style="color: #008000;">
             * &lt;B&gt;方法名称：&lt;/B&gt;nodeChanged&lt;BR&gt;
             * &lt;B&gt;概要说明：&lt;/B&gt;触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作。&lt;BR&gt;
             * </span><span style="color: #808080;">@see</span><span style="color: #008000;"> org.apache.curator.framework.recipes.cache.NodeCacheListener#nodeChanged()
             </span><span style="color: #008000;">*/</span><span style="color: #000000;">
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> nodeChanged() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                System.out.println(</span>"路径为：" +<span style="color: #000000;"> cache.getCurrentData().getPath());
                System.out.println(</span>"数据为：" + <span style="color: #0000ff;">new</span><span style="color: #000000;"> String(cache.getCurrentData().getData()));
                System.out.println(</span>"状态为：" +<span style="color: #000000;"> cache.getCurrentData().getStat());
                System.out.println(</span>"---------------------------------------"<span style="color: #000000;">);
            }
        });</span></code></pre>

<p>&nbsp;</p>
</li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;">对子节点添加watcher监听(PathChildrenCache)<br />触发事件为增删改节点<br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.131:2181,192.168.238.132:2181,192.168.1.129:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 10000;<span style="color: #008000;">//</span><span style="color: #008000;">ms
</span><span style="color: #008000;">//</span><span style="color: #008000;">1 重试策略：初试时间为1s 重试10次</span>
        RetryPolicy retryPolicy = <span style="color: #0000ff;">new</span> ExponentialBackoffRetry(1000, 10<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2 通过工厂创建连接</span>
        CuratorFramework cf =<span style="color: #000000;"> CuratorFrameworkFactory.builder()
                    .connectString(CONNECT_ADDR)
                    .sessionTimeoutMs(SESSION_OUTTIME)
                    .retryPolicy(retryPolicy)
                    .build();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3 建立连接</span>
<span style="color: #000000;">        cf.start();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4 建立一个PathChildrenCache缓存,第三个参数为是否接受节点数据内容 如果为false则不接受</span>
        PathChildrenCache cache = <span style="color: #0000ff;">new</span> PathChildrenCache(cf, "/super", <span style="color: #0000ff;">true</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5 在初始化的时候就进行缓存监听</span>
<span style="color: #000000;">        cache.start(StartMode.POST_INITIALIZED_EVENT);
        cache.getListenable().addListener(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> PathChildrenCacheListener() {
            </span><span style="color: #008000;">/**</span><span style="color: #008000;">
             * &lt;B&gt;方法名称：&lt;/B&gt;监听子节点变更&lt;BR&gt;
             * &lt;B&gt;概要说明：&lt;/B&gt;新建、修改、删除&lt;BR&gt;
             * </span><span style="color: #808080;">@see</span><span style="color: #008000;"> org.apache.curator.framework.recipes.cache.PathChildrenCacheListener#childEvent(org.apache.curator.framework.CuratorFramework, org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent)
             </span><span style="color: #008000;">*/</span><span style="color: #000000;">
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> childEvent(CuratorFramework cf, PathChildrenCacheEvent event) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (event.getType()) {
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> CHILD_ADDED:
                    System.out.println(</span>"CHILD_ADDED :" +<span style="color: #000000;"> event.getData().getPath());
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> CHILD_UPDATED:
                    System.out.println(</span>"CHILD_UPDATED :" +<span style="color: #000000;"> event.getData().getPath());
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> CHILD_REMOVED:
                    System.out.println(</span>"CHILD_REMOVED :" +<span style="color: #000000;"> event.getData().getPath());
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        });</span></code></pre>

</li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;">分布式锁简单实现-共享锁(全局同步阻塞锁InterProcessMutex)<br />主要利用Curator的InterProcessMutex实现<br />for循环创建10个线程,利用CountDownLatch把十个线程阻塞在同一位置coutdown.await();,然后再同时释放阻塞coutdown.countDown();<br />lock.acquire();获取锁<br />lock.release();释放锁<br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.131:2181,192.168.238.132:2181,192.168.1.129:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 5000;<span style="color: #008000;">//</span><span style="color: #008000;">ms </span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> CuratorFramework createCuratorFramework(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1 重试策略：初试时间为1s 重试10次</span>
        RetryPolicy retryPolicy = <span style="color: #0000ff;">new</span> ExponentialBackoffRetry(1000, 10<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2 通过工厂创建连接</span>
        CuratorFramework cf =<span style="color: #000000;"> CuratorFrameworkFactory.builder()
                    .connectString(CONNECT_ADDR)
                    .sessionTimeoutMs(SESSION_OUTTIME)
                    .retryPolicy(retryPolicy)
                    .build();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cf;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #0000ff;">final</span> CountDownLatch coutdown = <span style="color: #0000ff;">new</span> CountDownLatch(1<span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0; i &lt; 10; i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

                @Override
                </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                    CuratorFramework cf </span>=<span style="color: #000000;"> createCuratorFramework();
                    cf.start();
                    </span><span style="color: #0000ff;">final</span> InterProcessMutex lock = <span style="color: #0000ff;">new</span> InterProcessMutex(cf, "/super"<span style="color: #000000;">);</span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        coutdown.await();
                        lock.acquire();
                        System.out.println(Thread.currentThread().getName() </span>+ "执行业务逻辑.."<span style="color: #000000;">);
                        Thread.sleep(</span>1000<span style="color: #000000;">);
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
                        e.printStackTrace();
                    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">释放</span>
<span style="color: #000000;">                            lock.release();
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">reentrantLock.unlock();</span>
                        } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            },</span>"t" +<span style="color: #000000;"> i).start();
        }
        Thread.sleep(</span>2000<span style="color: #000000;">);
        coutdown.countDown();    
    }</span></code></pre>

<p>&nbsp;</p>
</li>
<li style="font-family: 'Microsoft YaHei'; font-size: 18px;">分布式计数器(DistributedAtomicInteger)<br />AtomicValue&lt;Integer&gt; value =atomicIntger.add(2);<br />"更改状态 "&nbsp; value.succeeded()<br /><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">"更改前 "&nbsp; value.preValue()<br /></span><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">"更改后 "&nbsp; value.postValue()</span>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.131:2181,192.168.238.132:2181,192.168.1.129:2181"<span style="color: #000000;">;
</span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>

<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 5000;<span style="color: #008000;">//</span><span style="color: #008000;">ms</span>

<span style="color: #0000ff;">static</span> org.apache.curator.framework.recipes.atomic.DistributedAtomicInteger atomicIntger =<span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        CountDownLatch countDown</span>=<span style="color: #0000ff;">new</span> CountDownLatch(1<span style="color: #000000;">);

        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0; i &lt; 5; i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable()  {
                @Override
                </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {

                    </span><span style="color: #008000;">//</span><span style="color: #008000;">1 重试策略：初试时间为1s 重试10次</span>
                    RetryPolicy retryPolicy = <span style="color: #0000ff;">new</span> ExponentialBackoffRetry(1000, 10<span style="color: #000000;">);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">2 通过工厂创建连接</span>
                    CuratorFramework cf =<span style="color: #000000;"> CuratorFrameworkFactory.builder()
                            .connectString(CONNECT_ADDR)
                            .sessionTimeoutMs(SESSION_OUTTIME)
                            .retryPolicy(retryPolicy)
                            .build();
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">3 开启连接</span>
<span style="color: #000000;">                    cf.start();
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        countDown.await();<br />
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">4 使用DistributedAtomicInteger</span>
                    atomicIntger = <span style="color: #0000ff;">new</span> org.apache.curator.framework.recipes.atomic.DistributedAtomicInteger(cf, "/super", <span style="color: #0000ff;">new</span> RetryNTimes(3, 1000<span style="color: #000000;">));
                    System.out.println(Thread.currentThread().getName()</span>+"开始增加"<span style="color: #000000;">);
                    AtomicValue</span>&lt;Integer&gt; value =atomicIntger.add(2<span style="color: #000000;">);
                    System.out.println(</span>"更改状态 "+<span style="color: #000000;">value.succeeded());
                    System.out.println(</span>"更改前 "+<span style="color: #000000;">value.preValue());
                    System.out.println(</span>"更改后 "+<span style="color: #000000;">value.postValue());
                    System.out.println(</span>"-------------------------------------------------"<span style="color: #000000;">);
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
                        e.printStackTrace();
                    }
                }
            },</span>"t" +<span style="color: #000000;"> i).start();
        }

        Thread.sleep(</span>3000<span style="color: #000000;">);</span>
<span style="color: #000000;">        countDown.countDown();
    }</span></code></pre>

<p>输出结果:</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">t0开始增加
t3开始增加
t1开始增加
t2开始增加
t4开始增加
更改状态 true
更改前 0
更改后 2
-------------------------------------------------
更改状态 true
更改前 2
更改后 4
-------------------------------------------------
更改状态 true
更改前 4
更改后 6
-------------------------------------------------
更改状态 true
更改前 6
更改后 8
-------------------------------------------------
更改状态 true
更改前 8
更改后 10
-------------------------------------------------</span></code></pre>

<p>&nbsp;</p>
</li>
<li><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">分布式Barrier(DistributedDoubleBarrier&nbsp; &nbsp; &nbsp;DistributedBarrier)<br /></span></span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">DistributedDoubleBarrier:<br /><img src="./images/ZooKeeper笔记0.png" alt="" /><br />barrier.enter();阻滞线程,只有当所有线程都串行执行到此处,才放行,让线程并行执行.<br />barrier.leave();线程并行执行结束后,只有所有线程都执行结束,才放行,让线程串行执行</span><br />
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.129:2181,192.168.238.131:2181,192.168.238.132:2181"<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 5000;<span style="color: #008000;">//</span><span style="color: #008000;">ms </span>
    
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception { 
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0; i &lt; 5; i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
                @Override
                </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        RetryPolicy retryPolicy </span>= <span style="color: #0000ff;">new</span> ExponentialBackoffRetry(1000, 10<span style="color: #000000;">);
                        CuratorFramework cf </span>=<span style="color: #000000;"> CuratorFrameworkFactory.builder()
                                    .connectString(CONNECT_ADDR)
                                    .retryPolicy(retryPolicy)
                                    .build();
                        cf.start();
                        
                        DistributedDoubleBarrier barrier </span>= <span style="color: #0000ff;">new</span> DistributedDoubleBarrier(cf, "/super", 5<span style="color: #000000;">);
                        Thread.sleep(</span>1000 * (<span style="color: #0000ff;">new</span> Random()).nextInt(3<span style="color: #000000;">));
                        System.out.println(Thread.currentThread().getName() </span>+ "已经准备"<span style="color: #000000;">);
                        barrier.enter();
                        System.out.println(</span>"同时开始运行..."<span style="color: #000000;">);
                        Thread.sleep(</span>1000 * (<span style="color: #0000ff;">new</span> Random()).nextInt(3<span style="color: #000000;">));
                        System.out.println(Thread.currentThread().getName() </span>+ "运行完毕"<span style="color: #000000;">);
                        barrier.leave();
                        System.out.println(</span>"同时退出运行..."<span style="color: #000000;">);
                        

                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
                        e.printStackTrace();
                    }
                }
            },</span>"t" +<span style="color: #000000;"> i).start();
        }   
    }</span></code></pre>

<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">输出结果:</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">t3已经准备
t1已经准备
t2已经准备
t4已经准备
t0已经准备
同时开始运行...
同时开始运行...
同时开始运行...
同时开始运行...
同时开始运行...
t2运行完毕
t3运行完毕
t4运行完毕
t1运行完毕
t0运行完毕
同时退出运行...
同时退出运行...
同时退出运行...
同时退出运行...
同时退出运行...</span></code></pre>

<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">DistributedBarrier:</span><br /><img src="./images/ZooKeeper笔记1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><br /><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">barrier.setBarrier();通过setBarrier()将新建的DistributedBarrier注入到barrier中</span><br /><span style="font-family: 'Microsoft YaHei'; font-size: 18px;">barrier.waitOnBarrier();设置阻滞,等待barrier.removeBarrier();释放,所有线程继续运行</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">    /**</span><span style="color: #008000;"> zookeeper地址 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CONNECT_ADDR = "192.168.238.131:2181,192.168.238.132:2181,192.168.1.129:2181"<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> session超时时间 </span><span style="color: #008000;">*/</span>

    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> SESSION_OUTTIME = 1000;<span style="color: #008000;">//</span><span style="color: #008000;">ms</span>
    
    <span style="color: #0000ff;">static</span> DistributedBarrier barrier = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        
        
        
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0; i &lt; 3; i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable()  {
                @Override
                </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {

                        RetryPolicy retryPolicy </span>= <span style="color: #0000ff;">new</span> ExponentialBackoffRetry(1000, 10<span style="color: #000000;">);
                        CuratorFramework cf </span>=<span style="color: #000000;"> CuratorFrameworkFactory.builder()
                                    .connectString(CONNECT_ADDR)
                                    .sessionTimeoutMs(SESSION_OUTTIME)
                                    .retryPolicy(retryPolicy)
                                    .build();
                        cf.start();
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        barrier </span>= <span style="color: #0000ff;">new</span> DistributedBarrier(cf, "/s"<span style="color: #000000;">);
                        System.out.println(Thread.currentThread().getName() </span>+ "设置barrier!"<span style="color: #000000;">);

                        barrier.setBarrier();    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置</span>
                        barrier.waitOnBarrier();    <span style="color: #008000;">//</span><span style="color: #008000;">等待</span>
<span style="color: #000000;">
                    System.out.println(</span>"---------开始执行程序----------"<span style="color: #000000;">);
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
                        e.printStackTrace();
                    }

                }
            },</span>"t" +<span style="color: #000000;"> i).start();
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">留给三个线程初始化连接的时间.不然barrier对象没有连接 空指针</span>
        Thread.sleep(15000<span style="color: #000000;">);
        barrier.removeBarrier();    </span><span style="color: #008000;">//</span><span style="color: #008000;">释放</span>
<span style="color: #000000;">        
        
    }</span></code></pre>

<p>输出结果:</p>
<src class="cnblogs_code">
<pre><code>t1设置barrier!<span style="color: #000000;">
t0设置barrier</span>!<span style="color: #000000;">
t2设置barrier</span>!
---------开始执行程序----------
---------开始执行程序----------
---------开始执行程序----------</code></pre>

<p>&nbsp;</p>
<br /><br /></li>




</ol>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><strong>&nbsp;</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 18px;"><strong>&nbsp;</strong></span></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>