<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修 JDK1.8新特性-Lambda表达式' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center> JDK1.8新特性-Lambda表达式</center></div><div class='banquan'>原文出处:本文由博客园博主佩奇er提供。<br/>
原文连接:https://www.cnblogs.com/hxun/p/11833680.html</div><br>
    <h1>Lambda 表达式</h1>
<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
<h3>语法</h3>
<p>lambda 表达式的语法格式如下：</p>
<src>
<src id="highlighter_743053" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code>(parameters) -&gt;<span style="color: #000000;"> expression
(parameters) </span>-&gt;{ statements; }</code></pre>



<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h2>Lambda 表达式实例</h2>
<p>Lambda 表达式的简单例子:</p>
<src>
<src id="highlighter_600774" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 1. 不需要参数,返回值为 5 </span>
() -&gt; 5 
 
<span style="color: #008000;">//</span><span style="color: #008000;"> 2. 接收一个参数(数字类型),返回其2倍的值 </span>
x -&gt; 2 *<span style="color: #000000;"> x 
 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 3. 接受2个参数(数字),并返回他们的差值 </span>
(x, y) -&gt;<span style="color: #000000;"> x &ndash; y 
 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 4. 接收2个int型整数,返回他们的和 </span>
(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y) -&gt; x +<span style="color: #000000;"> y 
 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) </span>
(String s) -&gt; System.out.print(s)</code></pre>



<p>在 Java8Tester.java 文件输入以下代码：</p>
<src>
<src id="highlighter_522896" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Java8Tester {
   </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){
      Java8Tester tester </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Java8Tester();
 
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> 类型声明</span>
      MathOperation addition = (<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b) -&gt; a +<span style="color: #000000;"> b;
 
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> 不用类型声明</span>
      MathOperation subtraction = (a, b) -&gt; a -<span style="color: #000000;"> b;
 
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> 大括号中的返回语句</span>
      MathOperation multiplication = (<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b) -&gt; { <span style="color: #0000ff;">return</span> a *<span style="color: #000000;"> b; };
 
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> 没有大括号及返回语句</span>
      MathOperation division = (<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b) -&gt; a /<span style="color: #000000;"> b;
 
      System.out.println(</span>"10 + 5 = " + tester.operate(10, 5<span style="color: #000000;">, addition));
      System.out.println(</span>"10 - 5 = " + tester.operate(10, 5<span style="color: #000000;">, subtraction));
      System.out.println(</span>"10 x 5 = " + tester.operate(10, 5<span style="color: #000000;">, multiplication));
      System.out.println(</span>"10 / 5 = " + tester.operate(10, 5<span style="color: #000000;">, division));
 
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> 不用括号</span>
      GreetingService greetService1 = message -&gt;<span style="color: #000000;">
      System.out.println(</span>"Hello " +<span style="color: #000000;"> message);
 
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> 用括号</span>
      GreetingService greetService2 = (message) -&gt;<span style="color: #000000;">
      System.out.println(</span>"Hello " +<span style="color: #000000;"> message);
 
      greetService1.sayMessage(</span>"Nowcoder"<span style="color: #000000;">);
      greetService2.sayMessage(</span>"Google"<span style="color: #000000;">);
   }
 
   </span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> MathOperation {
      </span><span style="color: #0000ff;">int</span> operation(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
   }
 
   </span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> GreetingService {
      </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> sayMessage(String message);
   }
 
   </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> operate(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b, MathOperation mathOperation){
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mathOperation.operation(a, b);
   }
}</span></code></pre>



<p>执行以上脚本，输出结果为：</p>
<src>
<src id="highlighter_888985" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">$ javac Java8Tester.java
$ java Java8Tester
</span>10 + 5 = 15
10 - 5 = 5
10 x 5 = 50
10 / 5 = 2<span style="color: #000000;">
Hello Nowcoder
Hello Google</span></code></pre>



<p>使用 Lambda 表达式需要注意以下两点：</p>
<ul>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li>
<li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
</ul>
<h2>变量作用域</h2>
<p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>
<p>在 Java8Tester.java 文件输入以下代码：</p>
<src>
<src id="highlighter_295077" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Java8Tester {
 
   </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">static</span> String salutation = "Hello! "<span style="color: #000000;">;
 
   </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){
      GreetingService greetService1 </span>= message -&gt;<span style="color: #000000;">
      System.out.println(salutation </span>+<span style="color: #000000;"> message);
      greetService1.sayMessage(</span>"Nowcoder"<span style="color: #000000;">);
   }
 
   </span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> GreetingService {
      </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> sayMessage(String message);
   }
}</span></code></pre>



<p>执行以上脚本，输出结果为：</p>
<src>
<src id="highlighter_350458" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">$ javac Java8Tester.java
$ java Java8Tester
Hello</span>! Nowcoder</code></pre>



<p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p>
<src>
<src id="highlighter_918489" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Java8Tester {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]) {
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> num = 1<span style="color: #000000;">;
        Converter</span>&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param +<span style="color: #000000;"> num));
        s.convert(</span>2);  <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果为 3</span>
<span style="color: #000000;">    }
 
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> Converter&lt;T1, T2&gt;<span style="color: #000000;"> {
        </span><span style="color: #0000ff;">void</span> convert(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i);
    }
}</span></code></pre>



<p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p>
<src>
<src id="highlighter_346318" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span> num = 1<span style="color: #000000;">; 
Converter</span>&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param +<span style="color: #000000;"> num));
s.convert(</span>2<span style="color: #000000;">);
num </span>= 5<span style="color: #000000;">; 
</span><span style="color: #008000;">//</span><span style="color: #008000;">报错信息：Local variable num defined in an enclosing scope must be final or effectively</span>
 <span style="color: #0000ff;">final</span></code></pre>

<p>&nbsp;</p>


<p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p>
<src>
<src id="highlighter_511670" class="syntaxhighlighter  java">
<src class="cnblogs_code">
<pre><code>String first = ""<span style="color: #000000;">; 
Comparator</span>&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span style="color: #008000;">//</span><span style="color: #008000;">编译会出错</span></code></pre>

<p><strong>&nbsp;</strong></p>
<p><strong>函数既可以作为参数，也可以作为返回值，看一下下面这个例子</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">这是常规的Collections的排序的写法，需要对接口方法重写</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test1(){
    List</span>&lt;String&gt; list =Arrays.asList("aaa","fsa","ser","eere"<span style="color: #000000;">);
    Collections.sort(list, </span><span style="color: #0000ff;">new</span> Comparator&lt;String&gt;<span style="color: #000000;">() {
        @Override
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> compare(String o1, String o2) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> o2.compareTo(o1);
        }
    });
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String string : list) {
        System.out.println(string);
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">这是带参数类型的Lambda的写法</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> testLamda1(){
    List</span>&lt;String&gt; list =Arrays.asList("aaa","fsa","ser","eere"<span style="color: #000000;">);
    Collections.sort(list, (Comparator</span>&lt;? <span style="color: #0000ff;">super</span> String&gt;) (String a,String b)-&gt;<span style="color: #000000;">
    {</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> b.compareTo(a); });
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String string : list) {
        System.out.println(string);
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">这是不带参数的lambda的写法</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> testLamda2(){
    List</span>&lt;String&gt; list =Arrays.asList("aaa","fsa","ser","eere"<span style="color: #000000;">);
    Collections.sort(list, (a,b)</span>-&gt;<span style="color: #000000;">b.compareTo(a));
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String string : list) {
        System.out.println(string);
    }
}</span></code></pre>

<p>&nbsp;</p>

<src class="syntaxhighlighter  java"><span style="color: #ff0000;">ending...</span>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>