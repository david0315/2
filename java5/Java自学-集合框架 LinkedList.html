<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java自学-集合框架 LinkedList' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java自学-集合框架 LinkedList</center></div><div class='banquan'>原文出处:本文由博客园博主半米高峰提供。<br/>
原文连接:https://www.cnblogs.com/jeddzd/p/11934485.html</div><br>
    <h2 id="java集合框架-linkedlist">Java集合框架 LinkedList</h2>
<p>序列分先进先出FIFO,先进后出FILO<br />
FIFO在Java中又叫Queue 队列<br />
FILO在Java中又叫Stack 栈</p>
<p>示例 1 : <strong>LinkedList 与 List接口</strong></p>
<p>与<strong>ArrayList</strong>一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。</p>
<p>示例 2 : <strong>双向链表 - Deque</strong></p>
<p>除了实现了List接口外，LinkedList还实现了<strong>双向链表结构</strong>Deque，可以很方便的在头尾插入删除数据</p>
<p>什么是链表结构: 与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，不用关心除此之外的其他佛珠在哪里。<br />
<img src="./images/Java自学-集合框架 LinkedList0.png" alt="在这里插入图片描述" /></p>
<pre><code><code>package collection;
 
import java.util.LinkedList;
 
import charactor.Hero;
 
public class TestCollection {
 
    public static void main(String[] args) {
         
        //LinkedList是一个双向链表结构的list
        LinkedList&lt;Hero&gt; ll =new LinkedList&lt;Hero&gt;();
         
        //所以可以很方便的在头部和尾部插入数据
        //在最后插入新的英雄
        ll.addLast(new Hero(&quot;hero1&quot;));
        ll.addLast(new Hero(&quot;hero2&quot;));
        ll.addLast(new Hero(&quot;hero3&quot;));
        System.out.println(ll);
         
        //在最前面插入新的英雄
        ll.addFirst(new Hero(&quot;heroX&quot;));
        System.out.println(ll);
         
        //查看最前面的英雄
        System.out.println(ll.getFirst());
        //查看最后面的英雄
        System.out.println(ll.getLast());
         
        //查看不会导致英雄被删除
        System.out.println(ll);
        //取出最前面的英雄
        System.out.println(ll.removeFirst());
         
        //取出最后面的英雄
        System.out.println(ll.removeLast());
         
        //取出会导致英雄被删除
        System.out.println(ll);
         
    }
      
}</code></code></pre>
<p>示例 3 : <strong>队列 - Queue</strong></p>
<p>LinkedList 除了实现了List和Deque外，还实现了<strong>Queue</strong>接口(队列)。<br />
Queue是先进先出队列 <strong>FIFO</strong>，常用方法：<br />
<strong>offer</strong> 在最后添加元素<br />
<strong>poll</strong> 取出第一个元素<br />
<strong>peek</strong> 查看第一个元素<br />
<img src="./images/Java自学-集合框架 LinkedList1.png" alt="队列 - Queue" /></p>
<pre><code><code>package collection;
  
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
  
import charactor.Hero;
  
public class TestCollection {
  
    public static void main(String[] args) {
        //和ArrayList一样，LinkedList也实现了List接口
        List ll =new LinkedList&lt;Hero&gt;();
          
        //所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口
        //Queue代表FIFO 先进先出的队列
        Queue&lt;Hero&gt; q= new LinkedList&lt;Hero&gt;();
          
        //加在队列的最后面
        System.out.print(&quot;初始化队列：\t&quot;);
        q.offer(new Hero(&quot;Hero1&quot;));
        q.offer(new Hero(&quot;Hero2&quot;));
        q.offer(new Hero(&quot;Hero3&quot;));
        q.offer(new Hero(&quot;Hero4&quot;));
          
        System.out.println(q);
        System.out.print(&quot;把第一个元素取poll()出来:\t&quot;);
        //取出第一个Hero，FIFO 先进先出
        Hero h = q.poll();
        System.out.println(h);
        System.out.print(&quot;取出第一个元素之后的队列:\t&quot;);
        System.out.println(q);
          
        //把第一个拿出来看一看，但是不取出来
        h=q.peek();
        System.out.print(&quot;查看peek()第一个元素:\t&quot;);
        System.out.println(h);
        System.out.print(&quot;查看并不会导致第一个元素被取出来:\t&quot;);
        System.out.println(q);
          
    }
       
}</code></code></pre>
<p><strong>练习</strong>： <a href="https://how2j.cn/k/collection/collection-linkedlist/370.html?p=43278">使用LinkedList实现Stack栈</a></p>
<p>与FIFO(先入先出的)队列类似的一种数据结构是FILO先入后出栈Stack<br />
根据接口Stack ：<br />
实现类：MyStack</p>
<pre class="java"><code>public class MyStack implements Stack</code></code></pre>
<p>并向这个栈中，压入5个英雄，接着弹出5个英雄</p>
<p>再解释一下栈: 栈的结构，就像给弹夹添加子弹一样，先添加的子弹，就放在了最下面，打手枪的时候，只能从最上面取子弹。</p>
<pre class="java"><code>package collection;
 
import charactor.Hero;
 
public interface Stack {
 
    //把英雄推入到最后位置
    public void push(Hero h);
    //把最后一个英雄取出来
    public Hero pull();
    //查看最后一个英雄
    public Hero peek();
}</code></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>