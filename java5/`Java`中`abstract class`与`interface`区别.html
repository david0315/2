<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修`Java`中`abstract class`与`interface`区别' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>`Java`中`abstract class`与`interface`区别</center></div><div class='banquan'>原文出处:本文由博客园博主从此寂静无声提供。<br/>
原文连接:https://www.cnblogs.com/jason1990/p/11606995.html</div><br>
    <h2 id="abstract-class"><code>abstract class</code></h2>
<p><code>Java</code>中允许使用<code>abstract</code>修饰符声明方法，此时只定义方法但是不实现方法(<code>abstract</code>修饰的方法没有主体，只有一个签名和一个分号).<br />
以下是<code>abstract</code>方法和这些方法所在的<code>abstract</code>类相关的规则:</p>
<ul>
<li>只要类中有一个<code>abstract</code>方法，那么这个类本身就自动成为<code>abstract</code>，而且必须声明为<code>abstract class</code>，否则会导致编译错误;</li>
<li><code>abstract class</code>无法实例化;</li>
<li><code>abstract</code>类的子类必须覆盖超类的每个<code>abstract</code>方法，并且把这些方法全部实现(即提供方法主体)，才能实例化.这种类一般称为具体子类(<code>concrete subclass</code>)，目的是强调它不是抽象类.</li>
<li>如果<code>abstract class</code>的子类没有实现集成的所有<code>abstract</code>方法，那么这个子类仍然是<code>abstract class</code>，而且必须使用<code>abstract</code>声明;</li>
<li>使用<code>static</code>,<code>private</code>以及<code>final</code>声明的方法不能是抽象方法，因为这三种方法在子类中不能被覆盖.类似的，<code>final class</code>中不能有任何<code>abstract</code>方法;</li>
<li>就算类中没有<code>abstract</code>方法，这个类也能声明为<code>abstract</code>.使用这种方法声明的<code>abstract</code>类表明类实现的不完善，需要交给子类实现，这种类不能被实例化.</li>
</ul>
<h2 id="interface"><code>interface</code></h2>
<p><code>Java</code>的类继承是单继承模式，为了更进一步的面向对象扩展，<code>Java</code>创建了<code>interface</code>概念.<br />
<code>interface</code>的作用只是描绘<code>API</code>，因此，<code>interface</code>提供类型的描述信息，以及实现这个<code>API</code>的类应该提供的方法.</p>
<p>以下是<code>interface</code>相关的规则:</p>
<ul>
<li><code>interface</code>中所有强制方法都隐式使用<code>abstract</code>声明，不能有方法主体，要使用分号(可以使用<code>abstract</code>修饰符，不过一般省略);</li>
<li>接口定义公开的<code>API</code>.<code>interface</code>中的所有成员都隐式使用<code>public</code>声明，而且习惯省略不必要的<code>public</code>修饰符.如果在接口中使用<code>protected</code>或者<code>private</code>定义方法，会导致编译错误;</li>
<li><code>interface</code>中不能定义任何势实例字段.字段是实现细节，而接口是规则不是事先，在接口中只能定义同时使用<code>static</code>和<code>final</code>声明的常量;</li>
<li>接口不能实例化，因此不能定义构造函数;</li>
<li>接口中可能包含嵌套类型.嵌套类型隐式使用<code>public</code>和<code>static</code>声明;</li>
<li>从<code>Java 8</code>开始，<code>interface</code>中可以包含静态方法.</li>
</ul>
<h2 id="区别总结">区别总结</h2>
<p><code>abstract class</code>与<code>interface</code>存在诸多联系，也存在差异.<br />
以下是个人总结的差异支出:</p>
<ul>
<li><code>abstract class</code>是<code>class</code>中存在未实现的方法，留待继承的子类实现,<code>interface</code>中的方法则均是未实现的方法(<code>Java 8</code>中<code>interface</code>中的<code>default</code>方法除外);</li>
</ul>
<pre><code><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {
    // `interface`中被`default`修饰的方法，提供默认实现
    default void sort(Comparator&lt;? super E&gt; c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator&lt;E&gt; i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
}</code></code></pre>
<ul>
<li>子类只能<code>extends</code>单个<code>abstract class</code>，但是可以<code>implements</code>多个<code>interface</code>;</li>
<li><code>abstract class</code>中能声明<code>non final</code>变量(诸如<code>int test;</code>),<code>interface</code>中仅能声明被<code>static final</code>修饰的变量;</li>
<li><code>abstract class</code>中变量可以被<code>private</code>,<code>public</code>以及<code>protected</code>修饰,<code>interface</code>中变量仅能被<code>public</code>修饰;</li>
<li><code>intercae</code>可以<code>extends</code>多个<code>interface</code>，而<code>abstract class</code>可以<code>extends</code>一个类(非限定于<code>abstract class</code>)以及多个<code>interface</code>.</li>
</ul>
<h2 id="编码使用">编码使用</h2>
<p>在日常的代码编写工作中，选用<code>abstract class</code>或者<code>interface</code>需要慎重.</p>
<ul>
<li><code>abstract class</code>表示继承关系，继承关系在本质上是&quot;is a&quot;关系;</li>
<li><code>interface</code>则表示具有某种行为关系，是<code>like a</code>关系.</li>
</ul>
<p>以<code>带报警器的门</code>为例，她具有门的作用，也具有报警功能.</p>
<ul>
<li>继承门(门为<code>abstract class</code>,子类实现开关函数);</li>
<li>实现告警功能(实现告警<code>interface</code>,完成报警函数).</li>
</ul>
<blockquote>
<p>PS:<br />
如果您觉得我的文章对您有帮助，请关注我的微信公众号，谢谢!<br />
<img src="./images/`Java`中`abstract class`与`interface`区别0.png" alt="程序员打怪之路" /></p>
</blockquote>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>