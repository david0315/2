<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修spring5 源码深度解析----- 事务增强器（100%理解事务）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>spring5 源码深度解析----- 事务增强器（100%理解事务）</center></div><div class='banquan'>原文出处:本文由博客园博主chen_hao提供。<br/>
原文连接:https://www.cnblogs.com/java-chen-hao/p/11613797.html</div><br>
    <p>上一篇文章我们讲解了事务的Advisor是如何注册进Spring容器的，也讲解了Spring是如何将有配置事务的类配置上事务的，实际上也就是用了AOP那一套，也讲解了Advisor，pointcut验证流程，至此，事务的初始化工作都已经完成了，在之后的调用过程，如果代理类的方法被调用，都会调用BeanFactoryTransactionAttributeSourceAdvisor这个Advisor的增强方法，也就是我们还未提到的那个Advisor里面的advise，还记得吗，在自定义标签的时候我们将TransactionInterceptor这个Advice作为bean注册进IOC容器，并且将其注入进Advisor中，这个Advice在代理类的invoke方法中会被封装到拦截器链中，最终事务的功能都在advise中体现，所以我们先来关注一下TransactionInterceptor这个类吧。</p>
<p>TransactionInterceptor类继承自MethodInterceptor，所以调用该类是从其invoke方法开始的，首先预览下这个方法：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Override
@Nullable
</span><span style="color: #0000ff;">public</span> Object invoke(<span style="color: #0000ff;">final</span> MethodInvocation invocation) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Work out the target class: may be {@code null}.
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> The TransactionAttributeSource should be passed the target class
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> as well as the method, which may be from an interface.</span>
    Class&lt;?&gt; targetClass = (invocation.getThis() != <span style="color: #0000ff;">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span style="color: #0000ff;">null</span><span style="color: #000000;">);

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Adapt to TransactionAspectSupport's invokeWithinTransaction...</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"><strong> invokeWithinTransaction</strong>(invocation.getMethod(), targetClass, invocation::proceed);
}</span></code></pre>

<p>重点来了，进入invokeWithinTransaction方法：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Nullable
</span><span style="color: #0000ff;">protected</span> Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt;<span style="color: #000000;"> targetClass,
        </span><span style="color: #0000ff;">final</span> InvocationCallback invocation) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> If the transaction attribute is null, the method is non-transactional.</span>
    TransactionAttributeSource tas =<span style="color: #000000;"> getTransactionAttributeSource();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取对应事务属性</span>
    <span style="color: #0000ff;">final</span> TransactionAttribute txAttr = (tas != <span style="color: #0000ff;">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取beanFactory中的transactionManager</span>
    <span style="color: #0000ff;">final</span> PlatformTransactionManager tm =<span style="color: #000000;"> determineTransactionManager(txAttr);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 构造方法唯一标识（类.方法，如：service.UserServiceImpl.save）</span>
    <span style="color: #0000ff;">final</span> String joinpointIdentification =<span style="color: #000000;"> methodIdentification(method, targetClass, txAttr);

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 声明式事务处理</span>
    <span style="color: #0000ff;">if</span> (txAttr == <span style="color: #0000ff;">null</span> || !(tm <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> CallbackPreferringPlatformTransactionManager)) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建TransactionInfo</span>
        TransactionInfo txInfo =<span style="color: #000000;"><strong> createTransactionIfNecessary</strong>(tm, txAttr, joinpointIdentification);
        Object retVal </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行原方法
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 继续调用方法拦截器链,这里一般将会调用目标类的方法,如:AccountServiceImpl.save方法</span>
            retVal =<span style="color: #000000;"><strong> invocation.proceedWithInvocation()</strong>;
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable ex) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 异常回滚</span>
<strong><span style="color: #000000;">            completeTransactionAfterThrowing(txInfo, ex);
            </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> 手动向上抛出异常，则下面的提交事务不会执行
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果子事务出异常，则外层事务代码需catch住子事务代码，不然外层事务也会回滚</span>
            <span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex;
        }
        </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 消除信息</span>
<span style="color: #000000;">            cleanupTransactionInfo(txInfo);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 提交事务</span>
<strong><span style="color: #000000;">        commitTransactionAfterReturning(txInfo);
        </span></strong><span style="color: #0000ff;">return</span><span style="color: #000000;"> retVal;
    }

    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #0000ff;">final</span> ThrowableHolder throwableHolder = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThrowableHolder();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 编程式事务处理</span>
            Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt;<span style="color: #000000;"> {
                TransactionInfo txInfo </span>=<span style="color: #000000;"> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> invocation.proceedWithInvocation();
                }
                </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable ex) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (txAttr.rollbackOn(ex)) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> A RuntimeException: will lead to a rollback.</span>
                        <span style="color: #0000ff;">if</span> (ex <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> RuntimeException) {
                            </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> (RuntimeException) ex;
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThrowableHolderException(ex);
                        }
                    }
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> A normal return value: will lead to a commit.</span>
                        throwableHolder.throwable =<span style="color: #000000;"> ex;
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    }
                }
                </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
                    cleanupTransactionInfo(txInfo);
                }
            });

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Check result state: It might indicate a Throwable to rethrow.</span>
            <span style="color: #0000ff;">if</span> (throwableHolder.throwable != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> throwableHolder.throwable;
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (ThrowableHolderException ex) {
            </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex.getCause();
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (TransactionSystemException ex2) {
            </span><span style="color: #0000ff;">if</span> (throwableHolder.throwable != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                logger.error(</span>"Application exception overridden by commit exception"<span style="color: #000000;">, throwableHolder.throwable);
                ex2.initApplicationException(throwableHolder.throwable);
            }
            </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex2;
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable ex2) {
            </span><span style="color: #0000ff;">if</span> (throwableHolder.throwable != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                logger.error(</span>"Application exception overridden by commit exception"<span style="color: #000000;">, throwableHolder.throwable);
            }
            </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex2;
        }
    }
}</span></code></pre>

<h2>创建事务Info对象</h2>
<p>我们先分析事务创建的过程。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">protected</span><span style="color: #000000;"> TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
        @Nullable TransactionAttribute txAttr, </span><span style="color: #0000ff;">final</span><span style="color: #000000;"> String joinpointIdentification) {

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> If no name specified, apply method identification as transaction name.
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果没有名称指定则使用方法唯一标识，并使用DelegatingTransactionAttribute封装txAttr</span>
    <span style="color: #0000ff;">if</span> (txAttr != <span style="color: #0000ff;">null</span> &amp;&amp; txAttr.getName() == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        txAttr </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> DelegatingTransactionAttribute(txAttr) {
            @Override
            </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName() {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> joinpointIdentification;
            }
        };
    }

    TransactionStatus status </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (txAttr != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">if</span> (tm != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取TransactionStatus</span>
          <strong>  status =</strong><span style="color: #000000;"><strong> tm.getTransaction(txAttr);</strong>
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (logger.isDebugEnabled()) {
                logger.debug(</span>"Skipping transactional joinpoint [" + joinpointIdentification +
                        "] because no transaction manager has been configured"<span style="color: #000000;">);
            }
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 根据指定的属性与status准备一个TransactionInfo</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"><strong> prepareTransactionInfo</strong>(tm, txAttr, joinpointIdentification, status);
}</span></code></pre>

<p>对于createTransactionlfNecessary函数主要做了这样几件事情。</p>
<p>（1）使用 DelegatingTransactionAttribute 封装传入的 TransactionAttribute 实例。</p>
<p>对于传入的TransactionAttribute类型的参数txAttr，当前的实际类型是RuleBasedTransactionAttribute，是由获取事务属性时生成，主要用于数据承载，而这里之所以使用DelegatingTransactionAttribute进行封装，当然是提供了更多的功能。</p>
<p>（2）获取事务。</p>
<p>事务处理当然是以事务为核心，那么获取事务就是最重要的事情。</p>
<p>（3）构建事务信息。</p>
<p>根据之前几个步骤获取的信息构建Transactionlnfo并返回。</p>
<h3>获取事务</h3>
<p>其中核心是在getTransaction方法中：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Override
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> TransactionStatus getTransaction(@Nullable TransactionDefinition definition) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> TransactionException {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取一个transaction</span>
    Object transaction =<span style="color: #000000;"><strong> doGetTransaction</strong>();

    </span><span style="color: #0000ff;">boolean</span> debugEnabled =<span style="color: #000000;"> logger.isDebugEnabled();

    </span><span style="color: #0000ff;">if</span> (definition == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        definition </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> DefaultTransactionDefinition();
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果在这之前已经存在事务了，就进入存在事务的方法中</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (<strong>isExistingTransaction</strong>(transaction)) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"><strong> handleExistingTransaction</strong>(definition, transaction, debugEnabled);
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 事务超时设置验证</span>
    <span style="color: #0000ff;">if</span> (definition.getTimeout() &lt;<span style="color: #000000;"> TransactionDefinition.TIMEOUT_DEFAULT) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> InvalidTimeoutException("Invalid transaction timeout"<span style="color: #000000;">, definition.getTimeout());
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 走到这里说明此时没有存在事务，如果传播特性是<strong>MANDATORY</strong>时抛出异常</span>
    <span style="color: #0000ff;">if</span> (definition.getPropagationBehavior() ==<span style="color: #000000;"> TransactionDefinition.<strong>PROPAGATION_MANDATORY</strong>) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IllegalTransactionStateException(
                </span>"No existing transaction found for transaction marked with propagation 'mandatory'"<span style="color: #000000;">);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此时不存在事务，当传播特性是REQUIRED或NEW或NESTED都会进入if语句块</span>
    <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (definition.getPropagationBehavior() == TransactionDefinition.<strong>PROPAGATION_REQUIRED</strong> ||<span style="color: #000000;">
            definition.getPropagationBehavior() </span>== TransactionDefinition.<strong>PROPAGATION_REQUIRES_NEW</strong> ||<span style="color: #000000;">
            definition.getPropagationBehavior() </span>==<span style="color: #000000;"> TransactionDefinition.<strong>PROPAGATION_NESTED</strong>) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED都需要新建事务
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 因为此时不存在事务，将null挂起</span>
        SuspendedResourcesHolder suspendedResources = suspend(<span style="color: #0000ff;">null</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (debugEnabled) {
            logger.debug(</span>"Creating new transaction with name [" + definition.getName() + "]: " +<span style="color: #000000;"> definition);
        }
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">boolean</span> newSynchronization = (getTransactionSynchronization() !=<span style="color: #000000;"> SYNCHRONIZATION_NEVER);
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> new一个status，存放刚刚创建的transaction，然后将其标记为新事务！
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这里transaction后面一个参数决定是否是新事务！</span>
            DefaultTransactionStatus status =<span style="color: #000000;"> newTransactionStatus(
                    definition, <strong>transaction</strong>, </span><strong><span style="color: #0000ff;">true</span></strong><span style="color: #000000;">, newSynchronization, debugEnabled, suspendedResources);
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 新开一个连接的地方，非常重要</span>
<span style="color: #000000;"><strong>            doBegin</strong>(transaction, definition);
            prepareSynchronization(status, definition);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> status;
        }
        </span><span style="color: #0000ff;">catch</span> (RuntimeException |<span style="color: #000000;"> Error ex) {
            resume(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, suspendedResources);
            </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex;
        }
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Create "empty" transaction: no actual transaction, but potentially synchronization.</span>
        <span style="color: #0000ff;">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp;<span style="color: #000000;"> logger.isWarnEnabled()) {
            logger.warn(</span>"Custom isolation level specified but no actual transaction initiated; " +
                    "isolation level will effectively be ignored: " +<span style="color: #000000;"> definition);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 其他的传播特性一律返回一个空事务，transaction = null
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当前不存在事务，且传播机制=PROPAGATION_SUPPORTS/PROPAGATION_NOT_SUPPORTED/PROPAGATION_NEVER，这三种情况，创建&ldquo;空&rdquo;事务</span>
        <span style="color: #0000ff;">boolean</span> newSynchronization = (getTransactionSynchronization() ==<span style="color: #000000;"> SYNCHRONIZATION_ALWAYS);
        </span><span style="color: #0000ff;">return</span> prepareTransactionStatus(definition, <strong><span style="color: #0000ff;">null</span></strong>, <span style="color: #0000ff;">true</span>, newSynchronization, debugEnabled, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }
}</span></code></pre>

<p>先来看看transaction是如何被创建出来的：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Override
</span><span style="color: #0000ff;">protected</span><span style="color: #000000;"> Object doGetTransaction() {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这里DataSourceTransactionObject是事务管理器的一个内部类
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> DataSourceTransactionObject就是一个transaction，这里new了一个出来</span>
    DataSourceTransactionObject txObject = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DataSourceTransactionObject();
    txObject.setSavepointAllowed(isNestedTransactionAllowed());
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 解绑与绑定的作用在此时体现，如果当前线程有绑定的话，将会取出holder
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 第一次conHolder肯定是null</span>
    ConnectionHolder conHolder =<span style="color: #000000;">
    (ConnectionHolder) <strong>TransactionSynchronizationManager.getResource(obtainDataSource());
    </strong></span><span style="color: #008000;">//</span><span style="color: #008000;"> 此时的holder被标记成一个旧holder</span>
    txObject.setConnectionHolder(conHolder, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> txObject;
}</span></code></pre>

<p>创建transaction过程很简单，接着就会判断当前是否存在事务：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Override
</span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isExistingTransaction(Object transaction) {
    DataSourceTransactionObject txObject </span>=<span style="color: #000000;"> (DataSourceTransactionObject) transaction;
    </span><span style="color: #0000ff;">return</span> (txObject.<strong>hasConnectionHolder()</strong> &amp;&amp;<span style="color: #000000;"> txObject.getConnectionHolder().<strong>isTransactionActive()</strong>);
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> hasConnectionHolder() {
    </span><span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">this</span>.connectionHolder != <span style="color: #0000ff;">null</span><span style="color: #000000;">);
}</span></code></pre>

<p>这里判断是否存在事务的依据主要是获取holder中的transactionActive变量是否为true，如果是第一次进入事务，holder直接为null判断不存在了，如果是第二次进入事务transactionActive变量是为true的（后面会提到是在哪里把它变成true的），由此来判断当前是否已经存在事务了。</p>
<p>至此，源码分成了2条处理线</p>
<p><strong>1.当前已存在事务：isExistingTransaction()判断是否存在事务，存在事务handleExistingTransaction()根据不同传播机制不同处理</strong></p>
<p><strong>2.当前不存在事务: 不同传播机制不同处理</strong></p>
<h2><sup>当前不存在事务</sup></h2>
<p>如果不存在事务，传播特性又是REQUIRED或NEW或NESTED，将会先挂起null，这个挂起方法我们后面再讲，然后创建一个DefaultTransactionStatus ，并将其标记为新事务，然后执行doBegin(transaction, definition);这个方法也是一个关键方法</p>
<h3>神秘又关键的status对象</h3>
<p><strong>TransactionStatus接口</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> TransactionStatus <span style="color: #0000ff;">extends</span><span style="color: #000000;"> SavepointManager, Flushable {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回当前事务是否为新事务（否则将参与到现有事务中，或者可能一开始就不在实际事务中运行）</span>
    <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isNewTransaction();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回该事务是否在内部携带保存点，也就是说，已经创建为基于保存点的嵌套事务。</span>
    <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> hasSavepoint();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 设置事务仅回滚。</span>
    <span style="color: #0000ff;">void</span><span style="color: #000000;"> setRollbackOnly();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回事务是否已标记为仅回滚</span>
    <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isRollbackOnly();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将会话刷新到数据存储区</span>
<span style="color: #000000;">    @Override
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> flush();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回事物是否已经完成，无论提交或者回滚。</span>
    <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isCompleted();
}</span></code></pre>

<p>&nbsp;</p>
<p>再来看看实现类DefaultTransactionStatus</p>
<p><strong>DefaultTransactionStatus</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> DefaultTransactionStatus <span style="color: #0000ff;">extends</span><span style="color: #000000;"> AbstractTransactionStatus {

    </span><span style="color: #008000;">//</span><span style="color: #008000;">事务对象</span>
<span style="color: #000000;">    @Nullable
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> Object transaction;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">事务对象</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> newTransaction;

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> newSynchronization;

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> readOnly;

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> debug;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">事务对象</span>
<span style="color: #000000;">    @Nullable
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> Object suspendedResources;
    
        </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> DefaultTransactionStatus(
            @Nullable Object transaction, </span><span style="color: #0000ff;">boolean</span> newTransaction, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> newSynchronization,
            </span><span style="color: #0000ff;">boolean</span> readOnly, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> debug, @Nullable Object suspendedResources) {

        </span><span style="color: #0000ff;">this</span>.transaction =<span style="color: #000000;"> transaction;
        </span><span style="color: #0000ff;">this</span>.newTransaction =<span style="color: #000000;"> newTransaction;
        </span><span style="color: #0000ff;">this</span>.newSynchronization =<span style="color: #000000;"> newSynchronization;
        </span><span style="color: #0000ff;">this</span>.readOnly =<span style="color: #000000;"> readOnly;
        </span><span style="color: #0000ff;">this</span>.debug =<span style="color: #000000;"> debug;
        </span><span style="color: #0000ff;">this</span>.suspendedResources =<span style="color: #000000;"> suspendedResources;
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">略...</span>
}</code></pre>

<p>&nbsp;</p>
<p>我们看看这行代码 DefaultTransactionStatus status = <strong>newTransactionStatus</strong>(&nbsp;definition, <strong>transaction, true</strong>, newSynchronization, debugEnabled, <strong>suspendedResources</strong>);</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 这里是构造一个status对象的方法</span>
<span style="color: #0000ff;">protected</span><span style="color: #000000;"> DefaultTransactionStatus newTransactionStatus(
    TransactionDefinition definition, @Nullable Object transaction, </span><span style="color: #0000ff;">boolean</span><span style="color: #000000;"> newTransaction,
    </span><span style="color: #0000ff;">boolean</span> newSynchronization, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> debug, @Nullable Object suspendedResources) {

    </span><span style="color: #0000ff;">boolean</span> actualNewSynchronization = newSynchronization &amp;&amp;
        !<span style="color: #000000;">TransactionSynchronizationManager.isSynchronizationActive();
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> DefaultTransactionStatus(
        transaction, newTransaction, actualNewSynchronization,
        definition.isReadOnly(), debug, suspendedResources);
}</span></code></pre>

<p>&nbsp;</p>
<p>实际上就是封装了事务属性definition，新创建的<strong>transaction，</strong>并且将事务状态属性设置为新事务，最后一个参数为被挂起的事务。</p>
<p>简单了解一下关键参数即可：</p>
<p>第二个参数transaction：事务对象，在一开头就有创建，其就是事务管理器的一个内部类。<br />第三个参数newTransaction：布尔值，一个标识，用于判断是否是新的事务，用于提交或者回滚方法中，是新的才会提交或者回滚。<br />最后一个参数suspendedResources：被挂起的对象资源，挂起操作会返回旧的holder，将其与一些事务属性一起封装成一个对象，就是这个suspendedResources这个对象了，它会放在status中，在最后的清理工作方法中判断status中是否有这个挂起对象，如果有会恢复它</p>
<p>接着我们来看看关键代码&nbsp;<strong>doBegin(transaction, definition);</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #000000;">@Override
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> doBegin(Object transaction, TransactionDefinition definition) {
</span><span style="color: #008080;"> 3</span>     DataSourceTransactionObject txObject =<span style="color: #000000;"> (DataSourceTransactionObject) transaction;
</span><span style="color: #008080;"> 4</span>     Connection con = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;"> 7</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 判断如果transaction没有holder的话，才去从dataSource中获取一个新连接</span>
<span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">if</span> (<strong>!txObject.hasConnectionHolder</strong>() ||
<span style="color: #008080;"> 9</span> <span style="color: #000000;">                txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
</span><span style="color: #008080;">10</span>             <span style="color: #008000;">//</span><span style="color: #008000;">通过dataSource获取连接</span>
<span style="color: #008080;">11</span>             <strong>Connection newCon = <span style="color: #0000ff;">this</span><span style="color: #000000;">.dataSource.getConnection();
</span></strong><span style="color: #008080;">12</span>             <span style="color: #0000ff;">if</span><span style="color: #000000;"> (logger.isDebugEnabled()) {
</span><span style="color: #008080;">13</span>                 logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction"<span style="color: #000000;">);
</span><span style="color: #008080;">14</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">15</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> 所以，只有transaction中的holder为空时，才会设置为新holder
</span><span style="color: #008080;">16</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> 将获取的连接封装进ConnectionHolder，然后封装进transaction的connectionHolder属性</span>
<span style="color: #008080;">17</span>             <strong>txObject.setConnectionHolder(<span style="color: #0000ff;">new</span> ConnectionHolder(newCon), <span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span></strong><span style="color: #008080;">18</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">19</span> 　　　　　<span style="color: #008000;">//</span><span style="color: #008000;">设置新的连接为事务同步中</span>
<span style="color: #008080;">20</span>         txObject.getConnectionHolder().setSynchronizedWithTransaction(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #008080;">21</span>         con =<span style="color: #000000;"> txObject.getConnectionHolder().getConnection();
</span><span style="color: #008080;">22</span> 　　　　 <span style="color: #008000;"><strong>//</strong></span><strong><span style="color: #008000;">conn设置事务隔离级别,只读</span></strong>
<span style="color: #008080;">23</span>         Integer previousIsolationLevel =<span style="color: #000000;"> DataSourceUtils.<strong>prepareConnectionForTransaction</strong>(con, definition);
</span><span style="color: #008080;">24</span>         txObject.setPreviousIsolationLevel(previousIsolationLevel);<span style="color: #008000;">//</span><span style="color: #008000;">DataSourceTransactionObject设置事务隔离级别
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span>         <span style="color: #008000;">//</span><strong><span style="color: #008000;"> 如果是自动提交切换到手动提交</span></strong>
<span style="color: #008080;">27</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (con.getAutoCommit()) {
</span><span style="color: #008080;">28</span>             txObject.setMustRestoreAutoCommit(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #008080;">29</span>             <span style="color: #0000ff;">if</span><span style="color: #000000;"> (logger.isDebugEnabled()) {
</span><span style="color: #008080;">30</span>                 logger.debug("Switching JDBC Connection [" + con + "] to manual commit"<span style="color: #000000;">);
</span><span style="color: #008080;">31</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">32</span>             <strong>con.setAutoCommit(<span style="color: #0000ff;">false</span><span style="color: #000000;">);
</span></strong><span style="color: #008080;">33</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">34</span> 　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 如果只读，执行sql设置事务只读</span>
<span style="color: #008080;">35</span> <span style="color: #000000;">        prepareTransactionalConnection(con, definition);
</span><span style="color: #008080;">36</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 设置connection持有者的事务开启状态</span>
<span style="color: #008080;">37</span>         txObject.getConnectionHolder().setTransactionActive(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #008080;">38</span> 
<span style="color: #008080;">39</span>         <span style="color: #0000ff;">int</span> timeout =<span style="color: #000000;"> determineTimeout(definition);
</span><span style="color: #008080;">40</span>         <span style="color: #0000ff;">if</span> (timeout !=<span style="color: #000000;"> TransactionDefinition.TIMEOUT_DEFAULT) {
</span><span style="color: #008080;">41</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> 设置超时秒数</span>
<span style="color: #008080;">42</span> <span style="color: #000000;">            txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
</span><span style="color: #008080;">43</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">44</span> 
<span style="color: #008080;">45</span>         <span style="color: #008000;">//</span><strong><span style="color: #008000;"> 将当前获取到的连接绑定到当前线程</span></strong>
<span style="color: #008080;">46</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (txObject.isNewConnectionHolder()) {
</span><span style="color: #008080;">47</span> <span style="color: #000000;"><strong>            TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());
</strong></span><span style="color: #008080;">48</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">49</span>     }<span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable ex) {
</span><span style="color: #008080;">50</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (txObject.isNewConnectionHolder()) {
</span><span style="color: #008080;">51</span>             DataSourceUtils.releaseConnection(con, <span style="color: #0000ff;">this</span><span style="color: #000000;">.dataSource);
</span><span style="color: #008080;">52</span>             txObject.setConnectionHolder(<span style="color: #0000ff;">null</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
</span><span style="color: #008080;">53</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">54</span>         <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> CannotCreateTransactionException("Could not open JDBC Connection for transaction"<span style="color: #000000;">, ex);
</span><span style="color: #008080;">55</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">56</span> }</code></pre>

<p>&nbsp;</p>
<h4><strong>conn设置事务隔离级别,只读</strong></h4>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Nullable
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Integer prepareConnectionForTransaction(Connection con, @Nullable TransactionDefinition definition)
        </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {

    Assert.notNull(con, </span>"No Connection specified"<span style="color: #000000;">);

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Set read-only flag.
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 设置数据连接的只读标识</span>
    <span style="color: #0000ff;">if</span> (definition != <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> definition.isReadOnly()) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (logger.isDebugEnabled()) {
                logger.debug(</span>"Setting JDBC Connection [" + con + "] read-only"<span style="color: #000000;">);
            }
          <strong>  con.setReadOnly(</strong></span><strong><span style="color: #0000ff;">true</span></strong><span style="color: #000000;"><strong>);</strong>
        }
        </span><span style="color: #0000ff;">catch</span> (SQLException |<span style="color: #000000;"> RuntimeException ex) {
            Throwable exToCheck </span>=<span style="color: #000000;"> ex;
            </span><span style="color: #0000ff;">while</span> (exToCheck != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (exToCheck.getClass().getSimpleName().contains("Timeout"<span style="color: #000000;">)) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Assume it's a connection timeout that would otherwise get lost: e.g. from JDBC 4.0</span>
                    <span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex;
                }
                exToCheck </span>=<span style="color: #000000;"> exToCheck.getCause();
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> "read-only not supported" SQLException -&gt; ignore, it's just a hint anyway</span>
            logger.debug("Could not set JDBC Connection read-only"<span style="color: #000000;">, ex);
        }
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Apply specific isolation level, if any.
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 设置数据库连接的隔离级别</span>
    Integer previousIsolationLevel = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (definition != <span style="color: #0000ff;">null</span> &amp;&amp; definition.getIsolationLevel() !=<span style="color: #000000;"> TransactionDefinition.ISOLATION_DEFAULT) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (logger.isDebugEnabled()) {
            logger.debug(</span>"Changing isolation level of JDBC Connection [" + con + "] to " +<span style="color: #000000;">
                    definition.getIsolationLevel());
        }
        </span><span style="color: #0000ff;">int</span> currentIsolation =<span style="color: #000000;"> con.getTransactionIsolation();
        </span><span style="color: #0000ff;">if</span> (currentIsolation !=<span style="color: #000000;"> definition.getIsolationLevel()) {
            previousIsolationLevel </span>=<span style="color: #000000;"> currentIsolation;
           <strong> con.setTransactionIsolation(definition.getIsolationLevel());</strong>
        }
    }

    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> previousIsolationLevel;
}</span></code></pre>

<p>&nbsp;</p>
<p>我们看到都是通过&nbsp;Connection 去设置</p>
<h4>线程变量的绑定</h4>
<p>我们看&nbsp;doBegin 方法的47行，<strong>将当前获取到的连接绑定到当前线程，</strong>绑定与解绑围绕一个线程变量，此变量在<strong><code>TransactionSynchronizationManager</code></strong>类中：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <strong><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span></strong> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =  <span style="color: #0000ff;">new</span> NamedThreadLocal&lt;&gt;("Transactional resources");</code></pre>

<p>&nbsp;</p>
<p>这是一个&nbsp;<strong>static final </strong>修饰的 线程变量，存储的是一个Map，我们来看看47行的静态方法，<strong>bindResource</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <strong><span style="color: #0000ff;">static</span> </strong><span style="color: #0000ff;">void</span> bindResource(Object key, Object value) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IllegalStateException {
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 从上面可知，线程变量是一个Map，而这个Key就是dataSource
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这个value就是holder</span></strong>
    Object actualKey =<span style="color: #000000;"> TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
    Assert.notNull(value, </span>"Value must not be null"<span style="color: #000000;">);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取这个线程变量Map</span>
    <strong>Map&lt;Object, Object&gt; map =<span style="color: #000000;"> resources.get();
    </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> set ThreadLocal Map if none found</span>
    <span style="color: #0000ff;">if</span> (map == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        map </span>= <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();
        resources.set(map);
    }
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 将新的holder作为value，dataSource作为key放入当前线程Map中</span>
    Object oldValue =<span style="color: #000000;"> map.put(actualKey, value);
    </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> Transparently suppress a ResourceHolder that was marked as void...</span>
    <span style="color: #0000ff;">if</span> (oldValue <span style="color: #0000ff;">instanceof</span> ResourceHolder &amp;&amp;<span style="color: #000000;"> ((ResourceHolder) oldValue).isVoid()) {
        oldValue </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">if</span> (oldValue != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalStateException("Already value [" + oldValue + "] for key [" +<span style="color: #000000;">
                actualKey </span>+ "] bound to thread [" + Thread.currentThread().getName() + "]"<span style="color: #000000;">);
    }    Thread.currentThread().getName() </span>+ "]"<span style="color: #000000;">);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 略...</span>
}</code></pre>

<p>&nbsp;</p>
<h3>扩充知识点</h3>
<p>这里再扩充一点，mybatis中获取的数据库连接，就是根据&nbsp;<strong>dataSource </strong>从ThreadLocal中获取的</p>
<p>以查询举例，会调用Executor#doQuery方法：</p>
<p><img src="./images/spring5 源码深度解析----- 事务增强器（100%理解事务）0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;最终会调用DataSourceUtils#doGetConnection获取，真正的数据库连接，其中TransactionSynchronizationManager中保存的就是方法调用前，spring增强方法中绑定到线程的connection，从而保证整个事务过程中connection的一致性</p>
<p><img src="./images/spring5 源码深度解析----- 事务增强器（100%理解事务）1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/spring5 源码深度解析----- 事务增强器（100%理解事务）2.png" alt="" /></p>
<p>&nbsp;</p>
<p>我们看看<strong><code>TransactionSynchronizationManager.getResource(Object key)这个方法</code></strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Nullable
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Object getResource(Object key) {
    Object actualKey </span>=<span style="color: #000000;"> TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
    Object value </span>=<span style="color: #000000;"><strong> doGetResource</strong>(actualKey);
    </span><span style="color: #0000ff;">if</span> (value != <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> logger.isTraceEnabled()) {
        logger.trace(</span>"Retrieved value [" + value + "] for key [" + actualKey + "] bound to thread [" +<span style="color: #000000;">
                Thread.currentThread().getName() </span>+ "]"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> value;
}

    @Nullable
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Object doGetResource(Object actualKey) {
   <strong> Map</strong></span><strong>&lt;Object, Object&gt; map =<span style="color: #000000;"> resources.get();
    </span></strong><span style="color: #0000ff;">if</span> (map == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
   <strong> Object value </strong></span><strong>=<span style="color: #000000;"> map.get(actualKey);
    </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> Transparently remove ResourceHolder that was marked as void...</span>
    <span style="color: #0000ff;">if</span> (value <span style="color: #0000ff;">instanceof</span> ResourceHolder &amp;&amp;<span style="color: #000000;"> ((ResourceHolder) value).isVoid()) {
        map.remove(actualKey);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Remove entire ThreadLocal if empty...</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (map.isEmpty()) {
            resources.remove();
        }
        value </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> value;
}</span></code></pre>

<p><strong>就是从线程变量的Map中根据&nbsp;</strong><strong>DataSource获取&nbsp;</strong><strong>ConnectionHolder</strong></p>
<h2>已经存在的事务</h2>
<p>前面已经提到，第一次事务开始时必会新创一个holder然后做绑定操作，此时线程变量是有holder的且avtive为true，如果第二个事务进来，去new一个transaction之后去线程变量中取holder，holder是不为空的且active是为true的，所以会进入handleExistingTransaction方法：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">private</span><span style="color: #000000;"> TransactionStatus handleExistingTransaction(
</span><span style="color: #008080;"> 2</span>         TransactionDefinition definition, Object transaction, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> debugEnabled)
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">throws</span><span style="color: #000000;"> TransactionException {
</span><span style="color: #008080;"> 4</span> 　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 1.NERVER（不支持当前事务;如果当前事务存在，抛出异常）报错</span>
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">if</span> (definition.getPropagationBehavior() ==<span style="color: #000000;"> TransactionDefinition.<strong>PROPAGATION_NEVER</strong>) {
</span><span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IllegalTransactionStateException(
</span><span style="color: #008080;"> 7</span>                 "Existing transaction found for transaction marked with propagation 'never'"<span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 9</span> 　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 2.<strong>NOT_SUPPORTED（不支持当前事务，现有同步将被挂起）挂起当前事务,返回一个空事务</strong></span>
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">if</span> (definition.getPropagationBehavior() ==<span style="color: #000000;"> TransactionDefinition.<strong>PROPAGATION_NOT_SUPPORTED</strong>) {
</span><span style="color: #008080;">11</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (debugEnabled) {
</span><span style="color: #008080;">12</span>             logger.debug("Suspending current transaction"<span style="color: #000000;">);
</span><span style="color: #008080;">13</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">14</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 这里会将原来的事务挂起,并返回被挂起的对象</span>
<span style="color: #008080;">15</span>         Object suspendedResources =<span style="color: #000000;"><strong> suspend</strong>(transaction);
</span><span style="color: #008080;">16</span>         <span style="color: #0000ff;">boolean</span> newSynchronization = (getTransactionSynchronization() ==<span style="color: #000000;"> SYNCHRONIZATION_ALWAYS);
</span><span style="color: #008080;">17</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 这里可以看到，第二个参数transaction传了一个空事务，第三个参数false为旧标记
</span><span style="color: #008080;">18</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 最后一个参数就是将前面挂起的对象封装进新的Status中，当前事务执行完后，就恢复suspendedResources</span>
<span style="color: #008080;">19</span>         <span style="color: #0000ff;">return</span> prepareTransactionStatus(definition, <strong><span style="color: #0000ff;">null</span></strong>, <strong><span style="color: #0000ff;">false</span></strong><span style="color: #000000;">, newSynchronization, debugEnabled, suspendedResources);
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">21</span> 　　 <span style="color: #008000;">//</span><span style="color: #008000;"> 3.REQUIRES_NEW挂起当前事务，创建新事务</span>
<span style="color: #008080;">22</span>     <span style="color: #0000ff;">if</span> (definition.getPropagationBehavior() ==<span style="color: #000000;"> TransactionDefinition.<strong>PROPAGATION_REQUIRES_NEW</strong>) {
</span><span style="color: #008080;">23</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (debugEnabled) {
</span><span style="color: #008080;">24</span>             logger.debug("Suspending current transaction, creating new transaction with name [" +
<span style="color: #008080;">25</span>                     definition.getName() + "]"<span style="color: #000000;">);
</span><span style="color: #008080;">26</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">27</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 将原事务挂起，此时新建事务，不与原事务有关系
</span><span style="color: #008080;">28</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 会将transaction中的holder设置为null，然后解绑！</span>
<span style="color: #008080;">29</span>         SuspendedResourcesHolder suspendedResources =<span style="color: #000000;"><strong> suspend</strong>(transaction);
</span><span style="color: #008080;">30</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;">31</span>             <span style="color: #0000ff;">boolean</span> newSynchronization = (getTransactionSynchronization() !=<span style="color: #000000;"> SYNCHRONIZATION_NEVER);
</span><span style="color: #008080;">32</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> new一个status出来，传入transaction，并且为新事务标记，然后传入挂起事务</span>
<span style="color: #008080;">33</span>             DefaultTransactionStatus status = newTransactionStatus(definition, transaction, <span style="color: #0000ff;">true</span><span style="color: #000000;">, newSynchronization, debugEnabled, suspendedResources);
</span><span style="color: #008080;">34</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> 这里也做了一次doBegin，此时的transaction中holer是为空的，因为之前的事务被挂起了
</span><span style="color: #008080;">35</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> 所以这里会取一次新的连接，并且绑定！</span>
<span style="color: #008080;">36</span> <span style="color: #000000;"><strong>            doBegin</strong>(transaction, definition);
</span><span style="color: #008080;">37</span> <span style="color: #000000;">            prepareSynchronization(status, definition);
</span><span style="color: #008080;">38</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> status;
</span><span style="color: #008080;">39</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">40</span>         <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (RuntimeException beginEx) {
</span><span style="color: #008080;">41</span> <span style="color: #000000;">            resumeAfterBeginException(transaction, suspendedResources, beginEx);
</span><span style="color: #008080;">42</span>             <span style="color: #0000ff;">throw</span><span style="color: #000000;"> beginEx;
</span><span style="color: #008080;">43</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">44</span>         <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Error beginErr) {
</span><span style="color: #008080;">45</span> <span style="color: #000000;">            resumeAfterBeginException(transaction, suspendedResources, beginErr);
</span><span style="color: #008080;">46</span>             <span style="color: #0000ff;">throw</span><span style="color: #000000;"> beginErr;
</span><span style="color: #008080;">47</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">48</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">49</span> 　　<span style="color: #008000;">//</span><strong><span style="color: #008000;"> 如果此时的传播特性是NESTED，不会挂起事务</span></strong>
<span style="color: #008080;">50</span>     <span style="color: #0000ff;">if</span> (definition.getPropagationBehavior() ==<span style="color: #000000;"> TransactionDefinition.<strong>PROPAGATION_NESTED</strong>) {
</span><span style="color: #008080;">51</span>         <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">isNestedTransactionAllowed()) {
</span><span style="color: #008080;">52</span>             <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> NestedTransactionNotSupportedException(
</span><span style="color: #008080;">53</span>                     "Transaction manager does not allow nested transactions by default - " +
<span style="color: #008080;">54</span>                     "specify 'nestedTransactionAllowed' property with value 'true'"<span style="color: #000000;">);
</span><span style="color: #008080;">55</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">56</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (debugEnabled) {
</span><span style="color: #008080;">57</span>             logger.debug("Creating nested transaction with name [" + definition.getName() + "]"<span style="color: #000000;">);
</span><span style="color: #008080;">58</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">59</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 这里如果是JTA事务管理器，就不可以用savePoint了，将不会进入此方法</span>
<span style="color: #008080;">60</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (useSavepointForNestedTransaction()) { 
</span><span style="color: #008080;">61</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> 这里不会挂起事务，说明NESTED的特性是原事务的子事务而已
</span><span style="color: #008080;">62</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> new一个status，传入transaction，传入旧事务标记，传入挂起对象=null</span>
<span style="color: #008080;">63</span>             DefaultTransactionStatus status =prepareTransactionStatus(definition, transaction, <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">false</span>, debugEnabled, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
</span><span style="color: #008080;">64</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> 这里是NESTED特性特殊的地方，在先前存在事务的情况下会建立一个savePoint</span>
<span style="color: #008080;">65</span> <strong><span style="color: #000000;">            status.createAndHoldSavepoint();
</span></strong><span style="color: #008080;">66</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> status;
</span><span style="color: #008080;">67</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">68</span>         <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">69</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> JTA事务走这个分支，创建新事务</span>
<span style="color: #008080;">70</span>             <span style="color: #0000ff;">boolean</span> newSynchronization = (getTransactionSynchronization() !=<span style="color: #000000;"> SYNCHRONIZATION_NEVER);
</span><span style="color: #008080;">71</span>             DefaultTransactionStatus status =<span style="color: #000000;"> newTransactionStatus(
</span><span style="color: #008080;">72</span>                     definition, transaction, <span style="color: #0000ff;">true</span>, newSynchronization, debugEnabled, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
</span><span style="color: #008080;">73</span> <span style="color: #000000;">            doBegin(transaction, definition);
</span><span style="color: #008080;">74</span> <span style="color: #000000;">            prepareSynchronization(status, definition);
</span><span style="color: #008080;">75</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> status;
</span><span style="color: #008080;">76</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">77</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">78</span> 
<span style="color: #008080;">79</span>     <span style="color: #008000;">//</span><strong><span style="color: #008000;"> 到这里PROPAGATION_SUPPORTS 或 PROPAGATION_REQUIRED或PROPAGATION_MANDATORY，存在事务加入事务即可，标记为旧事务，空挂起</span></strong>
<span style="color: #008080;">80</span>     <span style="color: #0000ff;">boolean</span> newSynchronization = (getTransactionSynchronization() !=<span style="color: #000000;"> SYNCHRONIZATION_NEVER);
</span><span style="color: #008080;">81</span>     <span style="color: #0000ff;">return</span> prepareTransactionStatus(definition, transaction, <span style="color: #0000ff;">false</span>, newSynchronization, debugEnabled, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
</span><span style="color: #008080;">82</span> }</code></pre>

<p>&nbsp;</p>
<p>对于已经存在事务的处理过程中，我们看到了很多熟悉的操作，但是，也有些不同的地方，函数中对已经存在的事务处理考虑两种情况。</p>
<p>（1）PROPAGATION_REQUIRES_NEW表示当前方法必须在它自己的事务里运行，一个新的事务将被启动，而如果有一个事务正在运行的话，则在这个方法运行期间被挂起。而Spring中对于此种传播方式的处理与新事务建立最大的不同点在于使用suspend方法将原事务挂起。 将信息挂起的目的当然是为了在当前事务执行完毕后在将原事务还原。</p>
<p>（2）PROPAGATION_NESTED表示如果当前正有一个事务在运行中，则该方法应该运行在一个嵌套的事务中，被嵌套的事务可以独立于封装事务进行提交或者回滚，如果封装事务不存在，行为就像PROPAGATION_REQUIRES_NEW。对于嵌入式事务的处理，Spring中主要考虑了两种方式的处理。</p>
<ul>
<li>Spring中允许嵌入事务的时候，则首选设置保存点的方式作为异常处理的回滚。</li>
<li>对于其他方式，比如JTA无法使用保存点的方式，那么处理方式与PROPAGATION_ REQUIRES_NEW相同，而一旦出现异常，则由Spring的事务异常处理机制去完成后续操作。</li>
</ul>
<p>对于挂起操作的主要目的是记录原有事务的状态，以便于后续操作对事务的恢复</p>
<h3>小结</h3>
<p>到这里我们可以知道，在当前存在事务的情况下，根据传播特性去决定是否为新事务，是否挂起当前事务。</p>
<p><strong>NOT_SUPPORTED&nbsp;：会挂起事务，不运行doBegin方法传空<code>transaction</code>，标记为旧事务。封装<code>status</code>对象：</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">return</span> prepareTransactionStatus(definition, <span style="color: #0000ff;">null</span>, <span style="color: #0000ff;">false</span>, newSynchronization, debugEnabled, suspendedResources)</code></pre>

<p>&nbsp;</p>
<p><strong>REQUIRES_NEW&nbsp;：将会挂起事务且运行doBegin方法，标记为新事务。封装<code>status</code>对象：</strong></p>
<src class="cnblogs_code">
<pre><code>DefaultTransactionStatus status = newTransactionStatus(definition, transaction, <span style="color: #0000ff;">true</span>, newSynchronization, debugEnabled, suspendedResources);</code></pre>

<p><strong>NESTED&nbsp;：不会挂起事务且不会运行doBegin方法，标记为旧事务，但会创建<code>savePoint</code>。封装<code>status</code>对象：</strong></p>
<src class="cnblogs_code">
<pre><code>DefaultTransactionStatus status =prepareTransactionStatus(definition, transaction, <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">false</span>, debugEnabled, <span style="color: #0000ff;">null</span>);</code></pre>

<p><strong>其他事务例如REQUIRED&nbsp;：不会挂起事务，封装原有的transaction不会运行doBegin方法，标记旧事务，封装<code>status</code>对象：</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">return</span> prepareTransactionStatus(definition, transaction, <span style="color: #0000ff;">false</span>, newSynchronization, debugEnabled, <span style="color: #0000ff;">null</span>);</code></pre>

<p>&nbsp;</p>
<h3>挂起</h3>
<p>对于挂起操作的主要目的是记录原有事务的状态，以便于后续操作对事务的恢复：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Nullable
</span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">final</span> SuspendedResourcesHolder suspend(@Nullable Object transaction) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> TransactionException {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (TransactionSynchronizationManager.isSynchronizationActive()) {
        List</span>&lt;TransactionSynchronization&gt; suspendedSynchronizations =<span style="color: #000000;"> doSuspendSynchronization();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Object suspendedResources </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (transaction != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这里是真正做挂起的方法，<strong>这里返回的是一个holder</strong></span>
               <strong> suspendedResources =</strong><span style="color: #000000;"><strong> doSuspend(transaction);</strong>
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这里将名称、隔离级别等信息从线程变量中取出并设置对应属性为null到线程变量</span>
            String name =<span style="color: #000000;"> TransactionSynchronizationManager.getCurrentTransactionName();
            TransactionSynchronizationManager.setCurrentTransactionName(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">boolean</span> readOnly =<span style="color: #000000;"> TransactionSynchronizationManager.isCurrentTransactionReadOnly();
            TransactionSynchronizationManager.setCurrentTransactionReadOnly(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
            Integer isolationLevel </span>=<span style="color: #000000;"> TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">boolean</span> wasActive =<span style="color: #000000;"> TransactionSynchronizationManager.isActualTransactionActive();
            TransactionSynchronizationManager.setActualTransactionActive(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
            </span><span style="color: #008000;">//</span><strong><span style="color: #008000;"> 将事务各个属性与挂起的holder一并封装进SuspendedResourcesHolder对象中</span></strong>
            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> SuspendedResourcesHolder(
                <strong>suspendedResources</strong>, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
        }
        </span><span style="color: #0000ff;">catch</span> (RuntimeException |<span style="color: #000000;"> Error ex) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> doSuspend failed - original transaction is still active...</span>
<span style="color: #000000;">            doResumeSynchronization(suspendedSynchronizations);
            </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex;
        }
    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (transaction != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Transaction active but no synchronization active.</span>
        Object suspendedResources =<span style="color: #000000;"> doSuspend(transaction);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> SuspendedResourcesHolder(suspendedResources);
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Neither transaction nor synchronization active.</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
}</span></code></pre>

<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Override
</span><span style="color: #0000ff;">protected</span><span style="color: #000000;"> Object doSuspend(Object transaction) {
    DataSourceTransactionObject txObject </span>=<span style="color: #000000;"> (DataSourceTransactionObject) transaction;
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 将transaction中的holder属性设置为空</span>
    txObject.setConnectionHolder(<span style="color: #0000ff;">null</span><span style="color: #000000;">);
    </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> ConnnectionHolder从线程变量中解绑！</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> TransactionSynchronizationManager.<strong>unbindResource</strong>(obtainDataSource());
}</span></code></pre>

<p>&nbsp;</p>
<p>我们来看看&nbsp;<strong>unbindResource</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Object doUnbindResource(Object actualKey) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 取得当前线程的线程变量Map</span>
    Map&lt;Object, Object&gt; map =<span style="color: #000000;"> resources.get();
    </span><span style="color: #0000ff;">if</span> (map == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 将key为dataSourece的value移除出Map，然后将旧的Holder返回</span>
    Object value =<span style="color: #000000;"> map.remove(actualKey);
    </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> Remove entire ThreadLocal if empty...
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果此时map为空，直接清除线程变量</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (map.isEmpty()) {
        resources.remove();
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Transparently suppress a ResourceHolder that was marked as void...</span>
    <span style="color: #0000ff;">if</span> (value <span style="color: #0000ff;">instanceof</span> ResourceHolder &amp;&amp;<span style="color: #000000;"> ((ResourceHolder) value).isVoid()) {
        value </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">if</span> (value != <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> logger.isTraceEnabled()) {
        logger.trace(</span>"Removed value [" + value + "] for key [" + actualKey + "] from thread [" +<span style="color: #000000;">
                     Thread.currentThread().getName() </span>+ "]"<span style="color: #000000;">);
    }
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 将旧Holder返回</span>
    <span style="color: #0000ff;">return</span></strong><span style="color: #000000;"><strong> value;</strong>
}</span></code></pre>

<p>&nbsp;</p>
<p>可以回头看一下解绑操作的介绍。这里挂起主要干了三件事：</p>
<ol>
<li><strong>将transaction中的holder属性设置为空</strong></li>
<li><strong>解绑（会返回线程中的那个旧的holder出来，从而封装到SuspendedResourcesHolder对象中）</strong></li>
<li><strong>将SuspendedResourcesHolder放入status中，方便后期子事务完成后，恢复外层事务</strong></li>
</ol>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>