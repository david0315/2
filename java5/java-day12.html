<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java-day12' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java-day12</center></div><div class='banquan'>原文出处:本文由博客园博主雅也提供。<br/>
原文连接:https://www.cnblogs.com/324fch/p/11733974.html</div><br>
    <p>数据结构</p>
<p>　　常用的数据存储结构：栈，队列，数组，列表，红黑树。</p>
<p>　　栈：先进后出（入口和出口在用一侧）</p>
<p>　　队列：先进先出</p>
<p>　　数组：</p>
<p>　　　　查询快：因为数组的地址是连续的，通过数组的首地址找到数组中的元素。</p>
<p>　　　　增/删慢：因为数组的长度是固定的，增/删一个元素，需要创建一个新的数组</p>
<p>　　链表：</p>
<p>　　　　查询慢：链表中的地址不是连续的，每次查询都必须从头开始。</p>
<p>　　　　增/删快：链表结构增删一个元素对链表的整体结构没有影响。</p>
<p>　　　　链表的每一个元素也称为一个节点，每个节点包含一个数据源，两个指针域&nbsp; |自己的地址|数据|下一个节点的地址|</p>
<p>　　　　单向链表：只有一条链子，不能保证元素的顺序</p>
<p>　　　　双向链表：有两条链子，有一条链子专门用来记录元素的顺序，是一个有序集合</p>
<p>　　红黑树：</p>
<p>　　　　二叉树：分支不能超过两个</p>
<p>　　　　排序树/查找树：在二叉树的基础上，元素有大小顺序，左子树小，右子树大</p>
<p>　　　　平衡树：左子树数量等于右子树数量</p>
<p>　　　　不平衡树：左子树数量与右子树数量不一样</p>
<p>　　　　红黑树：趋近与平衡树，查询速度快</p>
<p>　　　　　　约束：1.节点可以是红色或是黑色 2.根节点是黑色的 3.叶子节点是黑色的 4.每个红色节点的子节点都是黑色的 5.任何一个节点到齐每个叶子节点的所有路径上黑色系欸但数相同</p>
<p>List集合</p>
<p>　　Collectgion子类，有序，可重复，有索引</p>
<p>List接口中带索引的方法</p>
<p>　　创建List对象</p>
<p>　　List&lt;String&gt; list = new ArrayList&lt;&gt;()</p>
<p>　　add(index,element)　　添加元素</p>
<p>　　remove(index)　　删除元素，有返回值</p>
<p>　　set(index,element)　　用指定元素替换指定位置的元素，返回替换元素</p>
<p>　　get(index)　　获取指定位置元素</p>
<p>List的实现类</p>
<p>　　ArrayList集合(底层是一个数组)</p>
<p>　　　　查询快，增删慢</p>
<p>　　LinkedList集合(底层是一个链表)</p>
<p>　　　　查询慢，增删快</p>
<p>　　　　有大量操作首尾的方法：addFirst(),addLast().removeFirst(),removeLast(),getFirst(),getLast().</p>
<p>　　LinkedList集合有特用方法，所以不能用多态创建</p>
<p>　　LinkedList&lt;E&gt; linked =new LinkedList&lt;&gt;()</p>
<p>　　Vector集合（底层是一个数组）</p>
<p>Set集合</p>
<p>　　HashSet实现类 （底层是一个哈希表结构）查询快</p>
<p>　　　　无须，不可重复，无索引</p>
<p>　　　　创建　　Set&lt;E&gt; set = new HashSet&lt;&gt;();　使用迭代器或增强for循环遍历</p>
<p>　　哈希值：一个十进制的整数，由系统随机给出（就是对象的地址是一个逻辑地址，是模拟出来的，不是数据存储的实际物理地址）</p>
<p>　　在Object类中有一个方法可以获取对象的哈希值 int hashCode() 返回对象的哈希码值</p>
<p>　　哈希表结构：数组+链表/红黑树（提高查询速度，当链表的个数大于8位时，用红黑树）</p>
<p>　　数组结构：把元素进行分组（相同的哈希值元素一组）</p>
<p>　　链表/红黑树结构：把相同哈希值连接到一起</p>
<p>　　Set集合中不允许有重复元素的原理</p>
<p>　　　　Set集合调用add方法时，会调用元素的hashCode方法和equals方法判断元素是否重复（先调用hashCode方法后调用equals方法）</p>
<p>　　HashSet存储自定义类型元素，存储的元素必须重写hashCode方法和equals方法</p>
<p>　　LinkedHashCode集合</p>
<p>　　底层是一个哈希表和链表，多了一条列表记录元素的存储顺序保证元素有序，有序，不可重复</p>
<p>可变参数：底层是一个数组</p>
<p>　　当方法的参数列表数据类型已确定，但是参数的个数不确定就可以使用可变参数</p>
<p>　　使用格式：修饰符 返回值类型 方法名（数据类型...变量名）{}</p>
<p>　　使用：</p>
<p>　　　　定义一个初始化变量，遍历数组</p>
<p>　　注意事项：1.一个方法只能有一个可变参数 2.一个有多个参数列表时，可变参数要放在最后面</p>
<p>　　可变参数的特殊写法：修饰符 返回值类型 方法名（Object...obj）{}</p>
<p>Collections工具类</p>
<p>　　addAll()：一次性添加多个元素</p>
<p>　　shuffle()：打乱集合顺序</p>
<p>　　sort()：默认规则排序(升序)</p>
<p>　　sort(List&lt;T&gt; list,Comparator &lt;? super T&gt;)：<span style="font-family: 微软雅黑;">方法灵活的完成，这个里面就涉及到了</span><span style="font-family: 'Open Sans';">Comparator</span><span style="font-family: 微软雅黑;">这个接口，位于位于</span><span style="font-family: 'Open Sans';">java.util</span><span style="font-family: 微软雅黑;">包下，排序是</span><span style="font-family: 'Open Sans';">comparator</span><span style="font-family: 微软雅黑;">能实现的功能之一</span><span style="font-family: 'Open Sans';">,</span><span style="font-family: 微软雅黑;">该接口代表一个比较器，比</span><span style="font-family: 微软雅黑;">较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</span></p>
<p><span style="font-family: 微软雅黑;">　　</span><span style="font-family: Consolas;">public?int?compare(String?o1,?String?o2）</span></p>
<p>&nbsp;</p>
<src><span style="font-family: 微软雅黑;">　　两个对象比较的结果有三种：大于，等于，小于。</span>
<src><span style="font-family: 微软雅黑;">　　 如果要按照升序排序，则</span><span style="font-family: 'Open Sans';">o1</span><span style="font-family: 微软雅黑;">小于</span><span style="font-family: 'Open Sans';">o2</span><span style="font-family: 微软雅黑;">，返回（负数），相等返回</span><span style="font-family: 'Open Sans';">0</span><span style="font-family: 微软雅黑;">，</span><span style="font-family: 'Open Sans';">01</span><span style="font-family: 微软雅黑;">大于</span><span style="font-family: 'Open Sans';">02</span><span style="font-family: 微软雅黑;">返回（正数）</span>
<src><span style="font-family: 微软雅黑;">　　如果要按照</span><span style="font-family: 微软雅黑;">降序排序则</span><span style="font-family: 'Open Sans';">o1</span><span style="font-family: 微软雅黑;">小于</span><span style="font-family: 'Open Sans';">o2</span><span style="font-family: 微软雅黑;">，返回（正数），相等返回</span><span style="font-family: 'Open Sans';">0</span><span style="font-family: 微软雅黑;">，</span><span style="font-family: 'Open Sans';">01</span><span style="font-family: 微软雅黑;">大于</span><span style="font-family: 'Open Sans';">02</span><span style="font-family: 微软雅黑;">返回（负数）</span>
<src><span style="font-family: 微软雅黑;">Map集合</span>
<src><span style="font-family: 微软雅黑;">　　将键映射到值：1.键唯一2.键和值---映射一个键对应一个值3.靠键维护它们的关系<br /></span>
<src><span style="font-family: 微软雅黑;">　　双列集合：一个key，一个value</span>
<src><span style="font-family: 微软雅黑;">常用方法:</span>
<src><span style="font-family: 微软雅黑;">　　put(k,v)　　添加键和值，key不重复返回null，重复返回被替代的value<br /></span>
<src><span style="font-family: 微软雅黑;">　　get(k)　　获取key对应的value，返回value</span>
<src><span style="font-family: 微软雅黑;">　　remove(k)　　删除key和value，返回value</span>
<src><span style="font-family: 微软雅黑;">　　containsKey()　　判断是否有指定key,有true无false</span>
<src><span style="font-family: 微软雅黑;">　　containsValue()　　判断是否有指定value，有true无false<br /></span>
<src><span style="font-family: 微软雅黑;">遍历Map集合</span>
<src><span style="font-family: 微软雅黑;">　　Set&lt;K&gt;keySet():把Map集合所有键存到Set集合中，再遍历集合中的key通过key找到value</span>
<src><span style="font-family: 微软雅黑;">　　Map.Entry&lt;K.V&gt;:在Map接口中有一个内部接口Entry用来记录键和值。</span>
<src><span style="font-family: 微软雅黑;">　　Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():把Map集合内部的多个Entry对象存储到Set集合中，遍历Set集合，使用Entry对象的方法getKey()和getValue()</span>
<src><span style="font-family: 微软雅黑;">　　HashMap集合：1.基于哈希表（查询速特别快）2.是一个无序的集合<br /></span>
<src><span style="font-family: 微软雅黑;">　　LinkedHashMap集合 extends HashMap集合：底层是哈希表+链表，是一个有序集合，保证迭代的顺序</span>
<src><span style="font-family: 微软雅黑;">HashMap存储自定义类型，作为key元素需要重写hashCode()和equals(),保证key唯一</span>
<src>HashTable&lt;k,v&gt;
<src>　　底层是一个哈希表，单线程
<src>　　不能存储Null值，Null键
<src>&nbsp;
<src>JDK9对集合添加的优化
<src>List接口,Set接口,Map接口里添加了一个静态的方法of
<src>1.of方法只适用于List接口,Set接口,Map接口，不适用于接口的实现类
<src>2.of的返回值是一个已经确定的集合，不能再使用add和put方法添加元素
<src>3.Set接口和Map接口调用of方法时，不能有重复元素

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>