<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Excel解析工具easyexcel全面探索' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Excel解析工具easyexcel全面探索</center></div><div class='banquan'>原文出处:本文由博客园博主老梁讲Java提供。<br/>
原文连接:https://www.cnblogs.com/sky-chen/p/11733687.html</div><br>
    <h1 id="excel解析工具easyexcel全面探索">1. Excel解析工具easyexcel全面探索</h1>
<h2 id="简介">1.1. 简介</h2>
<p>之前我们想到Excel解析一般是使用POI，但POI存在一个严重的问题，就是非常消耗内存。所以阿里人员对它进行了重写从而诞生了<code>easyexcel</code>，它解决了过于消耗内存问题，也对它进行了封装让使用者使用更加便利</p>
<p>接下来我先一一介绍它所有的功能细节、如何使用及部分源码解析</p>
<h2 id="excel读">1.2. Excel读</h2>
<h3 id="例子">1.2.1. 例子</h3>
<pre><code><code>    /**
     * 最简单的读
     * &lt;p&gt;1. 创建excel对应的实体对象 参照{@link DemoData}
     * &lt;p&gt;2. 由于默认异步读取excel，所以需要创建excel一行一行的回调监听器，参照{@link DemoDataListener}
     * &lt;p&gt;3. 直接读即可
     */
    @Test
    public void simpleRead() {
        String fileName = TestFileUtil.getPath() + &quot;demo&quot; + File.separator + &quot;demo.xlsx&quot;;
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead();
    }</code></code></pre>
<ul>
<li>官方说明也比较明确，使用简单<code>fileName</code>是<code>路径+文件名</code>，<code>DemoData</code>是Excel数据对应的实体类，<code>DemoDataListener</code>这看名字就是监听器，用来监听处理读取到的每一条数据</li>
</ul>
<h3 id="源码解析">1.2.2. 源码解析</h3>
<h4 id="核心源码xlsxsaxanalyser">1.2.2.1. 核心源码<code>XlsxSaxAnalyser</code></h4>
<ul>
<li>它核心的Excel解析我认为是这个类<code>XlsxSaxAnalyser</code>，在它的构造方法中做了很多事</li>
</ul>
<pre><code><code>    public XlsxSaxAnalyser(AnalysisContext analysisContext, InputStream decryptedStream) throws Exception {
        ...
        //从这开始将数据读取成inputStream流，缓存到了sheetMap
        XSSFReader xssfReader = new XSSFReader(pkg);
        analysisUse1904WindowDate(xssfReader, readWorkbookHolder);

        stylesTable = xssfReader.getStylesTable();
        sheetList = new ArrayList&lt;ReadSheet&gt;();
        sheetMap = new HashMap&lt;Integer, InputStream&gt;();
        XSSFReader.SheetIterator ite = (XSSFReader.SheetIterator)xssfReader.getSheetsData();
        int index = 0;
        if (!ite.hasNext()) {
            throw new ExcelAnalysisException(&quot;Can not find any sheet!&quot;);
        }
        while (ite.hasNext()) {
            InputStream inputStream = ite.next();
            sheetList.add(new ReadSheet(index, ite.getSheetName()));
            sheetMap.put(index, inputStream);
            index++;
        }
    }</code></code></pre>
<h4 id="doread">1.2.2.2. doRead</h4>
<ul>
<li>例子中真正开始做解析任务的是<code>doRead</code>方法，不断进入此方法，会看到真正执行的最后方法就是<code>XlsxSaxAnalyser</code>类的<code>execute</code>方法；可以看到如下方法中<code>parseXmlSource</code>解析的就是<code>sheetMap</code>缓存的真正数据</li>
</ul>
<pre><code><code>    @Override
    public void execute(List&lt;ReadSheet&gt; readSheetList, Boolean readAll) {
        for (ReadSheet readSheet : sheetList) {
            readSheet = SheetUtils.match(readSheet, readSheetList, readAll,
                analysisContext.readWorkbookHolder().getGlobalConfiguration());
            if (readSheet != null) {
                analysisContext.currentSheet(readSheet);
                parseXmlSource(sheetMap.get(readSheet.getSheetNo()), new XlsxRowHandler(analysisContext, stylesTable));
                // The last sheet is read
                analysisContext.readSheetHolder().notifyAfterAllAnalysed(analysisContext);
            }
        }
    }</code></code></pre>
<h4 id="概述demodatalistener实现">1.2.2.3. 概述<code>DemoDataListener</code>实现</h4>
<ul>
<li>对应我们用户需要手写的代码，我们的监听器<code>DemoDataListener</code>中有两个实现方法如下，<code>invoke</code>就对应了上述代码中的<code>parseXmlSource</code>而<code>doAfterAllAnalysed</code>对应了上述方法中的<code>notifyAfterAllAnalysed</code>，分别表示了先解析每一条数据和当最后一页读取完毕通知所有监听器</li>
</ul>
<pre><code><code>    @Override
    public void invoke(DemoData data, AnalysisContext context) {
        LOGGER.info(&quot;解析到一条数据:{}&quot;, JSON.toJSONString(data));
        list.add(data);
        if (list.size() &gt;= BATCH_COUNT) {
            saveData();
            list.clear();
        }
    }

    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        saveData();
        LOGGER.info(&quot;所有数据解析完成！&quot;);
    }</code></code></pre>
<h4 id="parsexmlsource具体实现">1.2.2.4. <code>parseXmlSource</code>具体实现</h4>
<ul>
<li>看标识重点的地方，这是最核心的解析地</li>
</ul>
<pre><code><code>    private void parseXmlSource(InputStream inputStream, ContentHandler handler) {
        InputSource inputSource = new InputSource(inputStream);
        try {
            SAXParserFactory saxFactory = SAXParserFactory.newInstance();
            saxFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            saxFactory.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            saxFactory.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            SAXParser saxParser = saxFactory.newSAXParser();
            XMLReader xmlReader = saxParser.getXMLReader();
            xmlReader.setContentHandler(handler);
            //重点
            xmlReader.parse(inputSource);
            inputStream.close();
        } catch (ExcelAnalysisException e) {
            throw e;
        } catch (Exception e) {
            throw new ExcelAnalysisException(e);
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    throw new ExcelAnalysisException(&quot;Can not close &#39;inputStream&#39;!&quot;);
                }
            }
        }
    }</code></code></pre>
<ul>
<li>由于这层层深入非常多，我用一张截图来表现它的调用形式</li>
</ul>
<p><img src="./images/Excel解析工具easyexcel全面探索0.png" /></p>
<h4 id="notifyafterallanalysed具体实现">1.2.2.5. <code>notifyAfterAllAnalysed</code>具体实现</h4>
<ul>
<li>具体看<code>notifyAfterAllAnalysed</code>的代码，我们实现的<code>DemoDataListener</code>监听器继承<code>AnalysisEventListener</code>，而<code>AnalysisEventListener</code>实现<code>ReadListener</code>接口</li>
</ul>
<pre><code><code>    @Override
    public void notifyAfterAllAnalysed(AnalysisContext analysisContext) {
        for (ReadListener readListener : readListenerList) {
            readListener.doAfterAllAnalysed(analysisContext);
        }
    }</code></code></pre>
<h2 id="excel写">1.3. Excel写</h2>
<h3 id="例子-1">1.3.1. 例子</h3>
<ul>
<li>如下例子，使用还是简单的，和读比较类似</li>
</ul>
<pre><code><code>    /**
     * 最简单的写
     * &lt;p&gt;1. 创建excel对应的实体对象 参照{@link com.alibaba.easyexcel.test.demo.write.DemoData}
     * &lt;p&gt;2. 直接写即可
     */
    @Test
    public void simpleWrite() {
        String fileName = TestFileUtil.getPath() + &quot;write&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        // 如果这里想使用03 则 传入excelType参数即可
        EasyExcel.write(fileName, DemoData.class).sheet(&quot;模板&quot;).doWrite(data());
    }
    
    private List&lt;DemoData&gt; data() {
        List&lt;DemoData&gt; list = new ArrayList&lt;DemoData&gt;();
        for (int i = 0; i &lt; 10; i++) {
            DemoData data = new DemoData();
            data.setString(&quot;字符串&quot; + i);
            data.setDate(new Date());
            data.setDoubleData(0.56);
            list.add(data);
        }
        return list;
    }</code></code></pre>
<h3 id="源码解析-1">1.3.2. 源码解析</h3>
<h4 id="dowrite">1.3.2.1. <code>doWrite</code></h4>
<ul>
<li>和读一样<code>doWrite</code>才是实际做事的，这次我们从这个入口跟进</li>
</ul>
<pre><code><code>    public void doWrite(List data) {
        if (excelWriter == null) {
            throw new ExcelGenerateException(&quot;Must use &#39;EasyExcelFactory.write().sheet()&#39; to call this method&quot;);
        }
        excelWriter.write(data, build());
        excelWriter.finish();
    }</code></code></pre>
<h4 id="write">1.3.2.2. <code>write</code></h4>
<ul>
<li>很明显，<code>write</code>是核心，继续进入<code>ExcelWriter</code>类，看名字<code>addContent</code>就是添加数据了，由<code>excelBuilder</code>Excel建造者来添加，这是<code>ExcelBuilderImpl</code>类</li>
</ul>
<pre><code><code>    public ExcelWriter write(List data, WriteSheet writeSheet, WriteTable writeTable) {
        excelBuilder.addContent(data, writeSheet, writeTable);
        return this;
    }</code></code></pre>
<h4 id="addcontent">1.3.2.3. <code>addContent</code></h4>
<ul>
<li>可以看到如下，显示封装和实例化一些数据，创建了<code>ExcelWriteAddExecutor</code>写数据执行器，核心就是<code>add</code>方法了</li>
</ul>
<pre><code><code>    @Override
    public void addContent(List data, WriteSheet writeSheet, WriteTable writeTable) {
        try {
            if (data == null) {
                return;
            }
            context.currentSheet(writeSheet, WriteTypeEnum.ADD);
            context.currentTable(writeTable);
            if (excelWriteAddExecutor == null) {
                excelWriteAddExecutor = new ExcelWriteAddExecutor(context);
            }
            //核心
            excelWriteAddExecutor.add(data);
        } catch (RuntimeException e) {
            finish();
            throw e;
        } catch (Throwable e) {
            finish();
            throw new ExcelGenerateException(e);
        }
    }</code></code></pre>
<h4 id="add">1.3.2.4. <code>add</code></h4>
<ul>
<li>可以看到很明显在遍历数据<code>addOneRowOfDataToExcel</code>插入到Excel表了</li>
</ul>
<pre><code><code>    public void add(List data) {
        if (CollectionUtils.isEmpty(data)) {
            return;
        }
        WriteSheetHolder writeSheetHolder = writeContext.writeSheetHolder();
        int newRowIndex = writeSheetHolder.getNewRowIndexAndStartDoWrite();
        if (writeSheetHolder.isNew() &amp;&amp; !writeSheetHolder.getExcelWriteHeadProperty().hasHead()) {
            newRowIndex += writeContext.currentWriteHolder().relativeHeadRowIndex();
        }
        // BeanMap is out of order,so use fieldList
        List&lt;Field&gt; fieldList = new ArrayList&lt;Field&gt;();
        for (int relativeRowIndex = 0; relativeRowIndex &lt; data.size(); relativeRowIndex++) {
            int n = relativeRowIndex + newRowIndex;
            addOneRowOfDataToExcel(data.get(relativeRowIndex), n, relativeRowIndex, fieldList);
        }
    }</code></code></pre>
<h4 id="addonerowofdatatoexcel">1.3.2.5. <code>addOneRowOfDataToExcel</code></h4>
<ul>
<li>这里先是做创建Excel行的准备，包括行的一些属性处理器需不需要处理，之后我们的例子是插入java对象，进入<code>addJavaObjectToExcel</code>方法</li>
</ul>
<pre><code><code>    private void addOneRowOfDataToExcel(Object oneRowData, int n, int relativeRowIndex, List&lt;Field&gt; fieldList) {
        if (oneRowData == null) {
            return;
        }
        WriteHandlerUtils.beforeRowCreate(writeContext, n, relativeRowIndex, Boolean.FALSE);
        Row row = WorkBookUtil.createRow(writeContext.writeSheetHolder().getSheet(), n);
        WriteHandlerUtils.afterRowCreate(writeContext, row, relativeRowIndex, Boolean.FALSE);
        if (oneRowData instanceof List) {
            addBasicTypeToExcel((List)oneRowData, row, relativeRowIndex);
        } else {
            addJavaObjectToExcel(oneRowData, row, relativeRowIndex, fieldList);
        }
        WriteHandlerUtils.afterRowDispose(writeContext, row, relativeRowIndex, Boolean.FALSE);
    }</code></code></pre>
<h4 id="addjavaobjecttoexcel">1.3.2.6. <code>addJavaObjectToExcel</code></h4>
<ul>
<li>在<code>ExcelWriteAddExecutor</code>执行器类中执行<code>addJavaObjectToExcel</code>，在这里进行了数据的解析，将数据解析成标题和内容，封装成适合Excel的格式<code>CellData</code>，数据类型等，经过这步我们还没看到文件流的生成，那么下一步了</li>
</ul>
<pre><code><code>    private void addJavaObjectToExcel(Object oneRowData, Row row, int relativeRowIndex, List&lt;Field&gt; fieldList) {
        WriteHolder currentWriteHolder = writeContext.currentWriteHolder();
        BeanMap beanMap = BeanMap.create(oneRowData);
        Set&lt;String&gt; beanMapHandledSet = new HashSet&lt;String&gt;();
        int cellIndex = 0;
        // If it&#39;s a class it needs to be cast by type
        if (HeadKindEnum.CLASS.equals(writeContext.currentWriteHolder().excelWriteHeadProperty().getHeadKind())) {
            Map&lt;Integer, Head&gt; headMap = writeContext.currentWriteHolder().excelWriteHeadProperty().getHeadMap();
            Map&lt;Integer, ExcelContentProperty&gt; contentPropertyMap =
                writeContext.currentWriteHolder().excelWriteHeadProperty().getContentPropertyMap();
            for (Map.Entry&lt;Integer, ExcelContentProperty&gt; entry : contentPropertyMap.entrySet()) {
                cellIndex = entry.getKey();
                ExcelContentProperty excelContentProperty = entry.getValue();
                String name = excelContentProperty.getField().getName();
                if (writeContext.currentWriteHolder().ignore(name, cellIndex)) {
                    continue;
                }
                if (!beanMap.containsKey(name)) {
                    continue;
                }
                Head head = headMap.get(cellIndex);
                WriteHandlerUtils.beforeCellCreate(writeContext, row, head, cellIndex, relativeRowIndex, Boolean.FALSE);
                Cell cell = WorkBookUtil.createCell(row, cellIndex);
                WriteHandlerUtils.afterCellCreate(writeContext, cell, head, relativeRowIndex, Boolean.FALSE);
                Object value = beanMap.get(name);
                CellData cellData = converterAndSet(currentWriteHolder, excelContentProperty.getField().getType(), cell,
                    value, excelContentProperty);
                WriteHandlerUtils.afterCellDispose(writeContext, cellData, cell, head, relativeRowIndex, Boolean.FALSE);
                beanMapHandledSet.add(name);
            }
        }
        // Finish
        if (beanMapHandledSet.size() == beanMap.size()) {
            return;
        }
        if (cellIndex != 0) {
            cellIndex++;
        }
        Map&lt;String, Field&gt; ignoreMap = writeContext.currentWriteHolder().excelWriteHeadProperty().getIgnoreMap();
        initFieldList(oneRowData.getClass(), fieldList);
        for (Field field : fieldList) {
            String filedName = field.getName();
            boolean uselessData = !beanMap.containsKey(filedName) || beanMapHandledSet.contains(filedName)
                || ignoreMap.containsKey(filedName) || writeContext.currentWriteHolder().ignore(filedName, cellIndex);
            if (uselessData) {
                continue;
            }
            Object value = beanMap.get(filedName);
            if (value == null) {
                continue;
            }
            WriteHandlerUtils.beforeCellCreate(writeContext, row, null, cellIndex, relativeRowIndex, Boolean.FALSE);
            Cell cell = WorkBookUtil.createCell(row, cellIndex++);
            WriteHandlerUtils.afterCellCreate(writeContext, cell, null, relativeRowIndex, Boolean.FALSE);
            CellData cellData = converterAndSet(currentWriteHolder, value.getClass(), cell, value, null);
            WriteHandlerUtils.afterCellDispose(writeContext, cellData, cell, null, relativeRowIndex, Boolean.FALSE);
        }
    }</code></code></pre>
<h4 id="finish">1.3.2.7. <code>finish</code></h4>
<ul>
<li><code>doWrite</code>中之后还有一步<code>finish</code></li>
</ul>
<pre><code><code>    public void finish() {
        excelBuilder.finish();
    }</code></code></pre>
<ul>
<li>深入<code>ExcelBuilderImpl</code>类</li>
</ul>
<pre><code><code>    @Override
    public void finish() {
        if (context != null) {
            context.finish();
        }
    }</code></code></pre>
<ul>
<li>到<code>WriteContextImpl</code>写内容实现类的<code>finish</code>方法中，我们可以看到<code>writeWorkbookHolder.getWorkbook().write(writeWorkbookHolder.getOutputStream());</code> 这句是重点，将写Excel持有容器中的内容流输出；之后就是关闭流，删除临时文件的过程</li>
</ul>
<pre><code><code>    @Override
    public void finish() {
        WriteHandlerUtils.afterWorkbookDispose(this);
        if (writeWorkbookHolder == null) {
            return;
        }
        Throwable throwable = null;

        boolean isOutputStreamEncrypt = false;
        try {
            isOutputStreamEncrypt = doOutputStreamEncrypt07();
        } catch (Throwable t) {
            throwable = t;
        }

        if (!isOutputStreamEncrypt) {
            try {
                // 重点
                writeWorkbookHolder.getWorkbook().write(writeWorkbookHolder.getOutputStream());
                writeWorkbookHolder.getWorkbook().close();
            } catch (Throwable t) {
                throwable = t;
            }
        }

        try {
            Workbook workbook = writeWorkbookHolder.getWorkbook();
            if (workbook instanceof SXSSFWorkbook) {
                ((SXSSFWorkbook)workbook).dispose();
            }
        } catch (Throwable t) {
            throwable = t;
        }

        try {
            if (writeWorkbookHolder.getAutoCloseStream() &amp;&amp; writeWorkbookHolder.getOutputStream() != null) {
                writeWorkbookHolder.getOutputStream().close();
            }
        } catch (Throwable t) {
            throwable = t;
        }

        if (!isOutputStreamEncrypt) {
            try {
                doFileEncrypt07();
            } catch (Throwable t) {
                throwable = t;
            }
        }

        try {
            if (writeWorkbookHolder.getTempTemplateInputStream() != null) {
                writeWorkbookHolder.getTempTemplateInputStream().close();
            }
        } catch (Throwable t) {
            throwable = t;
        }

        clearEncrypt03();

        if (throwable != null) {
            throw new ExcelGenerateException(&quot;Can not close IO&quot;, throwable);
        }

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug(&quot;Finished write.&quot;);
        }
    }</code></code></pre>
<h2 id="文件上传">1.4. 文件上传</h2>
<ul>
<li>它提供了一个接收<code>InputStream</code>的参数，之后和Excel读没多大区别</li>
</ul>
<pre><code><code>    /**
     * 文件上传
     * &lt;p&gt;
     * 1. 创建excel对应的实体对象 参照{@link UploadData}
     * &lt;p&gt;
     * 2. 由于默认异步读取excel，所以需要创建excel一行一行的回调监听器，参照{@link UploadDataListener}
     * &lt;p&gt;
     * 3. 直接读即可
     */
    @PostMapping(&quot;upload&quot;)
    @ResponseBody
    public String upload(MultipartFile file) throws IOException {
        EasyExcel.read(file.getInputStream(), UploadData.class, new UploadDataListener()).sheet().doRead();
        return &quot;success&quot;;
    }</code></code></pre>
<h2 id="文件下载">1.5. 文件下载</h2>
<ul>
<li>写入提供参数<code>OutputStream</code>，其它和文件写入差不多</li>
</ul>
<pre><code><code>    /**
     * 文件下载
     * &lt;p&gt;
     * 1. 创建excel对应的实体对象 参照{@link DownloadData}
     * &lt;p&gt;
     * 2. 设置返回的 参数
     * &lt;p&gt;
     * 3. 直接写，这里注意，finish的时候会自动关闭OutputStream,当然你外面再关闭流问题不大
     */
    @GetMapping(&quot;download&quot;)
    public void download(HttpServletResponse response) throws IOException {
        // 这里注意 有同学反应使用swagger 会导致各种问题，请直接用浏览器或者用postman
        response.setContentType(&quot;application/vnd.ms-excel&quot;);
        response.setCharacterEncoding(&quot;utf-8&quot;);
        // 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系
        String fileName = URLEncoder.encode(&quot;测试&quot;, &quot;UTF-8&quot;);
        response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xlsx&quot;);
        EasyExcel.write(response.getOutputStream(), DownloadData.class).sheet(&quot;模板&quot;).doWrite(data());
    }</code></code></pre>
<h2 id="读取技巧">1.6. 读取技巧</h2>
<h3 id="excel读取多页">1.6.1. Excel读取多页</h3>
<ul>
<li>以上都是最基础的单页读写，在我们调用<code>sheet()</code>方法时，实际上都是默认第1页，那么如何读取多页？</li>
</ul>
<pre><code><code>    /**
     * 读多个或者全部sheet,这里注意一个sheet不能读取多次，多次读取需要重新读取文件
     * &lt;p&gt;
     * 1. 创建excel对应的实体对象 参照{@link DemoData}
     * &lt;p&gt;
     * 2. 由于默认异步读取excel，所以需要创建excel一行一行的回调监听器，参照{@link DemoDataListener}
     * &lt;p&gt;
     * 3. 直接读即可
     */
    @Test
    public void repeatedRead() {
        String fileName = TestFileUtil.getPath() + &quot;demo&quot; + File.separator + &quot;demo.xlsx&quot;;
        // 读取全部sheet
        // 这里需要注意 DemoDataListener的doAfterAllAnalysed 会在每个sheet读取完毕后调用一次。然后所有sheet都会往同一个DemoDataListener里面写
        EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).doReadAll();

        // 读取部分sheet
        fileName = TestFileUtil.getPath() + &quot;demo&quot; + File.separator + &quot;demo.xlsx&quot;;
        ExcelReader excelReader = EasyExcel.read(fileName).build();
        // 这里为了简单 所以注册了 同样的head 和Listener 自己使用功能必须不同的Listener
        ReadSheet readSheet1 =
            EasyExcel.readSheet(0).head(DemoData.class).registerReadListener(new DemoDataListener()).build();
        ReadSheet readSheet2 =
            EasyExcel.readSheet(1).head(DemoData.class).registerReadListener(new DemoDataListener()).build();
        // 这里注意 一定要把sheet1 sheet2 一起传进去，不然有个问题就是03版的excel 会读取多次，浪费性能
        excelReader.read(readSheet1, readSheet2);
        // 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的
        excelReader.finish();
    }</code></code></pre>
<ul>
<li>可以看到<code>doReadAll</code>方法可以读取所有sheet页面</li>
<li>若要读取单独的页面，用第二种方式<code>readSheet(index)</code>，index为页面位置，从0开始计数</li>
</ul>
<h3 id="自定义字段转换">1.6.2. 自定义字段转换</h3>
<ul>
<li>在读取写入的时候，我们可能会有这样的需求：比如日期格式转换，字符串添加固定前缀后缀等等，此时我们可以进行自定义编写</li>
</ul>
<pre><code><code>@Data
public class ConverterData {
    /**
     * 我自定义 转换器，不管数据库传过来什么 。我给他加上“自定义：”
     */
    @ExcelProperty(converter = CustomStringStringConverter.class)
    private String string;
    /**
     * 这里用string 去接日期才能格式化。我想接收年月日格式
     */
    @DateTimeFormat(&quot;yyyy年MM月dd日HH时mm分ss秒&quot;)
    private String date;
    /**
     * 我想接收百分比的数字
     */
    @NumberFormat(&quot;#.##%&quot;)
    private String doubleData;
}</code></code></pre>
<ul>
<li>如上面的<code>CustomStringStringConverter</code>类为自定义转换器，可以对字符串进行一定修改，而日期数字的格式化，它已经有提供注解了<code>DateTimeFormat</code>和<code>NumberFormat</code></li>
<li>转换器如下，实现<code>Converter</code>接口后即可使用<code>supportExcelTypeKey</code>这是判断单元格类型，<code>convertToJavaData</code>这是读取转换，<code>convertToExcelData</code>这是写入转换</li>
</ul>
<pre><code><code>
import com.alibaba.excel.converters.Converter;
import com.alibaba.excel.enums.CellDataTypeEnum;
import com.alibaba.excel.metadata.CellData;
import com.alibaba.excel.metadata.GlobalConfiguration;
import com.alibaba.excel.metadata.property.ExcelContentProperty;

public class CustomStringStringConverter implements Converter&lt;String&gt; {
    @Override
    public Class supportJavaTypeKey() {
        return String.class;
    }

    @Override
    public CellDataTypeEnum supportExcelTypeKey() {
        return CellDataTypeEnum.STRING;
    }

    /**
     * 这里读的时候会调用
     */
    @Override
    public String convertToJavaData(CellData cellData, ExcelContentProperty contentProperty,
        GlobalConfiguration globalConfiguration) {
        return &quot;自定义：&quot; + cellData.getStringValue();
    }

    /**
     * 这里是写的时候会调用 不用管
     */
    @Override
    public CellData convertToExcelData(String value, ExcelContentProperty contentProperty,
        GlobalConfiguration globalConfiguration) {
        return new CellData(value);
    }

}</code></code></pre>
<ul>
<li>这里解析结果截取部分如下，原数据是<code>字符串0    2020/1/1 1:01   1</code></li>
</ul>
<pre><code><code>解析到一条数据:{&quot;date&quot;:&quot;2020年01月01日01时01分01秒&quot;,&quot;doubleData&quot;:&quot;100%&quot;,&quot;string&quot;:&quot;自定义：字符串0&quot;}</code></code></pre>
<h3 id="指定表头行数">1.6.3. 指定表头行数</h3>
<pre><code><code>        EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet()
            // 这里可以设置1，因为头就是一行。如果多行头，可以设置其他值。不传入也可以，因为默认会根据DemoData 来解析，他没有指定头，也就是默认1行
            .headRowNumber(1).doRead();</code></code></pre>
<h3 id="读取表头数据">1.6.4. 读取表头数据</h3>
<ul>
<li>只要在实现了<code>AnalysisEventListener</code>接口的监听器中，重写<code>invokeHeadMap</code>方法即可</li>
</ul>
<pre><code><code>    /**
     * 这里会一行行的返回头
     *
     * @param headMap
     * @param context
     */
    @Override
    public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) {
        LOGGER.info(&quot;解析到一条头数据:{}&quot;, JSON.toJSONString(headMap));
    }</code></code></pre>
<h3 id="转换异常处理">1.6.5. 转换异常处理</h3>
<ul>
<li>只要在实现了<code>AnalysisEventListener</code>接口的监听器中，重写<code>onException</code>方法即可</li>
</ul>
<pre><code><code>    @Override
    public void onException(Exception exception, AnalysisContext context) {
        LOGGER.error(&quot;解析失败，但是继续解析下一行:{}&quot;, exception.getMessage());
        if (exception instanceof ExcelDataConvertException) {
            ExcelDataConvertException excelDataConvertException = (ExcelDataConvertException)exception;
            LOGGER.error(&quot;第{}行，第{}列解析异常&quot;, excelDataConvertException.getRowIndex(),
                excelDataConvertException.getColumnIndex());
        }
    }</code></code></pre>
<h3 id="读取单元格参数和类型">1.6.6. 读取单元格参数和类型</h3>
<ul>
<li>将类属性用<code>CellData</code>封装起来</li>
</ul>
<pre><code><code>@Data
public class CellDataReadDemoData {
    private CellData&lt;String&gt; string;
    // 这里注意 虽然是日期 但是 类型 存储的是number 因为excel 存储的就是number
    private CellData&lt;Date&gt; date;
    private CellData&lt;Double&gt; doubleData;
    // 这里并不一定能完美的获取 有些公式是依赖性的 可能会读不到 这个问题后续会修复
    private CellData&lt;String&gt; formulaValue;
}</code></code></pre>
<ul>
<li>这样读取到的数据如下，会包含单元格数据类型</li>
</ul>
<pre><code><code>解析到一条数据:{&quot;date&quot;:{&quot;data&quot;:1577811661000,&quot;dataFormat&quot;:22,&quot;dataFormatString&quot;:&quot;m/d/yy h:mm&quot;,&quot;formula&quot;:false,&quot;numberValue&quot;:43831.0423726852,&quot;type&quot;:&quot;NUMBER&quot;},&quot;doubleData&quot;:{&quot;data&quot;:1.0,&quot;formula&quot;:false,&quot;numberValue&quot;:1,&quot;type&quot;:&quot;NUMBER&quot;},&quot;formulaValue&quot;:{&quot;data&quot;:&quot;字符串01&quot;,&quot;formula&quot;:true,&quot;formulaValue&quot;:&quot;_xlfn.CONCAT(A2,C2)&quot;,&quot;stringValue&quot;:&quot;字符串01&quot;,&quot;type&quot;:&quot;STRING&quot;},&quot;string&quot;:{&quot;data&quot;:&quot;字符串0&quot;,&quot;dataFormat&quot;:0,&quot;dataFormatString&quot;:&quot;General&quot;,&quot;formula&quot;:false,&quot;stringValue&quot;:&quot;字符串0&quot;,&quot;type&quot;:&quot;STRING&quot;}}</code></code></pre>
<h3 id="同步返回">1.6.7. 同步返回</h3>
<ul>
<li>不推荐使用，但如果特定情况一定要用，可以如下，主要为<code>doReadSync</code>方法，直接返回<code>List</code></li>
</ul>
<pre><code><code>    /**
     * 同步的返回，不推荐使用，如果数据量大会把数据放到内存里面
     */
    @Test
    public void synchronousRead() {
        String fileName = TestFileUtil.getPath() + &quot;demo&quot; + File.separator + &quot;demo.xlsx&quot;;
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 同步读取会自动finish
        List&lt;Object&gt; list = EasyExcel.read(fileName).head(DemoData.class).sheet().doReadSync();
        for (Object obj : list) {
            DemoData data = (DemoData)obj;
            LOGGER.info(&quot;读取到数据:{}&quot;, JSON.toJSONString(data));
        }

        // 这里 也可以不指定class，返回一个list，然后读取第一个sheet 同步读取会自动finish
        list = EasyExcel.read(fileName).sheet().doReadSync();
        for (Object obj : list) {
            // 返回每条数据的键值对 表示所在的列 和所在列的值
            Map&lt;Integer, String&gt; data = (Map&lt;Integer, String&gt;)obj;
            LOGGER.info(&quot;读取到数据:{}&quot;, JSON.toJSONString(data));
        }
    }</code></code></pre>
<h3 id="无对象的读">1.6.8. 无对象的读</h3>
<ul>
<li>顾名思义，不创建实体对象来读取Excel数据，那么我们就用Map接收，但这种对日期不友好，对于简单字段的读取可以使用</li>
<li>其它都一样，监听器的继承中泛型参数变为Map即可</li>
</ul>
<pre><code><code>public class NoModleDataListener extends AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt; {
    ...
}</code></code></pre>
<ul>
<li>结果截取如下</li>
</ul>
<pre><code><code>解析到一条数据:{0:&quot;字符串0&quot;,1:&quot;2020-01-01 01:01:01&quot;,2:&quot;1&quot;}</code></code></pre>
<h2 id="写入技巧">1.7. 写入技巧</h2>
<h3 id="排除特定字段和只写入特定字段">1.7.1. 排除特定字段和只写入特定字段</h3>
<ul>
<li>使用<code>excludeColumnFiledNames</code>来排除特定字段写入，用<code>includeColumnFiledNames</code>表示只写入特定字段</li>
</ul>
<pre><code><code>    /**
     * 根据参数只导出指定列
     * &lt;p&gt;
     * 1. 创建excel对应的实体对象 参照{@link DemoData}
     * &lt;p&gt;
     * 2. 根据自己或者排除自己需要的列
     * &lt;p&gt;
     * 3. 直接写即可
     */
    @Test
    public void excludeOrIncludeWrite() {
        String fileName = TestFileUtil.getPath() + &quot;excludeOrIncludeWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;

        // 根据用户传入字段 假设我们要忽略 date
        Set&lt;String&gt; excludeColumnFiledNames = new HashSet&lt;String&gt;();
        excludeColumnFiledNames.add(&quot;date&quot;);
        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        EasyExcel.write(fileName, DemoData.class).excludeColumnFiledNames(excludeColumnFiledNames).sheet(&quot;模板&quot;)
            .doWrite(data());

        fileName = TestFileUtil.getPath() + &quot;excludeOrIncludeWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 根据用户传入字段 假设我们只要导出 date
        Set&lt;String&gt; includeColumnFiledNames = new HashSet&lt;String&gt;();
        includeColumnFiledNames.add(&quot;date&quot;);
        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        EasyExcel.write(fileName, DemoData.class).includeColumnFiledNames(includeColumnFiledNames).sheet(&quot;模板&quot;)
            .doWrite(data());
    }</code></code></pre>
<h3 id="指定写入列">1.7.2. 指定写入列</h3>
<ul>
<li>写入列的顺序可以进行指定，在实体类注解上指定index，从小到大，从左到右排列</li>
</ul>
<pre><code><code>@Data
public class IndexData {
    @ExcelProperty(value = &quot;字符串标题&quot;, index = 0)
    private String string;
    @ExcelProperty(value = &quot;日期标题&quot;, index = 1)
    private Date date;
    /**
     * 这里设置3 会导致第二列空的
     */
    @ExcelProperty(value = &quot;数字标题&quot;, index = 3)
    private Double doubleData;
}</code></code></pre>
<h3 id="复杂头写入">1.7.3. 复杂头写入</h3>
<ul>
<li>如下图这种复杂头</li>
</ul>
<p><img src="./images/Excel解析工具easyexcel全面探索1.png" /></p>
<ul>
<li>我们可以通过修改实体类注解实现</li>
</ul>
<pre><code><code>@Data
public class ComplexHeadData {
    @ExcelProperty({&quot;主标题&quot;, &quot;字符串标题&quot;})
    private String string;
    @ExcelProperty({&quot;主标题&quot;, &quot;日期标题&quot;})
    private Date date;
    @ExcelProperty({&quot;主标题&quot;, &quot;数字标题&quot;})
    private Double doubleData;
}</code></code></pre>
<h3 id="重复多次写入">1.7.4. 重复多次写入</h3>
<ul>
<li>分为三种：1. 重复写入同一个sheet；2. 同一个对象写入不同sheet；3. 不同的对象写入不同的sheet</li>
</ul>
<pre><code><code>    /**
     * 重复多次写入
     * &lt;p&gt;
     * 1. 创建excel对应的实体对象 参照{@link ComplexHeadData}
     * &lt;p&gt;
     * 2. 使用{@link ExcelProperty}注解指定复杂的头
     * &lt;p&gt;
     * 3. 直接调用二次写入即可
     */
    @Test
    public void repeatedWrite() {
        // 方法1 如果写到同一个sheet
        String fileName = TestFileUtil.getPath() + &quot;repeatedWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 这里 需要指定写用哪个class去读
        ExcelWriter excelWriter = EasyExcel.write(fileName, DemoData.class).build();
        // 这里注意 如果同一个sheet只要创建一次
        WriteSheet writeSheet = EasyExcel.writerSheet(&quot;模板&quot;).build();
        // 去调用写入,这里我调用了五次，实际使用时根据数据库分页的总的页数来
        for (int i = 0; i &lt; 5; i++) {
            // 分页去数据库查询数据 这里可以去数据库查询每一页的数据
            List&lt;DemoData&gt; data = data();
            writeSheet.setSheetName(&quot;模板&quot;);
            excelWriter.write(data, writeSheet);
        }
        /// 千万别忘记finish 会帮忙关闭流
        excelWriter.finish();

        // 方法2 如果写到不同的sheet 同一个对象
        fileName = TestFileUtil.getPath() + &quot;repeatedWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 这里 指定文件
        excelWriter = EasyExcel.write(fileName, DemoData.class).build();
        // 去调用写入,这里我调用了五次，实际使用时根据数据库分页的总的页数来。这里最终会写到5个sheet里面
        for (int i = 0; i &lt; 5; i++) {
            // 每次都要创建writeSheet 这里注意必须指定sheetNo
            writeSheet = EasyExcel.writerSheet(i, &quot;模板&quot;+i).build();
            // 分页去数据库查询数据 这里可以去数据库查询每一页的数据
            List&lt;DemoData&gt; data = data();
            excelWriter.write(data, writeSheet);
        }
        /// 千万别忘记finish 会帮忙关闭流
        excelWriter.finish();

        // 方法3 如果写到不同的sheet 不同的对象
        fileName = TestFileUtil.getPath() + &quot;repeatedWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 这里 指定文件
        excelWriter = EasyExcel.write(fileName).build();
        // 去调用写入,这里我调用了五次，实际使用时根据数据库分页的总的页数来。这里最终会写到5个sheet里面
        for (int i = 0; i &lt; 5; i++) {
            // 每次都要创建writeSheet 这里注意必须指定sheetNo。这里注意DemoData.class 可以每次都变，我这里为了方便 所以用的同一个class 实际上可以一直变
            writeSheet = EasyExcel.writerSheet(i, &quot;模板&quot;+i).head(DemoData.class).build();
            // 分页去数据库查询数据 这里可以去数据库查询每一页的数据
            List&lt;DemoData&gt; data = data();
            excelWriter.write(data, writeSheet);
        }
        /// 千万别忘记finish 会帮忙关闭流
        excelWriter.finish();
    }</code></code></pre>
<h3 id="图片导出">1.7.5. 图片导出</h3>
<ul>
<li>对图片的导出，可能会有这样的需求，它提供了四种数据类型的导出，还是很丰富的</li>
</ul>
<pre><code><code>    @Test
    public void imageWrite() throws Exception {
        String fileName = TestFileUtil.getPath() + &quot;imageWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 如果使用流 记得关闭
        InputStream inputStream = null;
        try {
            List&lt;ImageData&gt; list = new ArrayList&lt;ImageData&gt;();
            ImageData imageData = new ImageData();
            list.add(imageData);
            String imagePath = TestFileUtil.getPath() + &quot;converter&quot; + File.separator + &quot;img.jpg&quot;;
            // 放入四种类型的图片 实际使用只要选一种即可
            imageData.setByteArray(FileUtils.readFileToByteArray(new File(imagePath)));
            imageData.setFile(new File(imagePath));
            imageData.setString(imagePath);
            inputStream = FileUtils.openInputStream(new File(imagePath));
            imageData.setInputStream(inputStream);
            EasyExcel.write(fileName, ImageData.class).sheet().doWrite(list);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }
    }</code></code></pre>
<ul>
<li>图片类为</li>
</ul>
<pre><code><code>@Data
@ContentRowHeight(100)
@ColumnWidth(100 / 8)
public class ImageData {
    private File file;
    private InputStream inputStream;
    /**
     * 如果string类型 必须指定转换器，string默认转换成string
     */
    @ExcelProperty(converter = StringImageConverter.class)
    private String string;
    private byte[] byteArray;
}</code></code></pre>
<p>导出结果：两行四列，每列都对应一张图片，四种导出类型均可</p>
<p><img src="./images/Excel解析工具easyexcel全面探索2.png" alt="image.png" /></p>
<ul>
<li>其中<code>StringImageConverter</code>自定义转换器为</li>
</ul>
<pre><code><code>public class StringImageConverter implements Converter&lt;String&gt; {
    @Override
    public Class supportJavaTypeKey() {
        return String.class;
    }

    @Override
    public CellDataTypeEnum supportExcelTypeKey() {
        return CellDataTypeEnum.IMAGE;
    }

    @Override
    public String convertToJavaData(CellData cellData, ExcelContentProperty contentProperty,
        GlobalConfiguration globalConfiguration) {
        throw new UnsupportedOperationException(&quot;Cannot convert images to string&quot;);
    }

    @Override
    public CellData convertToExcelData(String value, ExcelContentProperty contentProperty,
        GlobalConfiguration globalConfiguration) throws IOException {
        return new CellData(FileUtils.readFileToByteArray(new File(value)));
    }

}</code></code></pre>
<h3 id="字段宽高设置">1.7.6. 字段宽高设置</h3>
<ul>
<li>设置实体类注解属性即可</li>
</ul>
<pre><code><code>@Data
@ContentRowHeight(10)
@HeadRowHeight(20)
@ColumnWidth(25)
public class WidthAndHeightData {
    @ExcelProperty(&quot;字符串标题&quot;)
    private String string;
    @ExcelProperty(&quot;日期标题&quot;)
    private Date date;
    /**
     * 宽度为50
     */
    @ColumnWidth(50)
    @ExcelProperty(&quot;数字标题&quot;)
    private Double doubleData;
}</code></code></pre>
<h3 id="自定义样式">1.7.7. 自定义样式</h3>
<ul>
<li>实现会比较复杂，需要做头策略，内容策略，字体大小等</li>
</ul>
<pre><code><code>    @Test
    public void styleWrite() {
        String fileName = TestFileUtil.getPath() + &quot;styleWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 头的策略
        WriteCellStyle headWriteCellStyle = new WriteCellStyle();
        // 背景设置为红色
        headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());
        WriteFont headWriteFont = new WriteFont();
        headWriteFont.setFontHeightInPoints((short)20);
        headWriteCellStyle.setWriteFont(headWriteFont);
        // 内容的策略
        WriteCellStyle contentWriteCellStyle = new WriteCellStyle();
        // 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定
        contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);
        // 背景绿色
        contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());
        WriteFont contentWriteFont = new WriteFont();
        // 字体大小
        contentWriteFont.setFontHeightInPoints((short)20);
        contentWriteCellStyle.setWriteFont(contentWriteFont);
        // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现
        HorizontalCellStyleStrategy horizontalCellStyleStrategy =
            new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);

        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        EasyExcel.write(fileName, DemoData.class).registerWriteHandler(horizontalCellStyleStrategy).sheet(&quot;模板&quot;)
            .doWrite(data());
    }</code></code></pre>
<ul>
<li>效果如下<br />
<img src="./images/Excel解析工具easyexcel全面探索3.png" alt="image.png" /></li>
</ul>
<h3 id="单元格合并">1.7.8. 单元格合并</h3>
<pre><code><code>    @Test
    public void mergeWrite() {
        String fileName = TestFileUtil.getPath() + &quot;mergeWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 每隔2行会合并。当然其他合并策略也可以自己写
        LoopMergeStrategy loopMergeStrategy = new LoopMergeStrategy(2, 0);
        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        EasyExcel.write(fileName, DemoData.class).registerWriteHandler(loopMergeStrategy).sheet(&quot;模板&quot;).doWrite(data());
    }</code></code></pre>
<ul>
<li>效果如下，第一列单元格数据，2,3两行合并</li>
</ul>
<p><img src="./images/Excel解析工具easyexcel全面探索4.png" alt="image.png" /></p>
<h3 id="自动列宽">1.7.9. 自动列宽</h3>
<ul>
<li>根据作者描述，POI对中文的自动列宽适配不友好，easyexcel对数字也不能准确适配列宽，他提供的适配策略可以用，但不能精确适配，可以自己重写</li>
<li>想用就注册处理器<code>LongestMatchColumnWidthStyleStrategy</code></li>
</ul>
<pre><code><code>    @Test
    public void longestMatchColumnWidthWrite() {
        String fileName =
            TestFileUtil.getPath() + &quot;longestMatchColumnWidthWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        EasyExcel.write(fileName, LongestMatchColumnWidthData.class)
            .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).sheet(&quot;模板&quot;).doWrite(dataLong());
    }</code></code></pre>
<h3 id="下拉超链接">1.7.10. 下拉，超链接</h3>
<ul>
<li>下拉，超链接等功能需要自定义实现</li>
</ul>
<pre><code><code>    @Test
    public void customHandlerWrite() {
        String fileName = TestFileUtil.getPath() + &quot;customHandlerWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        EasyExcel.write(fileName, DemoData.class).registerWriteHandler(new CustomSheetWriteHandler())
            .registerWriteHandler(new CustomCellWriteHandler()).sheet(&quot;模板&quot;).doWrite(data());
    }</code></code></pre>
<ul>
<li>其中主要为处理器<code>CustomCellWriteHandler</code>类，其实现<code>CellWriteHandler</code>接口，我们在后处理方法<code>afterCellDispose</code>做处理</li>
</ul>
<pre><code><code>public class CustomCellWriteHandler implements CellWriteHandler {

    private static final Logger LOGGER = LoggerFactory.getLogger(CustomCellWriteHandler.class);

    @Override
    public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row,
        Head head, Integer columnIndex, Integer relativeRowIndex, Boolean isHead) {

    }

    @Override
    public void afterCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Cell cell,
        Head head, Integer relativeRowIndex, Boolean isHead) {

    }

    @Override
    public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,
        List&lt;CellData&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) {
        // 这里可以对cell进行任何操作
        LOGGER.info(&quot;第{}行，第{}列写入完成。&quot;, cell.getRowIndex(), cell.getColumnIndex());
        if (isHead &amp;&amp; cell.getColumnIndex() == 0) {
            CreationHelper createHelper = writeSheetHolder.getSheet().getWorkbook().getCreationHelper();
            Hyperlink hyperlink = createHelper.createHyperlink(HyperlinkType.URL);
            hyperlink.setAddress(&quot;https://github.com/alibaba/easyexcel&quot;);
            cell.setHyperlink(hyperlink);
        }
    }

}</code></code></pre>
<h3 id="不创建对象的写">1.7.11. 不创建对象的写</h3>
<ul>
<li>在设置write的时候不设置对象类，在head里添加<code>List&lt;List&lt;String&gt;&gt;</code>的对象头</li>
</ul>
<pre><code><code>    @Test
    public void noModleWrite() {
        // 写法1
        String fileName = TestFileUtil.getPath() + &quot;noModleWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;
        // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        EasyExcel.write(fileName).head(head()).sheet(&quot;模板&quot;).doWrite(dataList());
    }
    
    private List&lt;List&lt;String&gt;&gt; head() {
        List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;List&lt;String&gt;&gt;();
        List&lt;String&gt; head0 = new ArrayList&lt;String&gt;();
        head0.add(&quot;字符串&quot; + System.currentTimeMillis());
        List&lt;String&gt; head1 = new ArrayList&lt;String&gt;();
        head1.add(&quot;数字&quot; + System.currentTimeMillis());
        List&lt;String&gt; head2 = new ArrayList&lt;String&gt;();
        head2.add(&quot;日期&quot; + System.currentTimeMillis());
        list.add(head0);
        list.add(head1);
        list.add(head2);
        return list;
    }</code></code></pre>
<h2 id="总结">1.8. 总结</h2>
<ul>
<li>不知不觉列出了这么多easyexcel的使用技巧和方式，这里应该囊括了大部分我们工作中常用到的excel读写技巧，欢迎收藏查阅</li>
</ul>
<blockquote>
<p>easyexcel的<a href="https://github.com/alibaba/easyexcel">github地址</a><br />
欢迎访问收藏作者<a href="https://www.processon.com/u/599d35fae4b00d97d7f9bb18">知识点整理</a>，没注册的请点击<a href="https://www.processon.com/i/599d35fae4b00d97d7f9bb17">这里</a></p>
</blockquote>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>