<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(11)接口、多态' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(11)接口、多态</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11632728.html</div><br>
    <h1><span style="font-size: 18pt;">1. 接口</span></h1>
<h2>1.1 接口概念</h2>
<p>接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的&rdquo;类&rdquo;。</p>
<p>接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。</p>
<p>请记住：一切事物均有功能，即一切事物均有接口。</p>
<h2>1.2 接口的定义</h2>
<p>与定义类的class不同，接口定义时需要使用interface关键字。</p>
<p>定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。</p>
<p>定义格式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> 接口名 {
　　抽象方法1;
　　抽象方法2;
　　抽象方法3;
}</span></code></pre>

<p>使用interface代替了原来的class，其他步骤与定义类相同：</p>
<p class="a">　　接口中的方法均为公共访问的抽象方法</p>
<p class="a">　　接口中无法定义普通的成员变量</p>
<h2>1.3 类实现接口</h2>
<p>类与接口的关系为实现关系，即类实现接口。实现的动作类似继承，只是关键字不同，实现使用implements。</p>
<p>其他类(实现类)实现接口后，就相当于声明：&rdquo;我应该具备这个接口中的功能&rdquo;。实现类仍然需要重写方法以实现具体的功能。</p>
<p>格式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> 类 <span style="color: #0000ff;">implements</span><span style="color: #000000;"> 接口 {
    重写接口中方法
} </span></code></pre>

<p>在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写该抽象方法，完成具体的逻辑。</p>
<p class="a">　　接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该具备该方法，是功能的声明。</p>
<p class="a">　　在具体实现类中重写方法，实现功能，是方法的具体实现。</p>
<p>于是，通过以上两个动作将功能的声明与实现便分开了。(此时请重新思考：类是现实事物的描述，接口是功能的集合。)</p>
<h2>1.4 接口中成员的特点</h2>
<p>1、接口中可以定义变量，但是变量必须有固定的修饰符修饰，public static final 所以接口中的变量也称之为常量，其值不能改变。后面我们会讲解static与final关键字</p>
<p>2、接口中可以定义方法，方法也有固定的修饰符，public abstract</p>
<p>3、接口不可以创建对象。</p>
<p>4、子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是一个抽象类。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span> Demo { <span style="color: #008000;">//</span><span style="color: #008000;">/定义一个名称为Demo的接口。</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> NUM = 3;<span style="color: #008000;">//</span><span style="color: #008000;"> NUM的值不能改变</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show1();
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show2();
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">定义子类去覆盖接口中的方法。类与接口之间的关系是 实现。通过 关键字 implements</span>
<span style="color: #0000ff;">class</span> DemoImpl <span style="color: #0000ff;">implements</span> Demo { <span style="color: #008000;">//</span><span style="color: #008000;">子类实现Demo接口。
    </span><span style="color: #008000;">//</span><span style="color: #008000;">重写接口中的方法。</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show1(){}
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show2(){}
}</span></code></pre>

<h2>1.5 接口的多实现</h2>
<p>了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，接口到底有啥用呢？</p>
<p>接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Fu1
{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show1();
}
</span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Fu2
{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show2();
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">implements</span> Fu1,Fu2<span style="color: #008000;">//</span><span style="color: #008000;"> 多实现。同时实现多个接口。</span>
<span style="color: #000000;">{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show1(){}
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show2(){}
}</span></code></pre>

<p>怎么解决多继承的弊端呢？</p>
<p>弊端：多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。</p>
<p>其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。</p>
<p>为什么多实现能解决了呢？</p>
<p>因为接口中的功能都没有方法体，由子类来明确。</p>
<h2>1.6 类继承类同时实现接口</h2>
<p>接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了。</p>
<p>子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show(){}
}
</span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Inter {
    pulbic </span><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show1();
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span> Fu <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Inter {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show1() {
    }
}</span></code></pre>

<p>接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。</p>
<h2>1.7 接口的多继承</h2>
<p>学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以通过实现产生关系，那么接口与接口之间会有什么关系。</p>
<p>多个接口之间可以使用extends进行继承。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Fu1{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show();
}
</span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Fu2{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show1();
}
</span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Fu3{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show2();
}
</span><span style="color: #0000ff;">interface</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu1,Fu2,Fu3{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show3();
}</span></code></pre>

<p>在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性。</p>
<h2>1.8 接口的思想</h2>
<p>前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。</p>
<p><strong>举例：</strong>我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。</p>
<p><strong>总结：</strong>接口在开发中的它好处</p>
<p>1、接口的出现扩展了功能。</p>
<p>2、接口其实就是暴漏出来的规则。</p>
<p>3、接口的出现降低了耦合性，即设备与设备之间实现了解耦。</p>
<p>&nbsp;</p>
<p>接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。</p>
<h2>1.9 接口和抽象的区别</h2>
<p>&nbsp;</p>
<p>明白了接口思想和接口的用法后，接口和抽象类的区别是什么呢？接口在生活体现也基本掌握，那在程序中接口是如何体现的呢？</p>
<p>通过实例进行分析和代码演示抽象类和接口的用法。</p>
<p>1、举例：</p>
<p>犬：</p>
<p>　　行为：</p>
<p>　　　　吼叫；</p>
<p>　　　　吃饭；</p>
<p>缉毒犬：</p>
<p>　　行为：</p>
<p>　　　　吼叫；</p>
<p>　　　　吃饭；</p>
<p>　　　　缉毒；</p>
<p>&nbsp;</p>
<p>2、思考：</p>
<p>由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。</p>
<p>可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如下代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> 缉毒{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> 缉毒();
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">定义犬科的这个提醒的共性功能</span>
<span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> 犬科{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> 吃饭();
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> 吼叫();
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，
</span><span style="color: #008000;">//</span><span style="color: #008000;">由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能</span>
<span style="color: #0000ff;">class</span> 缉毒犬 <span style="color: #0000ff;">extends</span> 犬科 <span style="color: #0000ff;">implements</span><span style="color: #000000;"> 缉毒{

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> 缉毒() {
    }
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> 吃饭() {
    }
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> 吼叫() {
    }
}
</span><span style="color: #0000ff;">class</span> 缉毒猪 <span style="color: #0000ff;">implements</span><span style="color: #000000;"> 缉毒{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> 缉毒() {
    }
}</span></code></pre>

<p>3、通过上面的例子总结接口和抽象类的区别：</p>
<p><strong>相同点:</strong></p>
<blockquote>
<p class="a">都位于继承的顶端,用于被其他类实现或继承;</p>
<p class="a">都不能直接实例化对象;</p>
<p class="a">都包含抽象方法,其子类都必须覆写这些抽象方法;</p>
</blockquote>
<p><strong>区别:</strong></p>
<blockquote>
<p class="a">抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;</p>
<p class="a">一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)</p>
<p class="a">抽象类是这个事物中应该具备的你内容, 继承体系是一种 is..a关系</p>
<p class="a">接口是这个事物中的额外内容,继承体系是一种 like..a关系</p>
</blockquote>
<p>&nbsp;</p>
<p>二者的选用:</p>
<blockquote>
<p class="a">优先选用接口,尽量少用抽象类;</p>
<p class="a">需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</p>
</blockquote>
<h1>2. 多态</h1>
<h2>2.1 多态概述</h2>
<p>多态是继封装、继承之后，面向对象的第三大特性。</p>
<p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p>
<p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。</p>
<p>如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p>
<p>最终多态体现为<span style="color: #ff0000;">父类引用变量可以指向子类对象。</span></p>
<p><span style="color: #ff0000;">多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</span></p>
<p><span style="color: #ff0000;">在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</span></p>
<h2>2.2 多态的定义与使用格式</h2>
<p>多态的定义格式：就是父类的引用变量指向子类对象</p>
<src class="cnblogs_code">
<pre><code>父类类型  变量名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 子类类型();
变量名.方法名();</span></code></pre>

<p class="a">普通类多态定义的格式</p>
<src class="cnblogs_code">
<pre><code>父类 变量名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 子类();
如：    </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {}
    </span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {}
    </span><span style="color: #008000;">//</span><span style="color: #008000;">类的多态使用</span>
Fu f = <span style="color: #0000ff;">new</span> Zi();</code></pre>

<p class="a">抽象类多态定义的格式</p>
<src class="cnblogs_code">
<pre><code>抽象类 变量名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 抽象类子类();
如：    </span><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
         </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method();
         }
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(){
              System.out.println(&ldquo;重写父类抽象方法&rdquo;);
}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">类的多态使用</span>
Fu fu= <span style="color: #0000ff;">new</span> Zi();</code></pre>

<p class="a">接口多态定义的格式</p>
<src class="cnblogs_code">
<pre><code>接口 变量名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 接口实现类();
如： </span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Fu {
             </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method();
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Fu {
             </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(){
              System.out.println(&ldquo;重写接口抽象方法&rdquo;);
}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">接口的多态使用</span>
Fu fu = <span style="color: #0000ff;">new</span> Zi();</code></pre>

<p class="a">注意事项</p>
<p class="a">同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。</p>
<src class="cnblogs_code">
<pre><code>如 Person p1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Student();
   Person p2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Teacher();
   p1.work(); </span><span style="color: #008000;">//</span><span style="color: #008000;">p1会调用Student类中重写的work方法</span>
   p2.work(); <span style="color: #008000;">//</span><span style="color: #008000;">p2会调用Teacher类中重写的work方法</span></code></pre>

<p>当变量名指向不同的子类对象时，由于每个子类重写父类方法的内容不同，所以会调用不同的方法。</p>
<h2>2.3 多态-成员的特点</h2>
<p>掌握了多态的基本使用后，那么多态出现后类的成员有啥变化呢？前面学习继承时，我们知道子父类之间成员变量有了自己的特定变化，那么当多态出现后，成员变量在使用上有没有变化呢？</p>
<p>多态出现后会导致子父类中的成员变量有微弱的变化。看如下代码</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">int</span> num = 4<span style="color: #000000;">;
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">int</span> num = 5<span style="color: #000000;">;
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)     {
        Fu f </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        System.out.println(f.num);
        Zi z </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        System.out.println(z.num);
    }
}</span></code></pre>

<p class="a">多态成员变量</p>
<p>当子父类中出现同名的成员变量时，多态调用该变量时：</p>
<blockquote>
<p>编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。</p>
<p>运行时期：也是调用引用型变量所属的类中的成员变量。</p>
<p>简单记：编译和运行都参考等号的左边。编译运行看左边。</p>
</blockquote>
<p>&nbsp;</p>
<p>多态出现后会导致子父类中的成员方法有微弱的变化。看如下代码</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">int</span> num = 4<span style="color: #000000;">;
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show()    {
        System.out.println(</span>"Fu show num"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">int</span> num = 5<span style="color: #000000;">;
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show()    {
        System.out.println(</span>"Zi show num"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)     {
        Fu f </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        f.show();
    }
}</span></code></pre>

<p class="a">多态成员方法</p>
<blockquote>
<p>编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。</p>
<p>运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。</p>
<p>简而言之：编译看左边，运行看右边。</p>
</blockquote>
<h2>2.4 instanceof关键字</h2>
<p>我们可以通过instanceof关键字来判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类。</p>
<p>使用格式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">boolean</span>  b  = 对象  <span style="color: #0000ff;">instanceof</span>  数据类型;</code></pre>

<p>如</p>
<src class="cnblogs_code">
<pre><code>Person p1 = <span style="color: #0000ff;">new</span> Student(); <span style="color: #008000;">//</span><span style="color: #008000;"> 前提条件，学生类已经继承了人类</span>
<span style="color: #0000ff;">boolean</span> flag = p1 <span style="color: #0000ff;">instanceof</span> Student; <span style="color: #008000;">//</span><span style="color: #008000;">flag结果为true</span>
<span style="color: #0000ff;">boolean</span> flag2 = p2 <span style="color: #0000ff;">instanceof</span> Teacher; <span style="color: #008000;">//</span><span style="color: #008000;">flag结果为false</span></code></pre>

<h2>2.5 多态-转型</h2>
<p class="a">多态的转型分为向上转型与向下转型两种：</p>
<p class="a">　　向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。</p>
<p>　　使用格式：</p>
<src class="cnblogs_code">
<pre><code>父类类型  变量名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 子类类型();
如：Person p </span>= <span style="color: #0000ff;">new</span> Student();</code></pre>

<p class="a">　　向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！</p>
<p>　　使用格式：</p>
<src class="cnblogs_code">
<pre><code>子类类型 变量名 =<span style="color: #000000;"> (子类类型) 父类类型的变量;
如:Student stu </span>= (Student) p;  <span style="color: #008000;">//</span><span style="color: #008000;">变量p 实际上指向Student对象</span></code></pre>

<h2>2.6 多态的好处与弊端</h2>
<p>当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。向上转型的好处是隐藏了子类类型，提高了代码的扩展性。</p>
<p>但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。看如下代码</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">描述动物类，并抽取共性eat方法</span>
<span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat();
}
 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 描述狗类，继承动物类，重写eat方法，增加lookHome方法</span>
<span style="color: #0000ff;">class</span> Dog <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"啃骨头"<span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> lookHome() {
        System.out.println(</span>"看家"<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 描述猫类，继承动物类，重写eat方法，增加catchMouse方法</span>
<span style="color: #0000ff;">class</span> Cat <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃鱼"<span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> catchMouse() {
        System.out.println(</span>"抓老鼠"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Animal a </span>= <span style="color: #0000ff;">new</span> Dog(); <span style="color: #008000;">//</span><span style="color: #008000;">多态形式，创建一个狗对象</span>
        a.eat(); <span style="color: #008000;">//</span><span style="color: #008000;"> 调用对象中的方法，会执行狗类中的eat方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> a.lookHome();</span><span style="color: #008000;">//</span><span style="color: #008000;">使用Dog类特有的方法，需要向下转型，不能直接使用
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 为了使用狗类的lookHome方法，需要向下转型
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 那么，在转之前需要做健壮性判断 </span>
        <span style="color: #0000ff;">if</span>( !a <span style="color: #0000ff;">instanceof</span> Dog){ <span style="color: #008000;">//</span><span style="color: #008000;"> 判断当前对象是否是Dog类型</span>
                 System.out.println("类型不匹配，不能转换"<span style="color: #000000;">); 
                 </span><span style="color: #0000ff;">return</span><span style="color: #000000;">; 
        } 
        Dog d </span>= (Dog) a; <span style="color: #008000;">//</span><span style="color: #008000;">向下转型</span>
        d.lookHome();<span style="color: #008000;">//</span><span style="color: #008000;">调用狗类的lookHome方法</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p class="a">我们来总结一下：</p>
<p class="a">　　什么时候使用向上转型：</p>
<p>　　当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。</p>
<src class="cnblogs_code">
<pre><code>如：Animal a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Dog();
    a.eat();</span></code></pre>

<p class="a">　　什么时候使用向下转型</p>
<p>　　当要使用子类特有功能时，就需要使用向下转型。</p>
<src class="cnblogs_code">
<pre><code>如：Dog d = (Dog) a; <span style="color: #008000;">//</span><span style="color: #008000;">向下转型</span>
        d.lookHome();<span style="color: #008000;">//</span><span style="color: #008000;">调用狗类的lookHome方法</span></code></pre>

<p class="a">　　向下转型的好处：可以使用子类特有功能。</p>
<p class="a">　　弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。</p>
<src class="cnblogs_code">
<pre><code>如：<span style="color: #0000ff;">if</span>( !a <span style="color: #0000ff;">instanceof</span> Dog){&hellip;}</code></pre>

<h2>2.7 多态-举例</h2>
<p>我们明确多态使用，以及多态的细节问题后，接下来练习下多态的应用。</p>
<p class="a">　　毕老师和毕姥爷的故事</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
描述毕老师和毕姥爷，
毕老师拥有讲课和看电影功能
毕姥爷拥有讲课和钓鱼功能
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 毕姥爷 {
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> 讲课() {
        System.out.println(</span>"政治"<span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> 钓鱼() {
        System.out.println(</span>"钓鱼"<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 毕老师继承了毕姥爷，就有拥有了毕姥爷的讲课和钓鱼的功能，
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 但毕老师和毕姥爷的讲课内容不一样，因此毕老师要覆盖毕姥爷的讲课功能</span>
<span style="color: #0000ff;">class</span> 毕老师 <span style="color: #0000ff;">extends</span><span style="color: #000000;"> 毕姥爷 {
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> 讲课() {
        System.out.println(</span>"Java"<span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> 看电影() {
        System.out.println(</span>"看电影"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 多态形式</span>
        毕姥爷 a = <span style="color: #0000ff;">new</span> 毕老师(); <span style="color: #008000;">//</span><span style="color: #008000;"> 向上转型</span>
        a.讲课(); <span style="color: #008000;">//</span><span style="color: #008000;"> 这里表象是毕姥爷，其实真正讲课的仍然是毕老师，因此调用的也是毕老师的讲课功能</span>
        a.钓鱼(); <span style="color: #008000;">//</span><span style="color: #008000;"> 这里表象是毕姥爷，但对象其实是毕老师，而毕老师继承了毕姥爷，即毕老师也具有钓鱼功能

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 当要调用毕老师特有的看电影功能时，就必须进行类型转换</span>
        毕老师 b = (毕老师) a; <span style="color: #008000;">//</span><span style="color: #008000;"> 向下转型</span>
<span style="color: #000000;">        b.看电影();
    }
}</span></code></pre>

<p>学习到这里，面向对象的三大特征学习完了。</p>
<p>总结下封装、继承、多态的作用：</p>
<blockquote>
<p class="a">封装：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式</p>
<p class="a">继承：子类会自动拥有父类所有可继承的属性和方法。</p>
<p class="a">多态：配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义。</p>
</blockquote>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>