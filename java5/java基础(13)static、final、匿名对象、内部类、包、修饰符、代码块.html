<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(13)static、final、匿名对象、内部类、包、修饰符、代码块' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(13)static、final、匿名对象、内部类、包、修饰符、代码块</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11633060.html</div><br>
    <h1>1. final关键字</h1>
<h2>1.1 final的概念</h2>
<p>继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？</p>
<p>要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</p>
<h2>1.2 final的特点</h2>
<p class="a">final修饰类不可以被继承，但是可以继承其他类。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Yy {}
</span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span> Fu <span style="color: #0000ff;">extends</span> Yy{} <span style="color: #008000;">//</span><span style="color: #008000;">可以继承Yy类</span>
<span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span> Fu{} <span style="color: #008000;">//</span><span style="color: #008000;">不能继承Fu类</span></code></pre>

<p class="a">final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> final修饰的方法，不可以被覆盖，但可以继承使用</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1(){}
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2(){}
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">重写method2方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2(){}
}</span></code></pre>

<p class="a">final修饰的变量称为常量，这些变量只能赋值一次。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> i = 20<span style="color: #000000;">;
i </span>= 30; <span style="color: #008000;">//</span><span style="color: #008000;">赋值报错，final修饰的变量只能赋值一次</span></code></pre>

<p>引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">final</span> Person p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
Person p2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
p </span>= p2; <span style="color: #008000;">//</span><span style="color: #008000;">final修饰的变量p，所记录的地址值不能改变</span>
p.name = "小明";<span style="color: #008000;">//</span><span style="color: #008000;">可以更改p对象中name属性值</span></code></pre>

<p>p不能为别的对象，而p对象中的name或age属性值可更改。</p>
<p>&nbsp;</p>
<p class="a">修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接赋值</span>
    <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> m = 100<span style="color: #000000;">;
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">final修饰的成员变量，需要在创建对象前赋值，否则报错。</span>
    <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> n; 
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Demo(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">可以在创建对象时所调用的构造方法中，为变量n赋值</span>
        n = 2016<span style="color: #000000;">;
    }
}</span></code></pre>

<h1>2. static关键字</h1>
<h2>2.1 static概念</h2>
<p>当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？</p>
<p>可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</p>
<h2>2.2 static特点</h2>
<p class="a">被static修饰的成员变量属于类，不属于这个类的某个对象。（也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）</p>
<p>代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> num = 100<span style="color: #000000;">;
}

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Demo d1 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Demo();
        Demo d2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Demo();
        d1.num </span>= 200<span style="color: #000000;">;
        System.out.println(d1.num); </span><span style="color: #008000;">//</span><span style="color: #008000;">结果为200</span>
        System.out.println(d2.num); <span style="color: #008000;">//</span><span style="color: #008000;">结果为200</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p class="a">被static修饰的成员可以并且建议通过类名直接访问。</p>
<p>访问静态成员的格式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">类名.静态成员变量名
类名.静态成员方法名(参数)
对象名.静态成员变量名         </span>------<span style="color: #000000;">不建议使用该方式，会出现警告
对象名.静态成员方法名(参数)     </span>------不建议使用该方式，会出现警告</code></pre>

<p>代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">静态成员变量</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> num = 100<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">静态方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(){
        System.out.println(</span>"静态方法"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        System.out.println(Demo.num);
        Demo.method();
    }
}</span></code></pre>

<h2>2.3 static注意事项</h2>
<p>静态内容是优先于对象存在，只能访问静态，不能使用this/super。静态修饰的内容存于静态区。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">成员变量</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> num = 100<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">静态方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">this.num; 不能使用this/super。</span>
        System.out.println(<span style="color: #0000ff;">this</span><span style="color: #000000;">.num);
    }
}</span></code></pre>

<p>同一个类中，静态成员只能访问静态成员</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">成员变量</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> num = 100<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">静态成员变量</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> count = 200<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">静态方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println(num); 静态方法中，只能访问静态成员变量或静态成员方法</span>
<span style="color: #000000;">        System.out.println(count);
    }
}</span></code></pre>

<p>main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中。</p>
<h2>2.4 定义静态常量</h2>
<p>开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。此时变量名用全部大写，多个单词使用下划线连接。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">定义格式：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> 数据类型 变量名 = 值;</code></pre>

<p>如下演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Company {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String COMPANY_NAME = "传智播客"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(){
        System.out.println(</span>"一个静态方法"<span style="color: #000000;">);
    }
}</span></code></pre>

<p class="a">当我们想使用类的静态成员时，不需要创建对象，直接使用类名来访问即可。</p>
<src class="cnblogs_code">
<pre><code>System.out.println(Company.COMPANY_NAME); <span style="color: #008000;">//</span><span style="color: #008000;">打印传智播客</span>
Company.method(); <span style="color: #008000;">//</span><span style="color: #008000;"> 调用一个静态方法</span></code></pre>

<p class="a">注意：</p>
<p><span style="color: #ff0000;">接口中的每个成员变量都默认使用public static final修饰。</span></p>
<p><span style="color: #ff0000;">所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> Inter {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> COUNT = 100<span style="color: #000000;">;
}</span></code></pre>

<p>访问接口中的静态变量</p>
<src class="cnblogs_code">
<pre><code>Inter.COUNT</code></pre>

<h1>3. 匿名对象</h1>
<h2>3.1 匿名对象的概念</h2>
<p>匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p>
<p>如：已经存在的类：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Person{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat(){
        System.out.println();
    }
}</span></code></pre>

<p>创建一个普通对象</p>
<src class="cnblogs_code">
<pre><code>Person p = <span style="color: #0000ff;">new</span> Person();</code></pre>

<p>创建一个匿名对象</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">new</span> Person();</code></pre>

<h2>3.2 匿名对象的特点</h2>
<p>创建匿名对象直接使用，没有变量名。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">new</span> Person().eat()  <span style="color: #008000;">//</span><span style="color: #008000;">eat方法被一个没有名字的Person对象调用了。</span></code></pre>

<p class="a">匿名对象在没有指定其引用变量时，只能使用一次。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">new</span><span style="color: #000000;"> Person().eat(); 创建一个匿名对象，调用eat方法
</span><span style="color: #0000ff;">new</span> Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象</code></pre>

<p class="a">匿名对象可以作为方法接收的参数、方法返回值使用</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Person getPerson(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">普通方式
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Person p = new Person();    
        </span><span style="color: #008000;">//</span><span style="color: #008000;">return p;
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名对象作为方法返回值</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person(); 
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(Person p){}
}

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用getPerson方法，得到一个Person对象</span>
        Person person =<span style="color: #000000;"> Demo.getPerson();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用method方法</span>
<span style="color: #000000;">        Demo.method(person);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名对象作为方法接收的参数</span>
        Demo.method(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Person());
    }
}</span></code></pre>

<h1>4. 内部类</h1>
<h2>4.1 内部类概念</h2>
<p class="a">什么是内部类</p>
<blockquote>
<p>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。</p>
</blockquote>
<p class="a">什么时候使用内部类</p>
<blockquote>
<p>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。</p>
</blockquote>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> 汽车 { <span style="color: #008000;">//</span><span style="color: #008000;">外部类</span>
    <span style="color: #0000ff;">class</span> 发动机 { <span style="color: #008000;">//</span><span style="color: #008000;">内部类</span>
　　<span style="color: #000000;">}
}</span></code></pre>

<p class="a">内部类的分类</p>
<blockquote>
<p>内部类分为成员内部类与局部内部类。</p>
<p>我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。</p>
</blockquote>
<h2>4.2 成员内部类</h2>
<p>成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问</p>
<p>定义格式</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> 外部类 { 
    修饰符 </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 内部类 {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">其他代码</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p>访问方式</p>
<src class="cnblogs_code">
<pre><code>外部类名.内部类名 变量名 = <span style="color: #0000ff;">new</span> 外部类名().<span style="color: #0000ff;">new</span> 内部类名();</code></pre>

<p class="a">成员内部类代码演示</p>
<p>定义类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> Body {<span style="color: #008000;">//</span><span style="color: #008000;">外部类，身体</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">boolean</span> life= <span style="color: #0000ff;">true</span>; <span style="color: #008000;">//</span><span style="color: #008000;">生命状态</span>
     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Heart { <span style="color: #008000;">//</span><span style="color: #008000;">内部类，心脏</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> jump() {
         System.out.println(</span>"心脏噗通噗通的跳"<span style="color: #000000;">)
            System.out.println(</span>"生命状态" + life); <span style="color: #008000;">//</span><span style="color: #008000;">访问外部类成员变量</span>
<span style="color: #000000;">        }
    }
}</span></code></pre>

<p>访问内部类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建内部类对象</span>
    Body.Heart bh = <span style="color: #0000ff;">new</span> Body().<span style="color: #0000ff;">new</span><span style="color: #000000;"> Heart();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">调用内部类中的方法</span>
<span style="color: #000000;">    bh.jump();
}</span></code></pre>

<h2>4.3 局部内部类</h2>
<p>局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问</p>
<p>定义格式</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> 外部类 { 
    修饰符 返回值类型 方法名(参数) {
　　　　</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 内部类 {
　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">其他代码</span>
<span style="color: #000000;">        }
    }
}</span></code></pre>

<p>访问方式</p>
<src class="cnblogs_code">
<pre><code>在外部类方法中，创建内部类对象，进行访问</code></pre>

<p class="a">局部内部类代码演示</p>
<p class="a">定义类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> Party {<span style="color: #008000;">//</span><span style="color: #008000;">外部类，聚会</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> puffBall(){<span style="color: #008000;">//</span><span style="color: #008000;"> 吹气球方法</span>
        <span style="color: #0000ff;">class</span> Ball {<span style="color: #008000;">//</span><span style="color: #008000;"> 内部类，气球</span>
              <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> puff(){
     System.out.println(</span>"气球膨胀了"<span style="color: #000000;">);
        }
    }
</span><span style="color: #008000;">//</span><span style="color: #008000;">创建内部类对象，调用puff方法</span>
<span style="color: #0000ff;">new</span><span style="color: #000000;"> Ball().puff();
    }
}</span></code></pre>

<p>访问内部类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建外部类对象</span>
    Party p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Party();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">调用外部类中的puffBall方法</span>
<span style="color: #000000;">    p.puffBall();
}</span></code></pre>

<h2>4.4 内部类的实际使用&mdash;&mdash;匿名内部类</h2>
<h3>4.4.1 匿名内部类概念</h3>
<p>内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。</p>
<p>最常用到的内部类就是匿名内部类，它是局部内部类的一种。</p>
<p>定义的匿名内部类有两个含义：</p>
<p class="a">　　临时定义某一指定类型的子类</p>
<p class="a">　　定义后即刻创建刚刚定义的这个子类的对象</p>
<h3>4.4.2 定义匿名内部类的作用与格式</h3>
<p><strong>作用：</strong>匿名内部类是创建某个类型子类对象的快捷方式。</p>
<p><strong>格式：</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">new</span><span style="color: #000000;"> 父类或接口(){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">进行方法重写</span>
};</code></pre>

<p class="a">代码演示</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">已经存在的父类：</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Person{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat();
    }
</span><span style="color: #008000;">//</span><span style="color: #008000;">定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量</span>
Person  p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person(){
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(&ldquo;我吃了&rdquo;);
    }
};
</span><span style="color: #008000;">//</span><span style="color: #008000;">调用eat方法</span>
p.eat();</code></pre>

<p>使用匿名对象的方式，将定义子类与创建子类对象两个步骤由一个格式一次完成，。虽然是两个步骤，但是两个步骤是连在一起完成的。</p>
<p>匿名内部类如果不定义变量引用，则也是匿名对象。代码如下：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">new</span><span style="color: #000000;"> Person(){
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(&ldquo;我吃了&rdquo;);
    }
}.eat();</span></code></pre>

<h1>5. 包的声明与访问</h1>
<h2>5.1 包的概念</h2>
<p>java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。</p>
<p>当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为分包管理。</p>
<p>在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。</p>
<p>类中声明的包必须与实际class文件所在的文件夹情况相一致，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类。</p>
<h2>5.2 包的声明格式</h2>
<p>通常使用公司网址反写，可以有多层包，包名采用全部小写字母，多层包之间用&rdquo;.&rdquo;连接</p>
<p>类中包的声明格式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span> 包名.包名.包名&hellip;;</code></pre>

<p>如：黑马程序员网址itheima.com那么网址反写就为com.itheima</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 传智播客 itcast.cn&nbsp; 那么网址反写就为 cn.itcast</p>
<p class="a">注意：声明包的语句，必须写在程序有效代码的第一行（注释不算）</p>
<p class="a">代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span> cn.itcast; <span style="color: #008000;">//</span><span style="color: #008000;">包的声明，必须在有效代码的第一行</span>

<span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Scanner;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Random;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Demo {}</code></pre>

<h2>5.3 包的访问</h2>
<p>在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">包名.包名&hellip;.类名
如： java.util.Scanner
     java.util.Random
    cn.itcast.Demo
带有包的类，创建对象格式：包名.类名 变量名 </span>=<span style="color: #000000;"> new包名.类名();
     cn.itcast.Demo d </span>= <span style="color: #0000ff;">new</span> cn.itcast.Demo();</code></pre>

<p class="a">前提：包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。</p>
<p class="a">类的简化访问</p>
<p>当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。</p>
<p>如：cn.itcast包中有两个类，PersonTest类，与Person类。我们在PersonTest类中，访问Person类时，由于是同一个包下，访问时可以省略包名，即直接通过类名访问 Person。</p>
<src class="cnblogs_code">
<pre><code>类名 变量名 =<span style="color: #000000;"> new类名();
Person p </span>= <span style="color: #0000ff;">new</span> Person();</code></pre>

<p class="a">当我们要使用的类，与当前程序不在同一个包中（即不同文件夹中），要访问的类必须用public修饰才可访问。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> cn.itcst02;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Person {}</code></pre>

<h2>5.4 import导包</h2>
<p>我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。</p>
<p>可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。</p>
<p>导包的格式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span> 包名.类名;</code></pre>

<p>当程序导入指定的包后，使用类时，就可以简化了。演示如下</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">导入包前的方式
</span><span style="color: #008000;">//</span><span style="color: #008000;">创建对象</span>
java.util.Random r1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> java.util.Random();
java.util.Random r2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> java.util.Random();
java.util.Scanner sc1 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> java.util.Scanner(System.in);
java.util.Scanner sc2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> java.util.Scanner(System.in);

</span><span style="color: #008000;">//</span><span style="color: #008000;">导入包后的方式</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Random;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Scanner;
</span><span style="color: #008000;">//</span><span style="color: #008000;">创建对象</span>
Random r1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();
Random r2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();
Scanner sc1 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
Scanner sc2 </span>= <span style="color: #0000ff;">new</span> Scanner(System.in);</code></pre>

<p class="a">import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import 包名.包名.类名;</p>
<h1>6. 访问修饰符</h1>
<p>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：</p>
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="77">
<p>&nbsp;</p>
</td>
<td width="109">
<p>public</p>
</td>
<td width="110">
<p>protected</p>
</td>
<td width="109">
<p>default</p>
</td>
<td width="109">
<p>private</p>
</td>
</tr>
<tr>
<td width="77">
<p>同一类中</p>
</td>
<td width="109">
<p>&radic;</p>
</td>
<td width="110">
<p>&radic;</p>
</td>
<td width="109">
<p>&radic;</p>
</td>
<td width="109">
<p>&radic;</p>
</td>
</tr>
<tr>
<td width="77">
<p>同一包中(子类与无关类)</p>
</td>
<td width="109">
<p>&radic;</p>
</td>
<td width="110">
<p>&radic;</p>
</td>
<td width="109">
<p>&radic;</p>
</td>
<td width="109">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td width="77">
<p>不同包的子类</p>
</td>
<td width="109">
<p>&radic;</p>
</td>
<td width="110">
<p>&radic;</p>
</td>
<td width="109">
<p>&nbsp;</p>
</td>
<td width="109">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td width="77">
<p>不同包中的无关类</p>
</td>
<td width="109">
<p>&radic;</p>
</td>
<td width="110">
<p>&nbsp;</p>
</td>
<td width="109">
<p>&nbsp;</p>
</td>
<td width="109">
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问</p>
<blockquote>
<p class="a">要想仅能在本类中访问使用private修饰；</p>
<p class="a">要想本包中的类都可以访问不加修饰符即可；</p>
<p class="a">要想本包中的类与其他包中的子类可以访问使用protected修饰</p>
<p class="a">要想所有包中的所有类都可以访问使用public修饰。</p>
<p class="a">注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。</p>
</blockquote>
<h1>7. 代码块</h1>
<h2>7.1 局部代码块</h2>
<p>局部代码块是定义在方法或语句中</p>
<p>特点：</p>
<blockquote>
<p class="a">以&rdquo;{}&rdquo;划定的代码区域，此时只需要关注作用域的不同即可</p>
<p class="a">方法和类都是以代码块的方式划定边界的</p>
</blockquote>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)    {
        {
                  </span><span style="color: #0000ff;">int</span> x = 1<span style="color: #000000;">;
                 System.out.println(</span>"普通代码块" +<span style="color: #000000;"> x);
        }
        </span><span style="color: #0000ff;">int</span> x = 99<span style="color: #000000;">;
        System.out.println(</span>"代码块之外" +<span style="color: #000000;"> x);
    }
}</span></code></pre>

<p>结果：</p>
<blockquote>
<p>普通代码块1</p>
<p>代码块之外99</p>
</blockquote>
<h2>7.2 构造代码块</h2>
<p>构造代码块是定义在类中成员位置的代码块</p>
<p>特点：</p>
<blockquote>
<p class="a">优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作</p>
<p class="a">每创建一个对象均会执行一次构造代码块。</p>
</blockquote>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Person {
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;
    
     </span><span style="color: #008000;">//</span><span style="color: #008000;">构造代码块</span>
<span style="color: #000000;">    {
        System.out.println(</span>"构造代码块执行了"<span style="color: #000000;">);
    }
    Person(){
        System.out.println(</span>"Person无参数的构造函数执行"<span style="color: #000000;">);
    }
    Person(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age){
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
        System.out.println(</span>"Person（age）参数的构造函数执行"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> PersonDemo{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)    {
        Person p </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
        Person p1 </span>= <span style="color: #0000ff;">new</span> Person(23<span style="color: #000000;">);
    }
}</span></code></pre>

<h2>7.3 静态代码块</h2>
<p>静态代码块是定义在成员位置，使用static修饰的代码块。</p>
<p>特点：</p>
<blockquote>
<p class="a">它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。</p>
<p class="a">该类不管创建多少对象，静态代码块只执行一次。</p>
<p class="a">可用于给静态变量赋值，用来给类进行初始化。</p>
</blockquote>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Person {
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;
     </span><span style="color: #008000;">//</span><span style="color: #008000;">静态代码块</span>
    <span style="color: #0000ff;">static</span><span style="color: #000000;">{
        System.out.println(</span>"静态代码块执行了"<span style="color: #000000;">);
    }
}</span></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>