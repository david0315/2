<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修javaSE总结（二）--java面向对象' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>javaSE总结（二）--java面向对象</center></div><div class='banquan'>原文出处:本文由博客园博主王大军提供。<br/>
原文连接:https://www.cnblogs.com/FondWang/p/11457436.html</div><br>
    <p><strong>一、类和对象</strong></p>
<p>　　（1）<strong>类</strong></p>
<src class="cnblogs_code">
<pre><code>【修饰符】 <span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">修饰符1：private public protected 三个最多出现其一
    </span><span style="color: #008000;">//</span><span style="color: #008000;">修饰符2：abstract final 两个最多出现其一
    </span><span style="color: #008000;">//</span><span style="color: #008000;">上面都可与static组合使用来修饰类</span>
}</code></pre>

<p>　　--每个单词首字母大写，其余字母小写<br />　　--最好不能是关键字，可以包含关键字</p>
<p><br />与类相关的构造器</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【修饰符】 构造器名(形参列表)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">修饰符：public private protected
    </span><span style="color: #008000;">//</span><span style="color: #008000;">构造器名：与类名相同
    </span><span style="color: #008000;">//</span><span style="color: #008000;">形参列表：和定义方法形参列表的格式相同</span>
}</code></pre>

<p>　　--构造器没有返回值</p>
<p>　　（2）<strong>对象</strong></p>
<p>　　　　a) 创建对象</p>
<p>　　　　　　类名 对象名 = new 构造器名（）；</p>
<p>　　　　b) 对象调用　</p>
<p>　　　　　　对象调用类中的内容（没有被static修饰过）<br />	　　　　　　　　1&nbsp;调用方法： 对象名.方法名()； ==&gt; per.say();<br />	　　　　　　　　2&nbsp;调用属性：对象名.属性名； 可赋值。例：per.name="测试";<br />	　　　　　　　　3&nbsp;this关键字：代表当前类的对象，this.方法名（）； this.属性名；</p>
<p>　　　　c) 对象的内存机制</p>
<src class="cnblogs_code">
<pre><code>Person p=<span style="color: #0000ff;">new</span>  Person(); 创建出对象后，会在分配内存存储这个对象，有两块内存。 一个是栈内存：存放p变量，p只是存放对象的变量名，它存储在堆内存中； 另一个是堆内存：存放实体对象，对象里的所有属性和方法都在栈内存中。 <br />栈内存中的变量会指向堆内存的对应的实体对象，p变量相当于一个引用。</code></pre>

<p>　　（3）static静态　　　</p>
<p>　　　　1.&nbsp;static静态，可修饰方法、属性<br />　　　　2.&nbsp;如果被static修饰的成员，那么此成员属于类的本身，使用该类作为主调；没有被static修饰过的，则属于该类的对象，通常使用对象调用（也可用类调用）。<br />　　　　3.&nbsp;总结： 静态用类名调用<br />         　　　　　　　　&nbsp;非静态用对象调用（也可类名调用）</p>
<p><strong>二、方法</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;"> 修饰关键字  [返回类型]  方法名称([参数类型  参数名称]){
       </span><span style="color: #008000;">//</span><span style="color: #008000;">方法内容</span>
        [<span style="color: #0000ff;">return</span><span style="color: #000000;"> 返回值]
}</span></code></pre>

<p><strong>注意：</strong></p>
<p>　　-- 方法不能独立定义，方法只能在类中定义；方法不能独立执行，需要通过对象或类调用执行；同一个类中，不可出现两个以上相同的方法。<br />　　-- 方法重载：相同方法名，不同参数。</p>
<p>&nbsp;</p>
<p><strong>三、成员变量和局部变量</strong></p>
<p>　　（1）成员变量</p>
<p>　　　　a) 实例变量：无static修饰</p>
<p>　　　　b) 类变量： 有static形式</p>
<p>　　（2）局部变量</p>
<p>　　　　a) <strong>方法局部变量</strong>（在方法内定义）:&nbsp;从定义该变量生效，到该方法结束是失效。</p>
<p>　　　　b) <strong>代码块局部变量</strong>（在代码块内定义）:&nbsp;从定义该变量时生效，到该代码块结束失效。</p>
<p>　　　　c)&nbsp;<strong>形参</strong>（方法签名中定义的变量）:&nbsp;在定义方法签名时，定义的变量，形参的作用域在整个方法内有效。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;"><span style="color: #ff0000;">注意:</span>
    局部变量与成员变量可以同名，局部变量覆盖成员变量的值。如果需要在这个方法里引用被覆盖的成员变量，则使用this(对于实例变量)或类名（对于类变量）作为调用者来限定访问成员变量。</span></code></pre>

<p><strong>四、面向对象的特征</strong></p>
<p><strong>　　</strong>（1）<span style="color: #cc99ff;">继承&nbsp;<span class="hl-reserved">extends</span></span></p>
<p>　　　　子类继承父类，子类便拥有父类的非私用方法和成员属性</p>
<p>　　　　a)&nbsp;方法重写（Override也称方法的覆盖）</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">方法重写遵循&ldquo;<span style="color: #ff0000;">两同两小一大</span>&rdquo;. 
   </span>1 "两同"<span style="color: #000000;">: 方法名、形参列表相同
   </span>2 "两小"<span style="color: #000000;">: 子类返回值类型要比父类的更小或相同；抛出的异常要比父类的异常类的范围要小。
   </span>3<span style="color: #000000;"> &ldquo;一大&rdquo;：子类方法的访问权限比父类方法的访问权限更大或相等。
<span style="color: #ff0000;">注意：</span>
      子类覆盖父类的方法后，子类对象无法访问父类中被子类覆盖的方法，可以调用子类中覆盖父类的方法。</span></code></pre>

<p>　　　　b)&nbsp;super限定</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">super</span><span style="color: #000000;">(); 调用父类构造器，只可在子类构造器中使用。
</span><span style="color: #0000ff;">super</span><span style="color: #000000;">.属性； 调用父类属性。
</span><span style="color: #0000ff;">super</span>.方法()；调用父类中的方法。</code></pre>

<p>　　　　c) super注意</p>
<src class="cnblogs_code">
<pre><code>    1<span style="color: #000000;"> 在子类构造器中没有通过super（）调用父类构造器，系统默认隐式的调用父类无参构造器一次。
    </span>2 子类构造器中只可调用一次父类构造器，普通方法可调用多次父类的属性或方法。</code></pre>

<p>　　（2）<span style="color: #cc99ff;">封装</span></p>
<p>　　　　访问控制符<br />	　　　<strong>　private</strong>(当前类访问权限) <strong>default</strong>（包访问权限） <strong>protected</strong>（子类访问权限） <strong>public</strong>（公共访问权限） </p>
<p>　　（3）<span style="color: #cc99ff;">多态</span></p>
<src class="cnblogs_code">
<pre><code>1<span style="color: #000000;">.相同类型的变量，调用同一个方法时呈现出多种不同的行为特征，就是多态。
</span>2<span style="color: #000000;">.引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法。
</span>3.难以理解的话，这样记。Father f=<span style="color: #0000ff;">new</span> Son()； Son子类的实例赋值给Father父类的变量，f变量只能调用Father父类中的内容</code></pre>

<src class="cnblogs_code">
<pre><code><span style="color: #000000;">instanceof运算符：
    对象名 </span><span style="color: #0000ff;">instanceof</span>  类，判断前一个对象是否是后一个类（子类、实现类）的实例。若是返回true，否则返回false。</code></pre>

<p><strong>五、接口和抽象类</strong></p>
<p>　　（1）接口</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">a 使用interface关键字修饰类，此类称为接口。
b 接口：</span>1<span style="color: #000000;">.所有的方法都是抽象方法（abstract可省略）。
         </span>2.所用的成员变量都是静态常量（<span style="color: #0000ff;">final</span><span style="color: #000000;"> 和 static可省略）。
c 接口可以继承接口，不可继承类，允许多继承。
<strong>一个类可以多实现多个接口。 </strong>   </span></code></pre>

<p>　　（2）抽象类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">定义：抽象类和抽象方法必须使用abstract来修饰。有抽象方法的类一定是抽象类，抽象类可以没有抽象方法。
抽象类不能被实例化。
抽象类作为子类的模板，避免子类设计的随意性。</span></code></pre>

<p>　　（3）接口和抽象类的异同</p>
<src class="cnblogs_code">
<pre><code>1<span style="color: #000000;">.它们都不能被实例化，用于子类的继承和实现。
</span>2<span style="color: #000000;">.抽象类可以包含普通方法和抽象方法，普通成员变量和静态常量； 接口中只能定义抽象方法和静态常量。
</span>3<span style="color: #000000;">.接口没有构造器；抽象类有构造器，但不能实例化，用于子类调用 完成初始化操作。
</span>4<span style="color: #000000;">.接口中不能包含初始代码块；抽象类可以包含初始代码块。
</span>5.一个类最多有一个直接父类，包括抽象类；但一个类可以实现多个接口。</code></pre>

<p>&nbsp;</p>
<p><strong>六、包装类</strong></p>
<p><strong>　　</strong>描述：基本数据类型不具备&ldquo;对象&rdquo;的特性，没有成员变量、方法可以调用。包装类则存在对数据处理的方法，方便良好的对数据操作。通过自动装/拆箱，简化基本类型和包装类对象之间的转换。</p>
<p>　　类型：Byte Int Short Long Character Float Double Boolean String</p>
<p>　　包装类的相关方法：</p>
<p>　　　　（1）xxxValue(): 将Number对象转换为xxx数据类型的值并返回。小括号中无参数</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">byteValue(); 以byte形式返回指定的数值。
doubleValue(); 以double形式返回指定的数值。
floatValue(); 以float形式返回指定的数值。
intValue(); 以int形式返回指定的数值。
longValue(); 以long形式返回指定的数值。
shortValue(); 以short形式返回指定的数值。
例： Integer x</span>=5<span style="color: #000000;">; 
x.doubleValue(); </span><span style="color: #008000;">//</span><span style="color: #008000;">返回double原生数据类型</span></code></pre>

<p>　　（2）compareTo()：将number对象与参数比较。</p>
<src class="cnblogs_code">
<pre><code>Integer x = 5<span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span> num=x.compareTo(3<span style="color: #000000;">);
如果指定的数与参数相等返回0。
如果指定的数小于参数返回 </span>-1<span style="color: #000000;">。
如果指定的数大于参数返回 </span>1。</code></pre>

<p>　　（3）equals()判断number对象是否与参数相等。<br />　　（4）valueOf() 返回一个Number对象指定的内置数据类型<br />　　（5）toString()：以字符串形式返回值。</p>
<p>　　（6）parseXXX(): 将字符串解析为XXX类型。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">parseInt(): 将字符串解析为int类型。
parseFloat(): 将字符串解析为Float类型。
parseDouble(): 将字符串解析为double类型。
parseShort(): 将字符串解析为Short类型。
parseLong(): 将字符串解析为Long类型。</span></code></pre>

<p>　　（7）random()：返回一个随机数0~1之间。</p>
<p>&nbsp;</p>
<p><strong>七、内部类</strong></p>
<p><strong>　　</strong>（1）定义：一个类在另一类的内部定义，这个在其他类内部的类被称为内部类（有的地方也叫嵌套类）。</p>
<p>　　（2）作用：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">a 提供更好的封装，把内部类隐藏在外部类中，不允许同一个包中的其他类访问该类。
b 内部类可以直接访问外部类的私有属性 以及其他成员，内部类也可看做是内部类的其他成员。但外部类不能访问内部类中的实现细节（如内部类的成员变量）。
c 内部类可以比外部类多使用三个修饰符：</span><span style="color: #0000ff;">private</span>、<span style="color: #0000ff;">protected</span>、<span style="color: #0000ff;">static</span>-----<span style="color: #000000;">外部类不可以使用。
d 非静态内部类不能拥有静态成员</span></code></pre>

<p>　　（3）静态内部类/非静态内部类</p>
<p>　　　　a) 静态内部类</p>
<p>　　　　　　定义：使用static修饰的内部类，称静态内部类。 静态内部类属于外部类本身。</p>
<p>　　　　　　　　　静态内部类中可以包含静态成员，也可非静态成员。静态成员不能访问非静态成员。</p>
<p>　　　　　　 &nbsp;　　&nbsp;接口中可以定义内部类，且内部类只能是静态内部类。</p>
<p>　　　　b) 非静态内部类</p>
<p>　　　　　　1 外部类不能直接访问内部类成员。在外部类中内部类外，通过创建内部类的实例，通过内部类实例访问内部类成员。（跟使用普通类的格式相同）</p>
<p>　　　　　　2 &nbsp;内部类可以直接使用外部类的成员。在内部类中，通过this、外部类类名.this作为限定区分。</p>
<p>　　　　　　　　a.this.成员名： 访问非静态内部类的实例变量，this.inVarName<br />　　　　　　　　b.外部类名.this.成员名： 访问外部类的实例变量，OutClass.this.outVarName</p>
<p>　　　　 &nbsp; &nbsp;<strong>注意</strong>：不允许在非静态内部类中定义静态成员</p>
<p>　　（4）使用内部类</p>
<p>　　　　a) 在外部使用内部类　</p>
<p>　　　　　　1&nbsp;与平常使用普通类没有太大的区别，通过new调用内部类的构造器创建内部类的实例，用实例调用内部类中的成员。<br />　　　　　　2&nbsp;不要在外部类的静态成员（包括静态方法和静态初始代码块）中使用非静态内部类，静态成员不能访问非静态成员。</p>
<p>　　　　b)&nbsp;在外部类以外使用非静态内部类</p>
<src class="cnblogs_code">
<pre><code>1<span style="color: #000000;">.private修饰的内部类，只能在外部类中使用。
</span>2<span style="color: #000000;">.省略访问控制符的内部类，只可被外部类处于同一包下的其他类使用。
</span>3<span style="color: #000000;">.protected修饰的内部类，只可被外部类处于同一包下的其他类和外部类的子类使用。
</span>4.public修饰的内部类，任何地方都可以被使用。</code></pre>

<src class="cnblogs_code">
<pre><code><span style="color: #000000;">使用非静态内部类的基本语法：
</span>1. OuterClass.InnerClass  inner=<span style="color: #0000ff;">new</span> OuterClass().<span style="color: #0000ff;">new</span><span style="color: #000000;"> InnerClass(); 创建了内部类的实例对象。
</span>2. OuterClass out=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Outer();
    OuterClass.InnerClass in</span>=out.<span style="color: #0000ff;">new</span><span style="color: #000000;"> InnerClass(); 同理也创建了内部类的实例对象。
</span>3. 非静态内部类的构造器，必须使用外部类对象来调用。</code></pre>

<src class="cnblogs_code">
<pre><code><span style="color: #000000;">当一个类继承了非静态内部类时，在子类构造器中会调用父类非静态内部类的构造器，需要将外部类的对象传递给子类构造器。因为非静态内部类的构造器必须通过外部类的实例对象调用。如下：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> SubClass <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Out.In{
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> SubClass(Out out){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">通过出入的out对象，调用In的构造器。</span>
            out.<span style="color: #0000ff;">super</span>("hello"<span style="color: #000000;">);
}
}</span></code></pre>

<p>　　　　c)&nbsp;在外部类以外使用静态内部类</p>
<p>　　　　　　基本语法：<br />　　　　　　　　OuterClass.InnerClass  in=new OuterClass.InnerClass();<br />　　　　　　　　因为静态内部类是外部类类相关的，因此在创建静态内部类对象时无法创建外部类的对象。</p>
<p>　　（5）局部内部类（方法内部类）　　　　</p>
<p>　　　　定义： 将一个类放入方法内中定义，则这个类成为局部内部类（方法内部类），局部内部类仅在该方法内有效。<br />　　　　　　1.方法外的任何地方 都不可调用局部内部类中的成员，只在方法内有效，<br />　　　　　　2.局部内部类不可以用static修饰。<br />　　　　　　3.如果需要用局部内部类定义变量、创建实例或派生子类，只能在局部内部类所处的方法内进行。</p>
<p><strong>八、处理类成员和对象</strong></p>
<p><strong>&nbsp;</strong>　　（1）处理对象</p>
<src class="cnblogs_code">
<pre><code>1 toString(); 在打印对象的时，通过toString() 方法，可以将对象的详细信息（"自我描述"<span style="color: #000000;">）打印出来。不使用toString ()方法，打印出的信息是对象的哈希值。
</span>2 ==<span style="color: #000000;"> 与equal 区别
    当判断的是基本数据类型，无区别。数值相等 即为相等
    当判断的是引用数据类型：</span>==当数值和内存地址（同一对象）相等时，才为相等； equal 只数值相等，即为相等</code></pre>

<p>　　（2）类成员</p>
<p>　　　　　<em id="__mceDel">成员变量，方法，构造器，初始代码块，内部类（包括接口，枚举）。=除构造器 都可用static修饰</em></p>
<p><em id="__mceDel">　　　　　单例类： 一个类只可创建一个实例</em></p>
<p>　　（3）final 修饰符</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">a) final修饰的变量必须赋初始值
b) final修饰的变量，初始值存在之后，值定不可变。
    </span>1<span style="color: #000000;"> 基本类型值不可变。
    </span>2<span style="color: #000000;"> 引用类型，引用对象不可变，内存地址不可变，地址中的内容可以。如        
p.setName() 可改变对象中的内容。不可p</span>=<span style="color: #0000ff;">null</span><span style="color: #000000;">; 这样内存中的地址就被消除，不可行。
    </span>3<span style="color: #000000;"> 子类不可以重写父类中final修饰的方法
    </span>4 final修饰的类为不可变类，不可被继承。</code></pre>

<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>