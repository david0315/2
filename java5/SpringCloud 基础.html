<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修SpringCloud 基础' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>SpringCloud 基础</center></div><div class='banquan'>原文出处:本文由博客园博主问魂归处提供。<br/>
原文连接:https://www.cnblogs.com/jtznenic/p/11438998.html</div><br>
    <src class="toc">
    <p class="toc-title">目录</p>
    <src class="toc-list">
        <ul>
        <li><a href="#springcloud-基础">SpringCloud 基础</a><ul>
        <li><a href="#一概述">一、概述</a></li>
        <li><a href="#二服务发现组件-eureka">二、服务发现组件 Eureka</a><ul>
        <li><a href="#介绍">1. 介绍</a></li>
        <li><a href="#搭建-maven-父工程">2. 搭建 Maven 父工程</a></li>
        <li><a href="#创建-eureka-集群">3. 创建 Eureka 集群</a></li>
        <li><a href="#创建服务提供方集群">4. 创建服务提供方集群</a></li>
        <li><a href="#创建服务消费方">5. 创建服务消费方</a></li>
        </ul></li>
        <li><a href="#三服务调用组件">三、服务调用组件</a><ul>
        <li><a href="#调用服务基于-loadbalancerclient">1. 调用服务基于 LoadBalancerClient</a></li>
        <li><a href="#调度服务基于-ribbon">2. 调度服务基于 Ribbon</a></li>
        <li><a href="#调度基于-feign">3. 调度基于 Feign</a></li>
        </ul></li>
        <li><a href="#四熔断器组件-hystrix">四、熔断器组件 Hystrix</a><ul>
        <li><a href="#介绍-1">1. 介绍</a></li>
        <li><a href="#ribbon使用hystrix">2. Ribbon使用Hystrix</a></li>
        <li><a href="#feign使用hystrix">3. Feign使用Hystrix</a></li>
        <li><a href="#hystrix监控服务器">4. Hystrix监控服务器</a></li>
        </ul></li>
        <li><a href="#五分布式配置中心组件spring-cloud-config">五、分布式配置中心组件Spring Cloud Config</a><ul>
        <li><a href="#介绍-2">1. 介绍</a></li>
        <li><a href="#构建config-server">2. 构建Config Server</a></li>
        <li><a href="#构建config-client">3. 构建Config Client</a></li>
        </ul></li>
        <li><a href="#六服务网关组件netflix-zuul">六、服务网关组件Netflix Zuul</a><ul>
        <li><a href="#介绍-3">1. 介绍</a></li>
        <li><a href="#zuul服务网关搭建">2.Zuul服务网关搭建</a></li>
        </ul></li>
        </ul></li>
        </ul>
    

<h1 id="springcloud-基础">SpringCloud 基础</h1>
<h2 id="一概述">一、概述</h2>
<ol>
<li>微服务：将传统的一站式应用，拆分成一个个的服务，彻底去耦合，一个微服务就是单功能业务，只做一件事。</li>
<li>微服务是一种架构模式或者一种架构风格，提倡将单一应用程序划分成一组小的服务独立部署服务之间相互配合、相互协调，每个服务运行于自己的进程中。服务与服务间采用轻量级通讯，如HTTP的RESTful API等避免统一的、集中式的服务管理机制 。</li>
<li>微服务优点
<ul>
<li>每个服务足够内聚，足够小，比较容易聚焦。</li>
<li>开发简单且效率高，一个服务只做一件事情。</li>
<li>微服务能用不同的语言开发</li>
<li>易于和第三方集成，微服务允许容易且灵活的自动集成部署（持续集成工具有Jenkins,Hudson,bamboo等）</li>
<li>微服务易于被开发人员理解，修改和维护。</li>
<li>微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面组件融合</li>
<li>每个微服务都可以有自己的存储能力，数据库可自有也可以统一，十分灵活</li>
</ul></li>
<li>微服务缺点
<ul>
<li>开发人员要处理分布式系统的复杂性</li>
<li>多服务运维难度，随着服务的增加，运维的压力也会增大</li>
<li>依赖系统部署</li>
<li>服务间通讯的成本</li>
<li>性能监控的难度大</li>
<li>系统集成测试难度大</li>
<li>数据的一致性维护比较困难</li>
</ul></li>
<li>Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</li>
<li>SpringCloud 核心子项目
<ul>
<li>Spring Cloud Netflix：核心组件，可以对多个Netflix OSS开源套件进行整合，包括以下几个组件：
<ul>
<li>Eureka：服务治理组件，包含服务注册与发现</li>
<li>Hystrix：容错管理组件，实现了熔断器</li>
<li>Ribbon：客户端负载均衡的服务调用组件</li>
<li>基于Ribbon和Hystrix的声明式服务调用组件</li>
<li>Zuul：网关组件，提供智能路由、访问过滤等功能</li>
<li>Archaius：外部化配置组件</li>
</ul></li>
<li>Spring Cloud Config：配置管理工具，实现应用配置的外部化存储，支持客户端配置信息刷新、加密/解密配置内容等。</li>
<li>…</li>
</ul></li>
</ol>
<h2 id="二服务发现组件-eureka">二、服务发现组件 Eureka</h2>
<h3 id="介绍">1. 介绍</h3>
<ol>
<li>Eureka是Spring Cloud Netflix微服务套件中的一部分，是一套成熟的服务注册和发现组件，可以与Springboot构建的微服务很容易的整合起来。Eureka包含了服务器端和客户端组件。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li>
</ol>
<h3 id="搭建-maven-父工程">2. 搭建 Maven 父工程</h3>
<ul>
<li><p>pom.xml</p>
<pre><code><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;groupId&gt;com.offcn&lt;/groupId&gt;
&lt;artifactId&gt;APartenProject&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;Greenwich.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></code></pre></li>
</ul>
<h3 id="创建-eureka-集群">3. 创建 Eureka 集群</h3>
<ol>
<li><p>新建子模块 eureka-server01</p>
<ol>
<li><p>pom.xml</p>
<pre><code><code>&lt;parent&gt;
    &lt;artifactId&gt;APartenProject&lt;/artifactId&gt;
    &lt;groupId&gt;com.offcn&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;
&lt;groupId&gt;com.offcn&lt;/groupId&gt;
&lt;artifactId&gt;eureka-server01&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;name&gt;eureka-server01&lt;/name&gt;
&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></code></pre></li>
<li><p>配置 application.yml</p>
<pre class="yaml"><code> #内置的tomcat服务启动监听端口号
server:
  # port: 8888
  port: 10086

#应用名称
spring:
  application:
    name: eureka-server

#EurekaServer配置
eureka:
  client:
    # register-with-eureka: false #此EurekaServer不再注册到其他的注册中心
    # fetch-registry: false       #不再从其他中心中心拉取服务器信息
    service-url:
      #defaultZone: http://localhost:${server.port}/eureka #注册中心访问地址
      defaultZone: http://localhost:10087/eureka #指向另外一台Eureka服务器
  server:
    enable-self-preservation: false   # Eureka开启自动保护模式
    eviction-interval-timer-in-ms: 4000</code></code></pre></li>
<li><p>为启动类添加注解</p>
<pre class="java"><code>@SpringBootApplication
// 开启 EurekaServer
@EnableEurekaServer
public class EurekaServer01Application {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServer01Application.class, args);
    }}</code></code></pre></li>
</ol></li>
<li><p>和 eureka-server01 一样，新建一个子模块eureka-server02，只改一下配置文件 application.yml，其它保持一致。</p>
<pre class="yaml"><code>server:
  port: 10087

spring:
  application:
    name: eureka-server

eureka:
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 4000
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka</code></code></pre></li>
<li><p>运行两个服务器 <a href="http://localhost:10086/" class="uri">http://localhost:10086/</a> 和 <a href="http://localhost:10087/" class="uri">http://localhost:10087/</a> 都可以</p></li>
</ol>
<p><img src="./images/SpringCloud 基础0.png" /></p>
<h3 id="创建服务提供方集群">4. 创建服务提供方集群</h3>
<ol>
<li><p>新建子模块 userprovider01</p>
<ol>
<li><p>pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></code></pre></li>
<li><p>application.yml</p>
<pre class="yaml"><code>server:
  port: 8001

spring:
  application:
    name: userprovider
  datasource:
    url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
#一定注意eureka与spring属于平级 注意格式
eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/

# 数据
ProviderVersion: UserProvider:0.02V</code></code></pre></li>
<li><p>创建实体类User</p>
<pre class="java"><code>@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @Column(name=&quot;name&quot;,nullable = true,length = 200)
    private String name;

    @Column(name = &quot;age&quot;,nullable = true,length = 4)
    private Integer age;
}</code></code></pre></li>
<li><p>UserDao 实现 JpaRepository&lt;User, Long&gt;，创建UserService、UserServiceImpl、UserController(RESTful风格)</p>
<pre class="java"><code>// UserController
@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @Autowired
    UserService userService;

    @Value(&quot;${ProviderVersion}&quot;)
    private String ProviderVersion;

    @GetMapping(&quot;/getall&quot;)
    @ApiOperation(value = &quot;获取全部用户信息&quot;, notes = &quot;获取全部用户信息&quot;)
    public Map&lt;String,Object&gt; getUsers() {
        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();
        List&lt;User&gt; list = userService.getUserList();
        map.put(&quot;list&quot;, list);
        map.put(&quot;ProviderVersion&quot;, ProviderVersion);
        return map;
    }   
    ......
}</code></code></pre></li>
<li><p>启动类添加注解 <code>@EnableDiscoveryClient</code></p></li>
</ol></li>
<li><p>新建子模块 userprovider02，除了 application.yml 和 UserController的getAll方法有些差别外，其它全部一样</p>
<pre class="yaml"><code>server:
  port: 8002

spring:
  application:
    name: userprovider
  datasource:
    url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
#一定注意eureka与spring属于平级 注意格式
eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/</code></code></pre>
<pre class="java"><code>// UserController 中的getUser方法中 ProviderVersion 的值与 UserProvider01项目有所区别（ProviderVersion: UserProvider:0.02V），这是为了后面负载均衡的时候看出差别。
@GetMapping(&quot;/getall&quot;)
    public Map&lt;String,Object&gt; getUsers() {
        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();
        List&lt;User&gt; list = userService.getUserList();
        map.put(&quot;list&quot;, list);
        String ProviderVersion=&quot;用户服务UserProvdier002:0.01V&quot;;
        map.put(&quot;ProviderVersion&quot;, ProviderVersion);
        return map;
    }</code></code></pre></li>
<li><p>运行两个提供者</p>
<p><img src="./images/SpringCloud 基础1.png" /></p>
<p><img src="./images/SpringCloud 基础2.png" /></p></li>
</ol>
<h3 id="创建服务消费方">5. 创建服务消费方</h3>
<ol>
<li><p>新建子模块 userweb01</p></li>
<li><p>pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.webjars&lt;/groupId&gt;
        &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
        &lt;version&gt;4.2.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></code></pre></li>
<li><p>配置 application.yml</p>
<pre class="yaml"><code>server:
  port: 9001

spring:
  thymeleaf:
    cache: false
  application:
    name: userweb01

eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/</code></code></pre></li>
<li><p>修改启动类</p>
<pre class="java"><code>@SpringBootApplication
@EnableDiscoveryClient
public class Userweb01Application {

    public static void main(String[] args) {
        SpringApplication.run(Userweb01Application.class, args);
    }

    @Bean
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}</code></code></pre></li>
<li><p>新建 User，UserController，UserService，UserSerivceImpl</p>
<pre class="java"><code>// UserController.java
// 因为使用了 thymeleaf，所以需要转发到相应模版，使用 Model 携带数据
@Controller
public class UserController {
    @Autowired
    UserService userService;

    @GetMapping(&quot;/&quot;)
    public String getUserList(Model model){
        Map map = userService.getUserMap();
        List&lt;User&gt; list=(List&lt;User&gt;) map.get(&quot;list&quot;);
        model.addAttribute(&quot;page&quot;, list);
        model.addAttribute(&quot;ProviderVersion&quot;, map.get(&quot;ProviderVersion&quot;));

        return &quot;user/list&quot;;
    }
 ......
}</code></code></pre>
<pre class="java"><code>// UserSerivceImpl.java
@Service
public class UserServiceImpl implements UserService {
    //远程服务调用客户端
    @Autowired
    RestTemplate restTemplate;
    //Eureka客户端
    @Autowired
    DiscoveryClient discoveryClient;

    /***
     * 通过客户端负载均衡器获取生产者服务器基础地址
     * @return
     */
    public String getServerUrl() {
        //通过客户端调用器查找指定服务
        List&lt;ServiceInstance&gt; instList = discoveryClient.getInstances(&quot;USERPROVIDER&quot;);
        //获取第一个服务器
        ServiceInstance inst = instList.get(0);
        //获取服务提供者服务器ip、端口号
        String ip = inst.getHost();
        int port = inst.getPort();
        //拼接调用地址
        String url=&quot;http://&quot;+ip+&quot;:&quot;+port+&quot;/user&quot;;
        return url;
    }

    @Override
    public Map getUserMap() {
        Map map = restTemplate.getForObject(getServerUrl()+&quot;/getall&quot;, Map.class);
        return map;
    }

    @Override
    public void createUser(User user) {

        restTemplate.postForObject(getServerUrl()+&quot;/save&quot;, user,String.class);

    }

    @Override
    public User getUser(Long id) {

        return restTemplate.getForObject(getServerUrl()+&quot;/get/&quot;+id, User.class);
    }

    @Override
    public void updateUser(Long id, User user) {
        restTemplate.put(getServerUrl()+&quot;/update/&quot;+id, user);

    }

    @Override
    public void deleteUser(Long id) {
        restTemplate.delete(getServerUrl()+&quot;/delete/&quot;+id);
    }
}</code></code></pre></li>
<li><p>启动服务，跳转地址 <a href="http://localhost:9001/" class="uri">http://localhost:9001/</a></p>
<p><img src="./images/SpringCloud 基础3.png" /></p>
<p><img src="./images/SpringCloud 基础4.png" /></p></li>
</ol>
<h2 id="三服务调用组件">三、服务调用组件</h2>
<p> SpringColud中已经帮我们集成了一系列负载均衡组件：LoadBalancerClient、Ribbon(缎带)、Feign(装作)，简单修改代码即可使用。</p>
<h3 id="调用服务基于-loadbalancerclient">1. 调用服务基于 LoadBalancerClient</h3>
<ol>
<li><p>新建子模块 userweb02</p></li>
<li><p>pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.webjars&lt;/groupId&gt;
        &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
        &lt;version&gt;4.2.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></code></pre></li>
<li><p>配置文件 application.yml</p>
<pre class="yaml"><code>server:
  port: 9002

spring:
  thymeleaf:
    cache: false
  application:
    name: userweb02

eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/</code></code></pre></li>
<li><p>启动类、Bean、UserController、UserService 还和 UserWeb01 项目保持一直，只有UserServiceImpl 有一些变化</p>
<pre class="java"><code>// UserServiceImpl.java
@Service
public class UserServiceImpl implements UserService {
    //远程服务调用客户端
    @Autowired
    RestTemplate restTemplate;
    //支持负载均衡的调用客户端
    @Autowired
    LoadBalancerClient loadBalancerClient;

    /***
     * 通过客户端负载均衡器获取生产者服务器基础地址
     * @return
     */
    public String getServerUrl() {
        //通过客户端调用器查找指定服务，只有这里发生了变化。
        ServiceInstance inst  = loadBalancerClient.choose(&quot;USERPROVIDER&quot;);
        //获取服务提供者服务器ip、端口号
        String ip = inst.getHost();
        int port = inst.getPort();
        //拼接调用地址
        String url=&quot;http://&quot;+ip+&quot;:&quot;+port+&quot;/user&quot;;
        return url;
    }
    ......
   // 方法还和以前保持一致     
}</code></code></pre></li>
<li><p>运行服务，<a href="http://localhost:9002/" class="uri">http://localhost:9002/</a></p></li>
</ol>
<p><img src="./images/SpringCloud 基础5.png" /></p>
<p><img src="./images/SpringCloud 基础6.png" /></p>
<p><img src="./images/SpringCloud 基础7.png" /></p>
<h3 id="调度服务基于-ribbon">2. 调度服务基于 Ribbon</h3>
<p> Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。</p>
<ol>
<li><p>新建子模块 UserWeb03</p></li>
<li><p>pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.webjars&lt;/groupId&gt;
        &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
        &lt;version&gt;4.2.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
        &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></code></pre></li>
<li><p>配置文件 application.yml</p>
<ul>
<li>负载均衡策略：</li>
<li>com.netflix.loadbalancer.RoundRobinRule：轮询</li>
<li>com.netflix.loadbalancer.RandomRule：随机</li>
<li>com.netflix.loadbalancer.RetryRule：重试</li>
<li>com.netflix.loadbalancer.WeightedResponseTimeRule：根据响应时间权重分配一个weight，响应时间越长，weight越小，被选中的可能性越低。</li>
<li>com.netflix.loadbalancer.BestAvailableRule：选择一个最小的并发请求的server</li>
<li>AvailabilityFilteringRule：过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</li>
<li>ZoneAvoidanceRule：复合判断server所在区域的性能和server的可用性选择server</li>
</ul>
<pre class="yaml"><code>server:
  port: 9003

spring:
  thymeleaf:
    cache: false
  application:
    name: userweb03
    #开启Spring Cloud的重试功能
  cloud:
    loadbalancer:
      retry:
        enabled: true

eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/

USERPROVIDER:
  ribbon: 
    # 配置指定服务的负载均衡策略
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    # Ribbon的连接超时时间
    ConnectTimeout: 250
    # Ribbon的数据读取超时时间
    ReadTimeout: 250
    # 是否对所有操作都进行重试
    OkToRetryOnAllOperations: true
    # 切换实例的重试次数
    MaxAutoRetriesNextServer: 1
    # 对当前实例的重试次数
    MaxAutoRetries: 1</code></code></pre></li>
<li><p>启动类修改</p>
<pre class="java"><code>@SpringBootApplication
@EnableDiscoveryClient
public class Userweb03Application {

    public static void main(String[] args) {
        SpringApplication.run(Userweb03Application.class, args);
    }

    @Bean
//    开启 ribbon
    @LoadBalanced
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}</code></code></pre></li>
<li><p>User、UserController、UserService都和上一个保持一致，只有UserServiceImpl有所不同</p>
<pre class="java"><code>@Service
public class UserServiceImpl implements UserService {
    //远程服务调用客户端
    @Autowired
    RestTemplate restTemplate;

    //开启Ribbon后，RestTemplate直接使用服务名就可以发起调用
    String url=&quot;http://USERPROVIDER&quot;;
    ......
        其它代码一致，取消了getUrl方法
}</code></code></pre></li>
</ol>
<p>5.运行服务 <a href="http://localhost:9003/" class="uri">http://localhost:9003/</a></p>
<p><img src="./images/SpringCloud 基础8.png" /></p>
<p><img src="./images/SpringCloud 基础6.png" /></p>
<p><img src="./images/SpringCloud 基础7.png" /></p>
<h3 id="调度基于-feign">3. 调度基于 Feign</h3>
<p> Feign是一个声明性的web服务客户端，使用Feign创建接口并对其进行注释，就可以通过该接口调用生产者提供的服务。Spring Cloud对Feign进行了增强，使得Feign支持了Spring MVC注解。</p>
<ul>
<li>Feign采用的是接口加注解;</li>
<li>Feign 整合了ribbon</li>
</ul>
<ol>
<li><p>创建子模块 UserWeb04</p></li>
<li><p>pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
            &lt;version&gt;4.2.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
            &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></code></pre></li>
<li><p>配置文件 application.yml</p>
<pre class="yaml"><code>server:
  port: 9004

spring:
  thymeleaf:
    cache: false
  application:
    name: userweb04
    #开启Spring Cloud的重试功能
  cloud:
    loadbalancer:
      retry:
        enabled: true

eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/

USERPROVIDER:
  ribbon:
    # 配置指定服务的负载均衡策略
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    # Ribbon的连接超时时间
    ConnectTimeout: 250
    # Ribbon的数据读取超时时间
    ReadTimeout: 250
    # 是否对所有操作都进行重试
    OkToRetryOnAllOperations: true
    # 切换实例的重试次数
    MaxAutoRetriesNextServer: 1
    # 对当前实例的重试次数
    MaxAutoRetries: 1

# 设置对应包的日志级别
logging.level.com.offcn.userweb04: debug</code></code></pre></li>
<li><p>编写配置类，定义日志级别，Feign支持4种级别：</p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<pre class="java"><code>@Configuration
public class FeignConfig {
    @Bean
    public Logger.Level getFeignlogger(){
        return Logger.Level.FULL;
    }
}</code></code></pre></li>
<li><p>启动类添加注解 <code>@EnableFeignClients</code></p></li>
<li><p>User、UserController与其它 UserWeb 项目保持一致，但是要删除UserServiceImpl，修改UserService</p>
<pre class="java"><code>@FeignClient(value = &quot;USERPROVIDER&quot;, configuration = FeignConfig.class)
public interface UserService {
    @GetMapping(&quot;/user/getall&quot;)
    public Map&lt;String, Object&gt; getUserMap();
    @PostMapping(&quot;/user/save&quot;)
    public void createUser(User user);
    @GetMapping(&quot;/user/get/{id}&quot;)
    public User getUser(@RequestParam(&quot;id&quot;) Long id);
    @PutMapping(&quot;/user/update/{id}&quot;)
    public void updateUser(@RequestParam(&quot;id&quot;) Long id, @RequestBody User user);
    @DeleteMapping(&quot;/user/delete/{id}&quot;)
    public void deleteUser(@RequestParam(&quot;id&quot;) Long id);
}</code></code></pre></li>
<li><p>运行服务 &lt;&gt;</p>
<p><img src="./images/SpringCloud 基础11.png" /></p></li>
</ol>
<p><img src="./images/SpringCloud 基础6.png" /></p>
<p><img src="./images/SpringCloud 基础7.png" /></p>
<p><img src="./images/SpringCloud 基础14.png" /></p>
<h2 id="四熔断器组件-hystrix">四、熔断器组件 Hystrix</h2>
<h3 id="介绍-1">1. 介绍</h3>
<p> Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。在分布式系统中应用这一模式之后，服务调用方可以自己进行判断某些服务反应慢或者存在大量超时的情况时，能够主动熔断，防止整体系统被拖垮。不同于电路熔断只能断不能自动重连，Hystrix可以实现弹性容错，当情况好转之后，可以自动重连。</p>
<h3 id="ribbon使用hystrix">2. Ribbon使用Hystrix</h3>
<ol>
<li><p>修改子模块 UserWeb03，引入依赖</p>
<pre><code><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;</code></code></pre></li>
<li><p>修改配置文件</p>
<pre class="yaml"><code># 添加Hystrix熔断超时时间，要求熔断超时 &gt; ribbon 读取超时
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 700</code></code></pre></li>
<li><p>在启动类添加注解 <code>@EnableCircuitBreaker</code></p></li>
<li><p>修改 UserServiceImpl</p>
<pre class="java"><code>@Override
@HystrixCommand(fallbackMethod=&quot;getUserMapFallbackMethod&quot;)
public Map getUserMap() {
    long beginTime = System.currentTimeMillis();
    Map map = restTemplate.getForObject(url+&quot;/user/getall&quot;, Map.class);
    long endTime=System.currentTimeMillis();
    System.out.println(&quot;程序执行时间:&quot;+(endTime-beginTime));
    return map;
}

// 熔断超时，就会执行该方法
public Map&lt;String, Object&gt; getUserMapFallbackMethod() {
    Map map = new HashMap();
    map.put(&quot;list&quot;, new ArrayList&lt;&gt;());
    map.put(&quot;ProviderVersion&quot;, &quot;获取远程调用失败&quot;);
    return map;
}</code></code></pre></li>
<li><p>修改 UserProvider01，模拟超时情况</p>
<pre class="java"><code>    @GetMapping(&quot;/getall&quot;)
    @ApiOperation(value = &quot;获取全部用户信息&quot;, notes = &quot;获取全部用户信息&quot;)
    public Map&lt;String,Object&gt; getUsers() {
        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();
        List&lt;User&gt; list = userService.getUserList();
        map.put(&quot;list&quot;, list);
        map.put(&quot;ProviderVersion&quot;, ProviderVersion);
        // 模拟超时
        try {
            Thread.sleep(900);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return map;
    }</code></code></pre></li>
</ol>
<p>7.运行服务 <a href="http://localhost:9003/" class="uri">http://localhost:9003/</a></p>
<p><img src="./images/SpringCloud 基础15.png" alt="./images/SpringCloud 基础15.png" /></p>
<p><img src="./images/SpringCloud 基础16.png" alt="./images/SpringCloud 基础16.png" /></p>
<h3 id="feign使用hystrix">3. Feign使用Hystrix</h3>
<ol>
<li><p>pom 引入依赖</p>
<pre><code><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;</code></code></pre></li>
<li><p>Feign默认也有对Hystrix的集成，只不过，默认情况下是关闭的。我们需要通过下面的参数来开启，修改UserWeb04 模块的配置文件：</p>
<pre class="yaml"><code>feign:
  hystrix:
    enabled: true
#设定Hystrix熔断超时时间
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 700</code></code></pre></li>
<li><p>添加类 UserServiceImpl</p>
<pre class="java"><code>@Service
public class UserServiceImpl implements UserService {

    @Override
    public Map&lt;String, Object&gt; getUserMap() {
        Map map = new HashMap();
        map.put(&quot;list&quot;, new ArrayList&lt;&gt;());
        map.put(&quot;ProviderVersion&quot;, &quot;获取远程调用失败&quot;);
        return map;
    }

    @Override
    public void createUser(User user) {
        System.out.println(&quot;创建用户失败:&quot;+user);

    }

    @Override
    public User getUser(Long id) {
        System.out.println(&quot;获取id：&quot;+id+&quot; 的用户失败&quot;);
        return null;
    }

    @Override
    public void updateUser(Long id, User user) {
        System.out.println(&quot;更新id:&quot;+id+&quot;的用户失败&quot;);

    }

    @Override
    public void deleteUser(Long id) {
        System.out.println(&quot;删除id为:&quot;+id+&quot;的用户失败&quot;);

    }
}</code></code></pre></li>
<li><p>在 UserService中，使用注解@FeignClient声明熔断调用实现类 <code>@FeignClient(value = &quot;USERPROVIDER&quot;, configuration = FeignConfig.class, fallback = UserServiceImpl.class)</code>。熔断超时，就会到该指定类执行对应的方法。</p></li>
<li><p>运行服务 <a href="http://localhost:9004/" class="uri">http://localhost:9004/</a></p>
<p><img src="./images/SpringCloud 基础15.png" /></p></li>
</ol>
<h3 id="hystrix监控服务器">4. Hystrix监控服务器</h3>
<h4 id="搭建hystrix-dashboard管理控制中心">1. 搭建Hystrix Dashboard管理控制中心</h4>
<ol>
<li><p>新建子模块 hystrix-dashboard，编辑pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></code></pre></li>
<li><p>修改配置文件 application.yml</p>
<pre class="yaml"><code>spring:
  application:
    name: hystrix-dashboard
server:
  port: 1301</code></code></pre></li>
<li><p>启动类添加注解 <code>@EnableHystrixDashboard</code></p></li>
<li><p>运行服务 <a href="http://localhost:1301/hystrix" class="uri">http://localhost:1301/hystrix</a></p>
<p><img src="./images/SpringCloud 基础18.png" alt="./images/SpringCloud 基础18.png" /></p></li>
</ol>
<h4 id="启用客户端hystrix监控">2. 启用客户端Hystrix监控</h4>
<ol>
<li><p>pom 引入依赖</p>
<pre><code><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></code></pre></li>
<li><p>修改 UserWeb04 启动类，在服务实例的主类中已经使用@EnableCircuitBreaker或@EnableHystrix注解，开启断路器功能。同时增加监控路径访问地址定义/hystrix.stream可以访问。</p>
<pre class="java"><code>@SpringBootApplication
@EnableDiscoveryClient
// 开启伪装客户端
@EnableFeignClients
// 开启断路器功能
@EnableHystrix
public class Userweb04Application {

    public static void main(String[] args) {
        SpringApplication.run(Userweb04Application.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }

    @Bean
    public ServletRegistrationBean getServlet(){
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);  //系统启动时加载顺序
        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);//路径
        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
        return registrationBean;
    }
}</code></code></pre></li>
<li><p>启动服务，先执行请求后，然后查看 <a href="http://localhost:9004/hystrix.stream" class="uri">http://localhost:9004/hystrix.stream</a></p>
<p><img src="./images/SpringCloud 基础19.png" /></p></li>
<li><p>使用Hystrix Dashboard对Hystrix监控数据进行图形化监控。在Hystrix Dashboard的首页输入http://localhost:9004/hystrix.stream，点击“Monitor Stream”按钮。</p>
<p><img src="./images/SpringCloud 基础20.png" /></p></li>
</ol>
<h2 id="五分布式配置中心组件spring-cloud-config">五、分布式配置中心组件Spring Cloud Config</h2>
<h3 id="介绍-2">1. 介绍</h3>
<ul>
<li>在SpringBoot应用中，配置内容写在application.yml，也可以使用 application-{profile}.yml 的形式设置，但是在微服务架构中，配置文件的分散并不利于系统的管理和维护。</li>
<li>微服务对配置管理有更高的要求：
<ul>
<li>集中管理：服务需要集中管理配置，否则维护困难、容易出错。</li>
<li>运行期动态调整：某些参数需要在应用运行时动态调整，并且调整时不停止服务。</li>
<li>自动更新配置：微服务能够在配置发生变化是自动更新配置。</li>
</ul></li>
<li>Spring Cloud Config主要是为了分布式系统的外部配置提供了服务器端和客户端的支持，只要体现为Config Server和Config Client两部分。
<ul>
<li>Config Server: 是一个看横向扩展的，集中式的配置服务器，它用于集中管理应用程序各个环境下配置，默认使用Git存储配置内容。</li>
<li>Config Client: 是一个Config Server的客户端，用于操作存储在Config Server上的配置属性，所有微服务都指向Config Server，启动的时候会请求它获取所需要的配置属性，然后缓存这些属性以提高性能。</li>
</ul></li>
</ul>
<h3 id="构建config-server">2. 构建Config Server</h3>
<ol>
<li><p>新建子模块 ConfigServer001，修改pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></code></pre></li>
<li><p>修改配置文件 application.yml</p>
<pre class="yaml"><code>server:
  port: 7001

spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
        # 根据自己的情况进行配置
          uri: https://github.com/username/repositoryname
          search-paths: src/main/resources
          username: username
          password: password

eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka,http://localhost:10087/eureka</code></code></pre></li>
<li><p>修改UserProvide01的配置文件 application.yml 为 UserProvider01-test.yml 并上传，运行服务执行 <a href="http://localhost:7001/UserProvider01-test.yml" class="uri">http://localhost:7001/UserProvider01-test.yml</a></p>
<p><img src="./images/SpringCloud 基础21.png" /></p></li>
</ol>
<h3 id="构建config-client">3. 构建Config Client</h3>
<ol>
<li><p>将 UserProvider01、UserProvider02、UserWeb01、UserWeb02、UserWeb03、UserWeb04 的配置文件 application.yml 修改为 application-dev.yml 并上传到 git 远程仓库，项目本身的配置文件不修改，只是上传git的时候需要改名。</p></li>
<li><p>修改以上子模块</p></li>
<li><p>pom.xml 引入config</p>
<pre><code><code>&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
 &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;</code></code></pre></li>
<li><p>新建配置文件 bootstrap.yml</p>
<pre class="yaml"><code>spring:
  application:
  # 根据自己上传的 yml 文件来定
    name: UserProvider01
  cloud:
    config:
      discovery:
        enabled: true
        # 根据 configserver001 的 application.name 来定。 
        service-id: config-server
      #   根据自己上传的 yml 文件来定
      profile: dev
      label: master

eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka,http://localhost:10087/eureka</code></code></pre></li>
<li><p>将原有的 application.yml 清空，加上新的内容，可以在配置文件中的内容有改动的时候，不用重启服务，动态刷新，需要在相应的调用类上加新的注解 <code>@RefreshScope</code>。</p>
<pre class="yaml"><code>management:
  endpoints:
    web:
      exposure:
        include: refresh,health,info</code></code></pre></li>
<li><p>运行服务，然后启动任意一个客户端，查看运行情况</p>
<p><img src="./images/SpringCloud 基础22.png" alt="./images/SpringCloud 基础22.png" /></p></li>
</ol>
<p><img src="./images/SpringCloud 基础4.png" /></p>
<h2 id="六服务网关组件netflix-zuul">六、服务网关组件Netflix Zuul</h2>
<h3 id="介绍-3">1. 介绍</h3>
<ul>
<li>Zuul是Netflix开源的微服务网关，和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：
<ul>
<li>认证和安全 ：对每一个resource进行身份认证</li>
<li>追踪和监控 ：实时观察后端微服务的TPS、响应时间，失败数量等准确的信息</li>
<li>日志 ：记录所有请求的访问日志数据，可以为日志分析和查询提供统一支持</li>
<li>动态路由 ： 动态的将request路由到后端的服务上去</li>
<li>压力测试 ：逐渐的增加访问集群的压力，来测试集群的性能</li>
<li>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li>静态响应 ：直接在网关返回一些响应，而不是通过内部的服务返回响应</li>
</ul></li>
</ul>
<h3 id="zuul服务网关搭建">2.Zuul服务网关搭建</h3>
<ol>
<li><p>新建子模块 ZuulGateWay，修改 pom.xml</p>
<pre><code><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></code></pre></li>
<li><p>修改配置文件：application.yml</p>
<pre class="yaml"><code>spring:
  application:
    name: zull-gateway

server:
  port: 80

# 通过 url 直接映射
#zuul:
#  routes:
#    userprovider001:
#      # userprovider001 部分为路由的名字，可以任意定义，但是一组映射关系的path和url要相同
#      path: /userprovider001/**
#      url: http://localhost:8001/
#    userprovider002:
#      path: /userprovider002/**
#      url: http://localhost:8002/


# 通过 serviceId的映射方式支持了断路器，对于服务故障的情况下，可以有效的防止故障蔓延到服务网关上而影响整个系统的对外服务。
eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka,http://localhost:10087/eureka


zuul:
  routes:
    userprovider:
      path: /service/**
      service-id: USERPROVIDER
      # 就是将web中的配置 到zuul中 这样多个web都用熔断 仅需要写一次 而不必要每个web 都配置。
  retryable: true   #打开重试

ribbon:
  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
  ConnectionTimeOut: 250
  ReadTimeout: 1000
  OkToRetryOnAllOperations: true
  MaxAutoRetriesNextServer: 1
  MaxAutoRetries: 1

#设定Hystrix熔断超时时间
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000</code></code></pre></li>
<li><p>启动类</p>
<pre class="java"><code>@EnableZuulProxy
// 包含了 @SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker
@SpringCloudApplication
public class ZuulgatewayApplication {

    public static void main(String[] args) {
        SpringApplication.run(ZuulgatewayApplication.class, args);
    }
}</code></code></pre></li>
<li><p>Zuul服务网关过滤器</p>
<pre class="java"><code>public class AccessFilter extends ZuulFilter {

    /**
     * 四种不同生命周期
     * pre：可以在请求被路由之前调用
     * routing：在路由请求时候被调用
     * post：在routing和error过滤器之后被调用
     * error：处理请求时发生错误时被调用
     * @return
     */
    @Override
    public String filterType() {
        return &quot;pre&quot;;
    }

    /**
     * 过滤器的执行顺序
     * @return
     */
    @Override
    public int filterOrder() {
        return 0;
    }

    /**
     * 过滤器是否要执行
     * @return
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() throws ZuulException {
        RequestContext ctx= RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        String token = request.getParameter(&quot;accesstoken&quot;);
        if(token == null) {
            // 过滤该请求，不对其进行路由
            ctx.setSendZuulResponse(false);
            // 返回的错误码。也可以通过ctx.setResponseBody(body)对返回
            ctx.setResponseStatusCode(401);
            return null;
        }
        return null;
    }
}</code></code></pre></li>
<li><p>在启动类中实例化该过滤器</p>
<pre class="java"><code>@Bean
public AccessFilter accessFilter() {
    return new AccessFilter();
}</code></code></pre></li>
<li><p>启动服务，进行测试</p>
<ul>
<li><p><a href="http://localhost/userprovider/user/getall" class="uri">http://localhost/userprovider/user/getall</a></p>
<p><img src="./images/SpringCloud 基础24.png" alt="./images/SpringCloud 基础24.png" /></p></li>
<li><p><a href="http://localhost/userprovider/user/getall?accesstoken=token" class="uri">http://localhost/userprovider/user/getall?accesstoken=token</a></p>
<p><img src="./images/SpringCloud 基础25.png" alt="./images/SpringCloud 基础25.png" /></p></li>
</ul></li>
</ol>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>