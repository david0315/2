<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JAVA知识点总结篇（二）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JAVA知识点总结篇（二）</center></div><div class='banquan'>原文出处:本文由博客园博主村雨1943提供。<br/>
原文连接:https://www.cnblogs.com/cunyu1943/p/11605062.html</div><br>
    <blockquote>
<h3 id="数组">数组</h3>
</blockquote>
<h5 id="一维数组">一维数组</h5>
<ul>
<li>声明
<ul>
<li><code>数据类型[] 数组名；</code></li>
<li><code>数据类型 数组名[]；</code></li>
</ul></li>
<li>分配空间
<ul>
<li><code>数组名 = new 数据类型 [数组长度]；</code></li>
</ul></li>
<li>可以在声明的同时分配空间，分配空间之后数组中才能放数据，数组元素都是通过下标来访问，声明数组的同时赋值时不能指定数组长度；</li>
<li><p>foreach：<code>for(元素类型 元素变量：遍历对象){  执行的代码； }；</code></p>
<h5 id="二维数组">二维数组</h5></li>
<li>声明并分配空间：<code>数据类型[][]  数组名 = new 数据类型 [行的个数][列的个数]；</code><br />
<img src="./images/JAVA知识点总结篇（二）0.png" /></li>
<li><p>在定义二维数组时可以只指定行的个数，然后再为每一行分别指定列的个数，若每行列数不同，则创建的是不规则的二维数组；</p></li>
</ul>
<blockquote>
<h3 id="方法">方法</h3>
</blockquote>
<ul>
<li>定义语法：<code>访问修饰符 返回值类型 方法名(参数列表){  方法体； }；</code></li>
<li>分类：
<ul>
<li>无参无返回值方法；</li>
<li>无参带返回值方法；</li>
<li>带参无返回值方法；</li>
<li>带参带返回值方法；</li>
</ul></li>
<li>调用方法：<code>对象名.方法名()</code></li>
<li>调用带参方法时，必须保证实参的数量，类型，顺序和形参一一对应；</li>
<li>调用方法时，实参不需要指定数据类型；</li>
<li>方法的参数既可以是基本数据类型，也可以是引用数据类型，当有多个参数时，多个参数间以逗号分割；</li>
<li>重载：在同一个类中，方法名相同，方法参数个数、顺序或类型不同称为方法的重载，与方法的修饰符或返回值无关系；</li>
</ul>
<blockquote>
<h3 id="类与对象">类与对象</h3>
</blockquote>
<ul>
<li>类是模子，确定对象将拥有的特征(属性)和行为(方法)，特点：类是对象的类型，具有相同属性和方法的一组对象的集合；</li>
<li>定义类的步骤：
<ul>
<li>定义类名；</li>
<li>编写类的属性；</li>
<li>编写类的方法；</li>
</ul></li>
<li>使用对象的步骤：
<ul>
<li>创建对象：<code>类名 对象名 = new 类名()；</code></li>
<li>使用对象：<code>引用对象的属性：对象名.属性；</code></li>
</ul></li>
</ul>
<blockquote>
<h3 id="成员变量与局部变量">成员变量与局部变量</h3>
</blockquote>
<ul>
<li>成员变量：在类中定义，用来描述对象将要有什么，既可被本类的方法使用，还能供其他类的方法使用；</li>
<li>局部变量：在类的方法中定义，在方法中临时保存数据，只能在当前方法中使用；</li>
<li>区别：
<ul>
<li>局部变量作用域仅限于定义它的方法，成员变量的作用域在整个类内部都是可见的；</li>
<li>成员变量有初始值，但局部变量未赋予初始值；</li>
<li>不同方法中可以有同名局部变量，同一方法中，不允许有同名局部变量；</li>
<li>两者重名时，局部变量优先级更高；</li>
</ul></li>
</ul>
<blockquote>
<h3 id="构造方法">构造方法</h3>
</blockquote>
<ul>
<li>使用new+构造方法，创建一个新对象；</li>
<li>构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且无返回值；</li>
<li>当无指定构造方法时，系统会自动添加无参的构造方法；</li>
<li>当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法；</li>
<li>构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应方法；</li>
<li>构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值；</li>
</ul>
<blockquote>
<h3 id="static">static</h3>
</blockquote>
<ul>
<li>static修饰的成员称为静态成员或类成员，属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问，static可以修饰变量、方法和代码块；</li>
<li>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类别卸载才会进行资源回收；</li>
<li>static修饰的方法称为静态方法或类方法，静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员，如果想要在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量；</li>
</ul>
<pre><code><code>public class HelloWorld{
    String name = &quot;村雨&quot;;
    static String hobby = &quot;basketball&quot;;

    public static void print(){
        System.out.println(&quot;姓名&quot; + name);
        System.out.println(&quot;爱好&quot; + hobby);
    }
}</code></code></pre>
<p><img src="./images/JAVA知识点总结篇（二）1.png" /></p>
<ul>
<li>普通成员方法中，可以直接访问同类的非静态变量和静态变量；<br />
<img src="./images/JAVA知识点总结篇（二）2.png" /></li>
<li><p>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法；<br />
<img src="./images/JAVA知识点总结篇（二）3.png" /></p></li>
<li><p>静态初始化块只在类加载时执行，且只执行一次，同时静态初始化块只能给静态变量复制，不能初始化普通的成员变量；</p></li>
</ul>
<blockquote>
<h3 id="面向对象特点">面向对象特点</h3>
</blockquote>
<h4 id="封装">封装</h4>
<pre><code><code> - 概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问；
 - 好处：只能通过规定的方法访问数据，隐藏类的实例细节，方便修改和实现；
 - 实现步骤：
     - 修改属性可见性，设为private；
     - 创建getter/setter方法用于属性读写；
     - 在getter/setter方法中加入属性控制语句，对属性值的合法性进行判断；</code></code></pre>
<h4 id="继承">继承</h4>
<ul>
<li>Java中是单继承；</li>
<li>优点：
<ul>
<li>子类拥有父类的所有属性和方法；</li>
<li>实现代码复用；</li>
</ul></li>
<li>重写：返回值类型，方法名，参数类型及个数都要与父类继承的方法相同，才叫方法的重写；</li>
<li>继承的初始化顺序
<ul>
<li>初始化父类再初始化子类；</li>
<li>先执行初始化对象中属性，再执行构造方法中的初始化；</li>
</ul></li>
<li>final
<ul>
<li>修饰类，则该类不允许被继承；</li>
<li>修饰方法，则该方法不允许被覆盖(重写)；</li>
<li>修饰属性：则该类属性不会进行隐式初始化(类的初始化属性必须有值)活在构造方法中赋值(但只能选其一)；</li>
<li>修饰变量，则该变量的值只能赋一次值，即变为常量；</li>
</ul></li>
<li>super
<ul>
<li>子类构造过程中必须调用父类构造方法；</li>
<li>若子类构造方法中既没有显示调用父类构造方法，而父类有没有无参的构造方法，则编译出错；</li>
<li>若显式调用构造方法，必须在子类构造方法的第一行；</li>
<li>若子类构造方法中未显示调用父类的构造方法，则系统默认调用父类无参的构造方法；</li>
</ul></li>
<li>equals()方法：比较的是对象的引用是否指向同一块内存地址；</li>
</ul>
<h4 id="多态">多态</h4>
<ul>
<li>引用多态
<ul>
<li>父类引用可以指向本类对象；</li>
<li>父类引用可以指向子类对象；</li>
</ul></li>
<li>方法多态
<ul>
<li>创建本类对象时，调用的方法为本类方法；</li>
<li>创建子类对象时，调用的方法为子类重写的方法或者继承的方法；</li>
</ul></li>
<li>引用类型转换
<ul>
<li>向上类型转换(隐式/自动类型转换)，是小类型到大类型的转换，无风险；</li>
<li>向下类型转换(强制类型转换)，是大类型到小类型，存在风险；</li>
<li>instanceof运算符，用来解决引用对象的类型，避免类型转换的安全性问题；</li>
</ul></li>
</ul>
<blockquote>
<h3 id="包">包</h3>
</blockquote>
<ul>
<li>作用：
<ul>
<li>管理Java文件；</li>
<li>解决同名文件冲突；</li>
</ul></li>
<li>必须放在Java源程序的第一行，包名间可以使用<code>.</code>号隔开；</li>
<li>系统中的包
<ul>
<li>java.(功能).(类)</li>
<li>java.lang.(类) 包含Java语言基础的类；</li>
<li>java.util.(类) 包含Java语言中各种工具类；</li>
<li>java.io.(类) 包含输入、输出相关功能的类；</li>
</ul></li>
</ul>
<blockquote>
<h3 id="修饰符">修饰符</h3>
</blockquote>
<p><img src="./images/JAVA知识点总结篇（二）4.png" /></p>
<blockquote>
<h3 id="内部类">内部类</h3>
</blockquote>
<ul>
<li>定义：定义在另一个类里面的类，与之对应，包含内部类的类被称为外部类；</li>
<li>作用
<ul>
<li>提供更好的封装，可把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类；</li>
<li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据；</li>
<li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便；</li>
</ul></li>
<li>分类
<ul>
<li>成员内部类；</li>
<li>静态内部类；</li>
<li>方法内部类；</li>
<li>匿名内部类；</li>
</ul></li>
<li>调用方式</li>
</ul>
<pre><code><code>public class Test{

    public class Demo{

    }

    public static void main(String[] args) {
        Test test = new Test();
        Demo demo = test.new Demo();
    }
}</code></code></pre>
<pre><code><code>内部类 对象名 = 外部类对象.new 内部类();</code></code></pre>
<ul>
<li>内部类中方法可以直接访问外部类中的数据，而不受访问控制符的影响，但外部类是不能使用内部类的成员和方法；</li>
<li><p>若外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，若要访问外部类的成员变量，可以使用this关键字；<br />
<img src="./images/JAVA知识点总结篇（二）5.png" /></p></li>
<li>静态内部类
<ul>
<li>特点
<ul>
<li>静态内部类不能直接访问外部的非静态成员，通过<code>new 外部类().成员</code>的方式访问；</li>
<li>若外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员&quot;访问外部类的静态成员；若外部类的静态成员与内部类的成员名称不同，则可通过&quot;成员名&quot;直接调用外部类的静态成员；</li>
<li>创建静态内部类的对象时，不需要内部类的对象，可直接创建<code>内部类 对象名 = new 内部类();</code><br />
<img src="./images/JAVA知识点总结篇（二）6.png" /></li>
</ul></li>
</ul></li>
<li><p>方法内部类：内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只能在该方法中使用，由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制服和static修饰符；<br />
<img src="./images/JAVA知识点总结篇（二）7.png" /></p>
<blockquote>
<p>欢迎关注微信公众号：<strong>村雨1943</strong>；创作不易，未经同意，转载请注明出处~</p>
</blockquote></li>
</ul>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>