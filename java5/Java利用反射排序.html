<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java利用反射排序' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java利用反射排序</center></div><div class='banquan'>原文出处:本文由博客园博主听风逝夜blog提供。<br/>
原文连接:https://www.cnblogs.com/HouXinLin/p/11624236.html</div><br>
    <section data-role="outer" label="Powered by 135editor.com" style="font-size:16px;"><p style="text-align:center;" align="center"><span style="font-size: 18px;"><strong>前言</strong></span></p><p style="text-align:left;" align="left"><span style="font-size: 15px;"></span>Java为我们提供了几种排序得方法,比如Arrays和Collections类,但是前提是数组或者集合中的元素都必须实现Comparable接口，基本的数据类型都已经实现了Comparable接口了，所以我们才能够直接对基本类型的数组或者集合进行排序,比如Float和Integer类得源码.</p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序0.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序1.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">今天记录一下对Comparable得使用和反射得使用.</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">先看一个Student类<br></p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序2.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">我们要对他进行年龄排序,可以用冒泡进行排序,或者用选择排序法</p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序3.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">但是这不是主角,</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">而我们要用Comparable接口进行排序,所以先要实现它.并重写compareTo方法,这个方法才是用来比较对象的,也就是this和传入过来的obj进行比较,返回值代表:</p><p style="text-align:left;" align="left"><span style="caret-color: red;">&gt;0&nbsp; &nbsp; 则<span style="color: rgb(0, 0, 0); font-size: 16px; text-align: left; caret-color: rgb(255, 0, 0); display: inline !important; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">this&gt;obj,</span></span></p><p style="text-align:left;" align="left"><span style="caret-color: red;">=0 &nbsp;&nbsp;&nbsp;则this=obj</span></p><p style="text-align:left;" align="left"><span style="caret-color: red;">&lt;0&nbsp;&nbsp;&nbsp;&nbsp;则this&lt;obj</span></p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序4.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">其实我们可以这样简写一下,原理是一样的.</p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序5.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">如果想降序呢?直接在前面加一个负号呗</p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序6.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">直接调用Collections.sort(list)进行排序,是不是简单多了呢</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left"><span style="caret-color: red;">但是此时,Student多了个字段money,我们要多money进行排序,但是我们又想保留年龄排序方式,那么</span><span style="caret-color: red;">Comparable就不太合适了</span><br></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">Comparator</p><p style="text-align:left;" align="left">我们可以用Collections.sort第二个重载方法,他接收两个参数,第一个是要排序的集合,第二个是Comparator接口.</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">他和Comparable不同之处在于Comparable对内,而Comparator对外.原理也是一样.</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">其实Collections.sort的两个重载方法都是调用List的sort方法,但是如果list.sort想传null,则必须要求T(也就是这个类)必须实现了Comparable接口,不然他没办法排序.如果这个类不想实现Comparable接口,那就使用对外接口Comparator.</p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序7.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序8.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">写两个不同字段的排序方法.同样,如果想降序,前面加一个负号就可以</p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序9.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">但是!!!</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">此时又多了一个字段身高height,我们又想对height进行排序,那是不是又要写一个方法呢?显然必须要写,不写怎么排?但是往后越来越多的字段加入,这么做肯定不好.</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">那要怎么做?</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">先分析一下,这种方法排序无非就是获取某个字段的值,然后相减返回,那我们可以封装一下,利用反射获取某个类的字段值,先看代码.</p><p style="text-align:left;" align="left"><img src="./images/Java利用反射排序10.png" data-ratio="1" alt="image.png"></p><p style="text-align:left;" align="left">在此,声明了一个sort方法</p><p style="text-align:left;" align="left">参数list,代表要排序的集合,</p><p style="text-align:left;" align="left">参数fieldName,代表要排序的字段</p><p style="text-align:left;" align="left">参数isDesc,是否降序</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">访问private的字段首先要对field调用setAccessible(true),否则会报错.</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">因为这个字段可能是不同类型,所以统一先转成Double类型,之后调用intValue方法.</p><p style="text-align:left;" align="left"><br></p><p style="text-align:left;" align="left">怎么样,是不是很简单了呢?</p><section class="_135editor" data-tools="135编辑器" data-id="94155"><section style="text-align: center;" class=""><section style="display: inline-block;" class=""><p style="width:6em;"><img style="display: block;width: 100%;" src="./images/Java利用反射排序11.png" data-width="100%" data-ratio="0.9791666666666666"></p></section></section></section><p style="text-align:center;" align="center">流年有爱</p><p style="text-align:center;" align="center">岁月静好</p></section>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>