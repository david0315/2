<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JAVA如何实现中式排名和美式排名' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JAVA如何实现中式排名和美式排名</center></div><div class='banquan'>原文出处:本文由博客园博主小方村子提供。<br/>
原文连接:https://www.cnblogs.com/xiaofangcunzi/p/11691525.html</div><br>
    <p>根据公司需求，需要编写中式和美式排名算法，根据具体业务编写的，代码如下，看不懂留言，欢迎探讨，求高手指教更高效稳定的方法。<br />private static int[] datas = {9,9,10,10,9,8,4,3,3,3,3,3,4,3,44,2,2,2,2,1};</p>
<p>public static void main(String[] args) {<br />    Map&lt;String,String&gt; map = new HashMap&lt;&gt;();<br />    for(int i = 0; i &lt; 100; i ++){<br />        map.put(i + "",(int)(Math.random()*100)%3+",");<br />    }<br />   Map&lt;String,String&gt; map1 = orderByChPfSort(map);<br />    System.out.println("中式排名：");<br />    for(Map.Entry&lt;String,String&gt; entry : map1.entrySet()){<br />        System.out.println(entry.getKey() + ":" + entry.getValue());<br />    }<br />    System.out.println("美式排名：");<br />    Map&lt;String,String&gt; map2 = orderByPf(map);<br />    for(Map.Entry&lt;String,String&gt; entry : map2.entrySet()){<br />        System.out.println(entry.getKey() + ":" + entry.getValue());<br />    }<br />}</p>
<p>/**<br /> * 中式排名算法<br /> * @param map<br /> * @return<br /> */<br />private static Map&lt;String,String&gt; orderByChPfSort(Map&lt;String, String&gt; map){<br />    List&lt;Map.Entry&lt;String, String&gt;&gt; lists = new ArrayList&lt;&gt;(map.entrySet());<br />    //step1: 排序<br />    Collections.sort(lists, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() {<br />        @Override<br />        public int compare(Map.Entry&lt;String, String&gt; o1, Map.Entry&lt;String, String&gt; o2) {<br />            String value1 = o1.getValue();<br />            String value2 = o2.getValue();<br />            int length1 = value1.split(",").length;</p>
<p>            return Double.valueOf(value1.split(",")[length1-1]).compareTo(Double.parseDouble(value2.split(",")[length1-1]));<br />        }<br />    });</p>
<p>    //step2：先给第一个数第一名的位置，<br />    //step3：再将后面的数与前一个数进行对比，如果大就获取前一个数的排名再加1，如果等于，就去前一个的排名给后面数<br />    Map&lt;String,String&gt; dataSort = new HashMap&lt;&gt;();<br />    int i = 0;<br />    String firstValue = "";<br />    String firstKey = "";<br />    for(Map.Entry&lt;String, String&gt; entry : lists){<br />        String value2 = entry.getValue();<br />        int length2 = value2.split(",").length;<br />        if(i == 0){<br />            dataSort.put(entry.getKey(), value2 + 1 + ",");<br />        }else{<br />            if(Double.parseDouble(value2.split(",")[length2 - 1]) &gt; Double.parseDouble(firstValue.split(",")[length2-1])){<br />                dataSort.put(entry.getKey(),value2 + ((Integer.parseInt(dataSort.get(firstKey).split(",")[length2])) + 1) + ",");<br />            }else if((Double.parseDouble(value2.split(",")[length2 - 1]) == Double.parseDouble(firstValue.split(",")[length2-1]))){<br />                dataSort.put(entry.getKey(),value2 + (Integer.parseInt(dataSort.get(firstKey).split(",")[length2])) + ",");<br />            }<br />        }<br />        firstValue = value2;<br />        firstKey = entry.getKey();<br />        i++;<br />    }<br />    return dataSort;<br />}</p>
<p>/**<br /> * 评分美式排名方法<br /> *<br /> * @param map<br /> * @return<br /> */<br />private static Map&lt;String, String&gt; orderByPf(Map&lt;String, String&gt; map) {<br />    Map&lt;String, String&gt; zsPmMap = new TreeMap&lt;&gt;();<br />    //step1：遍历map<br />    for (Map.Entry&lt;String, String&gt; m : map.entrySet()) {<br />        int size = 1;<br />        String[] strsm = m.getValue().split(",");<br />        int lengthm = strsm.length;<br />        //step2：遍历map<br />        for (Map.Entry&lt;String, String&gt; m1 : map.entrySet()) {<br />            String[] strsm1 = m1.getValue().split(",");<br />            int lengthm1 = strsm1.length;<br />            //step3：将map中的每个值与其他值都对比一遍，如果有大于的就将排名数加1<br />            if (Double.parseDouble(strsm[lengthm - 1]) &gt; Double.parseDouble(strsm1[lengthm1 - 1])) {<br />                size++;<br />            }<br />        }<br />        String value = "";<br />        //step4：重新给value设置值<br />        for (int i = 0; i &lt;= lengthm - 1; i++) {<br />            value += (strsm[i] + ",");<br />            if (i == lengthm - 1) {<br />                value += (size + ",");<br />            }<br />        }<br />        //step5：将产生的包含排序值的数据重新添加到map中<br />        zsPmMap.put(m.getKey(), value);<br />    }<br />    return zsPmMap;<br />}</p>
<p>/**<br /> * 对数组进行中式拍寻<br /> */<br />private Map&lt;Integer,String&gt;  sortData(){<br />    //step1: 排序<br />    for(int i = 0; i &lt; datas.length; i ++){<br />        for(int j = 0; j &lt; datas.length; j ++){<br />            if(datas[i] &lt; datas[j]){<br />                int mid = datas[i];<br />                datas[i] = datas[j];<br />                datas[j] = mid;<br />            }<br />        }<br />    }<br />    //step2：先给第一个数第一名的位置，<br />    //step3：再将后面的数与前一个数进行对比，如果大就获取前一个数的排名再加1，如果等于，就去前一个的排名给后面数<br />    Map&lt;Integer,String&gt; dataSort = new HashMap&lt;&gt;();<br />    for(int i = 0; i &lt; datas.length ; i ++){<br />        if(i == 0){<br />            dataSort.put(i,datas[i] + "," + 1);<br />        }else{<br />            if(datas[i] &gt; datas[i-1]){<br />                dataSort.put(i,datas[i] + "," + (Integer.parseInt(dataSort.get(i-1).split(",")[1]) + 1));<br />            }else if(datas[i] == datas[i-1]){<br />                dataSort.put(i,datas[i] + "," + (Integer.parseInt(dataSort.get(i-1).split(",")[1])));<br />            }<br />        }<br />    }</p>
<p>    for (Map.Entry&lt;Integer,String&gt; entry : dataSort.entrySet()){<br />        System.out.print(entry.getKey() + ":" + entry.getValue());<br />        System.out.println();<br />    }<br />    return dataSort;<br />}<br /><br /></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>