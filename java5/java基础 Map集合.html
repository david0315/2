<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础 Map集合' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础 Map集合</center></div><div class='banquan'>原文出处:本文由博客园博主新兵蛋蛋程序员提供。<br/>
原文连接:https://www.cnblogs.com/0307lmy/p/11509958.html</div><br>
    <p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　集合</p>
<p>&nbsp;</p>
<p>集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下</p>
<p>&nbsp;</p>
<p>Collection<span style="font-family: 宋体;">接口是集合的根接口，没有蹄冻这个接口的直接实现类，但是却又其让其被继承的长</span> &nbsp;&nbsp;<span style="font-family: 宋体;">生的两个接口就是</span>set<span style="font-family: 宋体;">与</span><span style="font-family: 'Times New Roman';">list </span><span style="font-family: 宋体;">。</span><span style="font-family: 'Times New Roman';">Set</span><span style="font-family: 宋体;">中不能包含重复的元素。</span><span style="font-family: 'Times New Roman';">List</span><span style="font-family: 宋体;">是一个有序的集合</span></p>
<p>&nbsp;</p>
<p>List <span style="font-family: 宋体;">有序 &nbsp;可重复的</span></p>
<p>List<span style="font-family: 宋体;">里存放的对象是有序的，同时也是可以重复的，</span><span style="font-family: 'Times New Roman';">list</span></p>
<p>关注的是索引，拥有一系列和索引相关的方法，查询速度快</p>
<p>因为是会伴随这后面数据的移动，所有插入删除数据速度慢</p>
<p>&nbsp;</p>
<p>Set <span style="font-family: 宋体;">无序 不能重复</span></p>
<p>Set<span style="font-family: 宋体;">是无序的 不能重复的，集合中的对象不按特定的方式排序，只是简单的把对象加入</span> 集合中</p>
<p>&nbsp;</p>
<p>Arraylist <span style="font-family: 宋体;">和 </span><span style="font-family: 'Times New Roman';">linked list </span><span style="font-family: 宋体;">区别</span></p>
<p>&nbsp;</p>
<p>Arraylist<span style="font-family: 宋体;">与</span><span style="font-family: 'Times New Roman';">linkedlist</span><span style="font-family: 宋体;">在用法上没有区别，但是在功能上还是有区别的，</span><span style="font-family: 'Times New Roman';">linkedlist</span><span style="font-family: 宋体;">经常用</span> <span style="font-family: 宋体;">在增删操作较多而查询很少的情况下，</span>arraylist<span style="font-family: 宋体;">则相反</span></p>
<p>&nbsp;</p>
<p>Map &nbsp;&nbsp;<span style="font-family: 宋体;">是</span><span style="font-family: 'Times New Roman';">java</span><span style="font-family: 宋体;">。</span><span style="font-family: 'Times New Roman';">Util</span><span style="font-family: 宋体;">包中的另一个接口，它是</span><span style="font-family: 'Times New Roman';">collection</span><span style="font-family: 宋体;">接口没有关系，是互相独立的，但是都属于集合的一部分。</span><span style="font-family: 'Times New Roman';">Map</span><span style="font-family: 宋体;">包含了</span><span style="font-family: 'Times New Roman';">Key-value</span><span style="font-family: 宋体;">对，</span><span style="font-family: 'Times New Roman';">map</span><span style="font-family: 宋体;">不能包含重复的</span><span style="font-family: 'Times New Roman';">key</span><span style="font-family: 宋体;">，但是可以包含相同的</span><span style="font-family: 'Times New Roman';">value</span></p>
<p>&nbsp;</p>
<p>Map <span style="font-family: 宋体;">键值对 建唯一 &nbsp;值不唯一</span></p>
<p>Map<span style="font-family: 宋体;">集合中存储的是键值对，建不能重复，值可以重复，根据建得到值，对</span><span style="font-family: 'Times New Roman';">map</span><span style="font-family: 宋体;">集合遍历时先得到建的</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">集合，对</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">集合进行遍历，得到相应的值</span></p>
<p>&nbsp;</p>
<p>Map<span style="font-family: 宋体;">集合</span></p>
<p><span style="font-family: 宋体;">实现类：</span>HashMap &nbsp;&nbsp;Hashtable &nbsp;LinkedHashMao <span style="font-family: 宋体;">与 </span><span style="font-family: 'Times New Roman';">TreeMap</span></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;HashMap<span style="font-family: 宋体;">类</span></p>
<p>HashMap<span style="font-family: 宋体;">类是最常见的</span><span style="font-family: 'Times New Roman';">map</span><span style="font-family: 宋体;">集合，他是根据建得</span><span style="font-family: 'Times New Roman';">HashCode</span><span style="font-family: 宋体;">存储数据的，根据建可以直</span> 获取它的值，具有很快的访问速度，在遍历的时候，获取数据的顺序是完全随机的，因 <span style="font-family: 宋体;">为建不可以重复，所以</span>HashMap<span style="font-family: 宋体;">最多只允许一条记录为</span><span style="font-family: 'Times New Roman';">mull</span><span style="font-family: 宋体;">，允许多条记录的值为</span><span style="font-family: 'Times New Roman';">Null</span></p>
<p>是不同步的</p>
<p>&nbsp;&nbsp;Hashtable <span style="font-family: 宋体;">类</span></p>
<p>Hashtable <span style="font-family: 宋体;">与 </span><span style="font-family: 'Times New Roman';">HashMap</span><span style="font-family: 宋体;">类似，是</span><span style="font-family: 'Times New Roman';">HashMap</span><span style="font-family: 宋体;">的线程安全版，他支持线程的同步，即任意</span> <span style="font-family: 宋体;">时刻只有一个线程写</span>Hashtable<span style="font-family: 宋体;">，因此也导致了</span><span style="font-family: 'Times New Roman';">Hashtable</span><span style="font-family: 宋体;">在写入的时候会比较慢，他继</span> <span style="font-family: 宋体;">承自</span>Dictionary<span style="font-family: 宋体;">类，不同的是它不允许记录的键或者值为</span><span style="font-family: 'Times New Roman';">null</span><span style="font-family: 宋体;">，同时效率较低。</span></p>
<p>&nbsp;&nbsp;ConcurrentHashMap <span style="font-family: 宋体;">类</span></p>
<p><span style="font-family: 宋体;">线程安全的，并且是锁分离。</span>ConcurrentHashMap <span style="font-family: 宋体;">内部使用段（</span><span style="font-family: 'Times New Roman';">Segment</span><span style="font-family: 宋体;">）来表示这些</span> <span style="font-family: 宋体;">不同的部分，每个段其实就是一个小时的</span>hash &nbsp;table <span style="font-family: 宋体;">他们有自己的锁，只要修改多个</span> 操作发生在不同的段上，他们就可以并发进行。</p>
<p>&nbsp;&nbsp;LinkedHashMap &nbsp;<span style="font-family: 宋体;">类</span></p>
<p>LinkedHashMap<span style="font-family: 宋体;">保存了记录的插入顺序，用在</span><span style="font-family: 'Times New Roman';">lteraor</span><span style="font-family: 宋体;">遍历</span><span style="font-family: 'Times New Roman';">linkedHash</span></p>
<p>Map<span style="font-family: 宋体;">时先得到记录肯定是先插入的，在比遍历的时候会比</span><span style="font-family: 'Times New Roman';">HashMap</span><span style="font-family: 宋体;">慢，有</span><span style="font-family: 'Times New Roman';">HashMap</span><span style="font-family: 宋体;">的</span> 全部特征。</p>
<p>&nbsp;&nbsp;TreeMap <span style="font-family: 宋体;">类</span></p>
<p>TreeMap<span style="font-family: 宋体;">实现</span><span style="font-family: 'Times New Roman';">SortMap</span><span style="font-family: 宋体;">接口，能狗把他保存的记录根据建排序，默认是按键值的升序</span> <span style="font-family: 宋体;">序（自然排序），也可以指定排序的比较器，当用</span>lierator <span style="font-family: 宋体;">遍历</span><span style="font-family: 'Times New Roman';">TreeMap</span><span style="font-family: 宋体;">，得到的记录时</span> <span style="font-family: 宋体;">排过序的，不允许</span>key<span style="font-family: 宋体;">值为空</span></p>
<p>Map<span style="font-family: 宋体;">的遍历</span></p>
<p>&nbsp;</p>
<p>KeySet()</p>
<p><span style="font-family: 宋体;">将</span>map<span style="font-family: 宋体;">中所有的建存入</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">集合中，，因为</span><span style="font-family: 'Times New Roman';">set</span></p>
<p><span style="font-family: 宋体;">具备迭代器，所有可以迭代方式取出所有的建，再根据</span>get<span style="font-family: 宋体;">方法，获取每一个建对应的</span> <span style="font-family: 宋体;">值。</span>Keyset<span style="font-family: 宋体;">（）；迭代后只能通过</span><span style="font-family: 'Times New Roman';">gat</span><span style="font-family: 宋体;">（）获取</span><span style="font-family: 'Times New Roman';">key</span><span style="font-family: 宋体;">。</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family: 宋体;">取到的结果会乱序，因为取得数据行主键的时候，使用了</span>HashMap.keyset()<span style="font-family: 宋体;">方法，而这</span> <span style="font-family: 宋体;">个防范返回的</span>set<span style="font-family: 宋体;">结果，里面的数据是乱序排放的。</span></p>
<p>用法：</p>
<p>Map &nbsp;map &nbsp;= new HashMap();</p>
<p>Map.put(&ldquo;key1&rdquo;&nbsp;, &rdquo;lisi1&rdquo;);</p>
<p>Map.put(&ldquo;key2&rdquo;&nbsp;, &rdquo;lisi2&rdquo;);</p>
<p>Map.put(&ldquo;key3&rdquo;&nbsp;, &rdquo;lisi3&rdquo;);</p>
<p>Map.put(&ldquo;key4&rdquo;&nbsp;, &rdquo;lisi4&rdquo;);</p>
<p>//<span style="font-family: 宋体;">先获取</span><span style="font-family: 'Times New Roman';">mao</span><span style="font-family: 宋体;">集合的所有键的</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">集合，</span><span style="font-family: 'Times New Roman';">keyset()</span></p>
<p>Lterator it &nbsp;= &nbsp;map.keyset().iterator();</p>
<p>//<span style="font-family: 宋体;">获取迭代器</span></p>
<p>While(it.hasNext()){</p>
<p>&nbsp;&nbsp;Object key =it.next();</p>
<p>&nbsp;&nbsp;System.out.println(map.get(key));</p>
<p>}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;entrySet()</p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet() &nbsp;//<span style="font-family: 宋体;">返回此映射中包含的映射关系的</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">视图。（一个关系</span> <span style="font-family: 宋体;">就是一个建</span>-<span style="font-family: 宋体;">值对），就是把（</span><span style="font-family: 'Times New Roman';">key-value</span><span style="font-family: 宋体;">）作为一个整体一对一地存放到</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">集合中。</span> Map.entry<span style="font-family: 宋体;">表示映射关系。</span><span style="font-family: 'Times New Roman';">Entryset(); </span><span style="font-family: 宋体;">迭代后可以</span><span style="font-family: 'Times New Roman';">e.getKey(). e.getValur()</span><span style="font-family: 宋体;">两种方法来取</span> key<span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">value</span><span style="font-family: 宋体;">。返回的是</span><span style="font-family: 'Times New Roman';">entry</span><span style="font-family: 宋体;">接口；</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="font-family: 宋体;">用法：</span></p>
<p>Map &nbsp;map &nbsp;= new HashMap();</p>
<p>Map.put(&ldquo;key1&rdquo;&nbsp;, &rdquo;lisi1&rdquo;);</p>
<p>Map.put(&ldquo;key2&rdquo;&nbsp;, &rdquo;lisi2&rdquo;);</p>
<p>Map.put(&ldquo;key3&rdquo;&nbsp;, &rdquo;lisi3&rdquo;);</p>
<p>Map.put(&ldquo;key4&rdquo;&nbsp;, &rdquo;lisi4&rdquo;);</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">将</span><span style="font-family: 'Times New Roman';">map</span><span style="font-family: 宋体;">集合中的映射关系取出，存入到</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">集合</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lterator it = map.entrySet().iterator();</p>
<p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;While(it.hasNext){</p>
<p>Entry e = (Entry)it.next();</p>
<p>System.out.println(&ldquo;键&rdquo;+e.gatKey()+&rdquo;的值为&rdquo;+e.getValue);</p>
<p>}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: 宋体;">推荐使用第二种方法，及</span>entryset()<span style="font-family: 宋体;">方法，效率高。</span></p>
<p>&nbsp;Lterator <span style="font-family: 宋体;">类所有的集合类，都实现了</span><span style="font-family: 'Times New Roman';">lterator</span><span style="font-family: 宋体;">接口，这是一个用于遍历集合中的接口，在只要包</span> &nbsp;&nbsp;<span style="font-family: 宋体;">含下面的三种方法</span></p>
<p>HasNext()<span style="font-family: 宋体;">是否还有下一个元素。</span></p>
<p>Next() <span style="font-family: 宋体;">放回下一个元素</span></p>
<p>Remove() <span style="font-family: 宋体;">删除当前元素</span></p>
<p>Lteror<span style="font-family: 宋体;">：迭代输出，时使用最多的输出方式。</span></p>
<p>Listiterator <span style="font-family: 宋体;">是</span><span style="font-family: 'Times New Roman';">lterator</span><span style="font-family: 宋体;">的子接口，专门用于输出</span><span style="font-family: 'Times New Roman';">list</span><span style="font-family: 宋体;">中的内容。</span></p>
<p>Foreach<span style="font-family: 宋体;">输出，</span><span style="font-family: 'Times New Roman';">jdk1.5</span><span style="font-family: 宋体;">之后提供的新功能，可以输出数组或集合。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Vector <span style="font-family: 宋体;">与 </span><span style="font-family: 'Times New Roman';">ArrayList</span></p>
<p>1，&nbsp;Vector<span style="font-family: 宋体;">是线程同步的，所有他是安全的，而</span><span style="font-family: 'Times New Roman';">arraylist</span><span style="font-family: 宋体;">是线程异步的，是不安全的 如果我</span> &nbsp;<span style="font-family: 宋体;">们不考虑到这个线程安全的因素的问题的话，一般用</span>arraylist<span style="font-family: 宋体;">效率比较高</span></p>
<p>2，&nbsp;<span style="font-family: 宋体;">如果考虑到集合中的元素的数目大于目前聚合数组的长度时，</span>vector<span style="font-family: 宋体;">增长率为目前数组</span> <span style="font-family: 宋体;">长度的</span>100<span style="font-family: 宋体;">％而</span><span style="font-family: 'Times New Roman';">arraylist</span><span style="font-family: 宋体;">增长率为目前数组长度的</span><span style="font-family: 'Times New Roman';">50</span><span style="font-family: 宋体;">％，如果在集合中使用数据量比较</span> <span style="font-family: 宋体;">大的数据，用</span>vector<span style="font-family: 宋体;">有一定的优势。</span></p>
<p>3，&nbsp;<span style="font-family: 宋体;">查找一个指定数据或者频繁的访问数据</span> <span style="font-family: 宋体;">这个时候</span>Vector<span style="font-family: 宋体;">与</span><span style="font-family: 'Times New Roman';">arraylist</span><span style="font-family: 宋体;">都可以 &nbsp;</span><span style="font-family: 'Times New Roman';">Vector</span></p>
<p>&nbsp; <span style="font-family: 宋体;">使用了</span>synchronized<span style="font-family: 宋体;">方法 线程安全，所以性能上要比</span><span style="font-family: 'Times New Roman';">arraylist</span><span style="font-family: 宋体;">要差，</span><span style="font-family: 'Times New Roman';">linkedlist</span><span style="font-family: 宋体;">使用双向</span> 链表实现存储，所以插入数据比较快</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>Arraylist <span style="font-family: 宋体;">和 </span><span style="font-family: 'Times New Roman';">linkedlist</span></p>
<p>1，&nbsp;&nbsp;&nbsp;&nbsp;Arraylist<span style="font-family: 宋体;">是实现了基于鼎泰数组的数据结构，</span><span style="font-family: 'Times New Roman';">linkedlist</span><span style="font-family: 宋体;">是基于链表的数据结构</span></p>
<p>2，&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: 宋体;">对于随机访问</span>get<span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">set</span><span style="font-family: 宋体;">，</span><span style="font-family: 'Times New Roman';">Arraylist</span><span style="font-family: 宋体;">觉得优于</span><span style="font-family: 'Times New Roman';">linkedlist</span><span style="font-family: 宋体;">，因为</span><span style="font-family: 'Times New Roman';">linkedlist</span><span style="font-family: 宋体;">要移动指针</span></p>
<p>3，&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: 宋体;">对于新增和删除操作</span>add<span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">remove</span><span style="font-family: 宋体;">，</span><span style="font-family: 'Times New Roman';">linedlistbi'jiao</span><span style="font-family: 宋体;">比较占优势，因为</span><span style="font-family: 'Times New Roman';">arraylist</span><span style="font-family: 宋体;">要移动数</span> <span style="font-family: 宋体;">据，这一点要看实际情况，若只对单条数据插入或删除，</span>arraylist<span style="font-family: 宋体;">的速度而优于</span><span style="font-family: 'Times New Roman';">linkedlist</span></p>
<p><span style="font-family: 宋体;">但若是批量随机的插入删除数据，</span>linkedlist<span style="font-family: 宋体;">的速度要大于</span><span style="font-family: 'Times New Roman';">arraylist</span><span style="font-family: 宋体;">每插入一条数据要移</span> 动插入点及之后的所有数据</p>
<p>&nbsp;</p>
<p>Hashmap<span style="font-family: 宋体;">与</span><span style="font-family: 'Times New Roman';">treemap</span></p>
<p>1，&nbsp;Hashmap<span style="font-family: 宋体;">通过</span><span style="font-family: 'Times New Roman';">hashcode</span><span style="font-family: 宋体;">对其内容进行快速查找，而</span><span style="font-family: 'Times New Roman';">treemap</span><span style="font-family: 宋体;">中所有的元素都保持这某种</span> <span style="font-family: 宋体;">固定的顺序，如果你需要得到一个有序的就应该使用</span>treemap<span style="font-family: 宋体;">，</span><span style="font-family: 'Times New Roman';">hashmap</span><span style="font-family: 宋体;">是无序的</span></p>
<p>2，&nbsp;<span style="font-family: 宋体;">在</span>map<span style="font-family: 宋体;">中插入，删除和定位元素，</span><span style="font-family: 'Times New Roman';">hashmap</span><span style="font-family: 宋体;">是最好的选择，但如果您要按自然顺序或自</span> <span style="font-family: 宋体;">定义顺序遍历键，那么</span>treemap<span style="font-family: 宋体;">会更好，使用</span><span style="font-family: 'Times New Roman';">hashmap</span><span style="font-family: 宋体;">要求添加的键类声明确定定义了</span> hashcode()<span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">equals();</span></p>
<p>3，&nbsp;<span style="font-family: 宋体;">两个</span>map<span style="font-family: 宋体;">中的元素一样，但是顺序不一样，导致</span><span style="font-family: 'Times New Roman';">hashcode()</span><span style="font-family: 宋体;">不一样。</span></p>
<p>测试：</p>
<p><span style="font-family: 宋体;">在</span>hashmap<span style="font-family: 宋体;">中，同样的值</span><span style="font-family: 'Times New Roman';">map</span><span style="font-family: 宋体;">顺序不同，</span><span style="font-family: 'Times New Roman';">equals</span><span style="font-family: 宋体;">时 </span><span style="font-family: 'Times New Roman';">false</span><span style="font-family: 宋体;">；</span></p>
<p><span style="font-family: 宋体;">在</span>treemap<span style="font-family: 宋体;">中，同样的值</span><span style="font-family: 'Times New Roman';">map</span><span style="font-family: 宋体;">，顺序不同，</span><span style="font-family: 'Times New Roman';">equals</span><span style="font-family: 宋体;">时，</span><span style="font-family: 'Times New Roman';">true</span><span style="font-family: 宋体;">，说明，</span><span style="font-family: 'Times New Roman';">treemap</span><span style="font-family: 宋体;">在</span><span style="font-family: 'Times New Roman';">equals</span><span style="font-family: 宋体;">（）</span> 时时整理了顺序了的。</p>
<p>&nbsp;</p>
<p>Hashtable<span style="font-family: 宋体;">线程与</span><span style="font-family: 'Times New Roman';">hashmap</span></p>
<p>1，&nbsp;<span style="font-family: 宋体;">同步性：</span>hashtable<span style="font-family: 宋体;">时线程安全的，也就是说时同步的，而</span><span style="font-family: 'Times New Roman';">hashmap</span><span style="font-family: 宋体;">是线程不安全的，不</span> 是同步的。</p>
<p>2，&nbsp;Hashmap<span style="font-family: 宋体;">允许存在一个为</span><span style="font-family: 'Times New Roman';">nulll</span><span style="font-family: 宋体;">的</span><span style="font-family: 'Times New Roman';">key</span><span style="font-family: 宋体;">，多个为</span><span style="font-family: 'Times New Roman';">null</span><span style="font-family: 宋体;">的</span><span style="font-family: 'Times New Roman';">value</span></p>
<p>3，&nbsp;Hashtable<span style="font-family: 宋体;">的</span><span style="font-family: 'Times New Roman';">key</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">value</span><span style="font-family: 宋体;">都不允许为</span><span style="font-family: 'Times New Roman';">null；</span><span style="font-family: 宋体;"><br /></span></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>