<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JAVA 8 的新特性' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JAVA 8 的新特性</center></div><div class='banquan'>原文出处:本文由博客园博主十五小哥哥提供。<br/>
原文连接:https://www.cnblogs.com/wanghj-15/p/11462056.html</div><br>
    <p class="25"><span style="font-size: 18px;"><strong>Java8<span style="font-family: 宋体;">的新特性有：</span></strong></span><strong><span style="font-family: 宋体;">默认方法、函数式接口、</span>lambda<span style="font-family: 宋体;">表达式、方法引用、</span><span style="font-family: Courier New;">Stream</span><span style="font-family: 宋体;">、</span><span style="font-family: Courier New;">Optional</span><span style="font-family: 宋体;">、日期</span><span style="font-family: Courier New;">API</span><span style="font-family: 宋体;">。</span></strong></p>
<p><span style="font-size: 14pt;"><strong><span style="font-family: 宋体;">　一、</span></strong><strong><span style="font-family: 宋体;">默认方法：</span></strong></span></p>
<p><span style="font-size: 14pt;"><strong><span style="font-family: 宋体;">　　</span></strong></span><span style="font-family: Microsoft YaHei UI;">接口中的方法可以有方法体</span><span style="font-family: Microsoft YaHei UI;">，</span><span style="font-family: Microsoft YaHei UI;">但是必须要有</span>static或者default修饰<span style="font-family: Microsoft YaHei UI;">，</span><span style="font-family: Microsoft YaHei UI;">其他的方法都为抽象方法</span><span style="font-family: Microsoft YaHei UI;">，</span><span style="font-family: Microsoft YaHei UI;">由</span>static修饰的方法不能被子接口继承 <span style="font-family: Microsoft YaHei UI;">、</span><span style="font-family: Microsoft YaHei UI;">方法不能被覆写</span><span style="font-family: Microsoft YaHei UI;">，</span><span style="font-family: Microsoft YaHei UI;">只能通过类名</span>.方法名调用<span style="font-family: Microsoft YaHei UI;">；</span><span style="font-family: Microsoft YaHei UI;">由</span>default修饰的方法可以被子接口继承<span style="font-family: Microsoft YaHei UI;">，</span><span style="font-family: Microsoft YaHei UI;">也可以被覆写</span><span style="font-family: Microsoft YaHei UI;">，</span><span style="font-family: Microsoft YaHei UI;">调用通过实现类的对象调用</span><span style="font-family: Microsoft YaHei UI;">。</span></p>
<p><span style="font-size: 14pt;"><strong><span style="font-family: 宋体;">二、</span></strong><strong><span style="font-family: 宋体;">函数式接口：</span></strong></span></p>
<p><span style="font-size: 14pt;"><strong><span style="font-family: 宋体;">　　</span></strong></span><span style="font-family: Microsoft YaHei UI;">接口中有且仅有一个抽象方法</span>,一般都有@FuntionalInterface注解<span style="font-family: 宋体;">，即使没有注解它还是函数式接口。</span></p>
<p><span style="font-family: Microsoft YaHei UI;">常见的函数式接口</span><span style="font-family: Microsoft YaHei UI;">：</span>Comparetor<span style="font-family: Microsoft YaHei UI;">、</span>Runnable。</p>
<p class="25"><span style="font-size: 14pt;"><strong><span style="font-family: 宋体;">三、</span>lambda<span style="font-family: 宋体;">表达式：</span></strong></span></p>
<p class="25"><span style="font-size: 14pt;"><strong><span style="font-family: 宋体;">　　</span></strong></span><span style="font-family: 宋体;">可以看成是</span><span style="font-family: 宋体;">对</span><span style="font-family: 宋体;">匿名内部类</span><span style="font-family: 宋体;">的简写</span><span style="font-family: 宋体;">，</span><span style="font-family: Microsoft YaHei UI;">使用</span>lambda表达式的接口必须为函数式接口<span style="font-family: Microsoft YaHei UI;">；</span></p>
<p class="25"><span style="font-family: 宋体;">　　　　注：匿名内部类会编译产生两个</span>class<span style="font-family: 宋体;">文件，但</span><span style="font-family: Courier New;">lambda</span><span style="font-family: 宋体;">表达式只会编译产生一个</span><span style="font-family: Courier New;">class</span><span style="font-family: 宋体;">文件。</span></p>
<p class="25"><span style="font-family: 宋体;"><img src="./images/JAVA 8 的新特性0.png" alt="" /></span></p>
<p class="25">&nbsp;</p>
<p>　　　　(参数1，参数2&hellip;)表示参数列表；-&gt;表示连接符；{}内部是方法体 <br />	　　　　1、=右边的类型会根据左边的函数式接口类型自动推断； <br />	　　　　2、如果形参列表为空，只需保留()； <br />	　　　　3、如果形参只有1个，()可以省略，只需要参数的名称即可； <br />	　　　　4、如果执行语句只有1句，且无返回值，{}可以省略，若有返回值，则若想省去{}，则必须同时省略return，且执行语句也保证只有1句； <br />	　　　　5、形参列表的数据类型会自动推断；</p>
<p>　　　　6<span style="font-family: 宋体;">、</span><span style="color: #ff00ff;">lambda<span style="font-family: 宋体;">表达式中使用的局部变量默认会被</span><span style="font-family: Times New Roman;">final</span><span style="font-family: 宋体;">修饰</span><span style="font-family: Times New Roman;">,</span><span style="font-family: 宋体;">不管这个局部变量是在</span><span style="font-family: Times New Roman;">lamdba</span><span style="font-family: 宋体;">表达式里定义的还是在表达式外定义的。</span><span style="color: #339966;"><span style="font-family: 宋体;">因此只要是</span>lambda<span style="font-family: 宋体;">表达式中使用过的局部变量就不能再修改了，不管在什么位置</span><span style="font-family: 宋体;">。</span></span></span></p>
<p class="25"><strong>&nbsp;</strong></p>
<p class="25"><span style="font-size: 14pt;"><strong>四、<span style="font-family: 宋体;">方法引用：</span></strong></span></p>
<p class="25"><strong>　　　　4.1 <span style="font-family: 宋体;">构造方法引用：</span></strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">匿名内部类</span>
PersonFacotry facotry = <span style="color: #0000ff;">new</span><span style="color: #000000;"> PersonFacotry() {
　　@override
　　</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Person createPerson(String name, Integer age){ 
　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">其他操作</span>
　　　　<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person (name, age);
　　}
}；
</span><span style="color: #008000;">//</span><span style="color: #008000;">lambda表达式写法</span>
PersonFacotry facotry1 = (name, age) -&gt; <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person (name, age);

</span><span style="color: #008000;">//</span><span style="color: #008000;">lambda表达式简写（这种写法的函数式接口有几个参数,就调用其对应参数个数的构造方法）</span>
PersonFacotry facotry2 = Person:: <span style="color: #0000ff;">new</span><span style="color: #000000;">;

Person person </span>= facotry.createPerson ( name: "某某某", age: 100<span style="color: #000000;">) ;
System.out.println(person);</span></code></pre>

<p class="25"><strong>　　　　</strong></p>
<p class="25"><strong>　　　　4.2<span style="font-family: 宋体;">静态方法引用</span></strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(string[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名内部类方式</span>
        Parseinterface pil = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ParseInterface(){ 
            @override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> parse(string str) {
                 </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Integer.parselnt(str);
            }
        };

         </span><span style="color: #008000;">//</span><span style="color: #008000;"> Lambda表达式常规写法</span>
         ParseInterface pi2 = str-&gt;<span style="color: #000000;">Integer.parseInt(str);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Lambda表达式简写</span>
        ParseInterface pi3 =<span style="color: #000000;"> Integer::parseInt;   
    }
}     </span></code></pre>

<p>&nbsp;</p>
<p class="25"><strong>　　　　4.3<span style="font-family: 宋体;">实例方法引用</span></strong></p>
<p>　　Java1.8<span style="font-family: 宋体;">提供了一个函数式接口</span><span style="font-family: Times New Roman;">Function</span><span style="font-family: 宋体;">，接受两个参数</span></p>
<p><span style="font-family: 宋体;"><img src="./images/JAVA 8 的新特性1.png" alt="" /></span></p>
<p>&nbsp;</p>
<p>&nbsp;　　<span style="font-family: 宋体;">匿名内部类方式</span></p>
<src class="cnblogs_code">
<pre><code>    string str ="Hello.world"<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名内部类的方式</span>
    Function&lt;String,Boolean&gt; func1= <span style="color: #0000ff;">new</span> Function&lt;String,Boolean&gt;<span style="color: #000000;"> (){
        @override
        </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Boolean apply(strinq suffix) {
             </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str.endswith (suffix);
        }
    };    </span></code></pre>

<p>&nbsp;</p>
<p>　　Lambda<span style="font-family: 宋体;">表达式常规写法</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Lambda表达式常规写法</span>
String str = "Hello.world"<span style="color: #000000;">;
Function</span>&lt;String,Boolean&gt; func3 = t -&gt;<span style="color: #000000;"> str.endsWith(t);
System.out.println(func3.apply(</span>"world"));</code></pre>

<p>&nbsp;</p>
<p>　　Lambda<span style="font-family: 宋体;">表达式简写</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> Lambda表达式常规写法</span>
String str = "Hello.world"<span style="color: #000000;">;
Function</span>&lt;String,Boolean&gt; func2 = t -&gt;<span style="color: #000000;"> str::endsWith;
System.out.println(func2.apply(</span>"world"));</code></pre>

<p>&nbsp;</p>
<p class="25"><strong><span style="font-size: 14pt;">五、Stream<span style="font-family: 宋体;">：</span></span></strong></p>
<p class="25">　　　　Java 8 API<span style="font-family: 宋体;">添加了一个新的抽象称为流</span><span style="font-family: Courier New;">Stream</span><span style="font-family: 宋体;">，</span><span style="font-family: Courier New;">Stream API</span><span style="font-family: 宋体;">可以极大提高</span><span style="font-family: Courier New;">Java</span><span style="font-family: 宋体;">程序员的生产力，让程序员写出</span><span style="font-family: 宋体;"><span style="color: #ff00ff;">高效率、干净、简洁</span>的代码</span><span style="font-family: 宋体;">。</span></p>
<p class="25"><strong><span style="font-family: 宋体;">　　　　　　<span style="color: #3366ff;">注意：</span></span></strong><span style="color: #3366ff;"><span style="font-family: 宋体;">和</span>IO<span style="font-family: 宋体;">中的流是完全不一样的。</span></span></p>
<p class="25"><span style="font-family: 宋体;">　　　　在</span> Java 8 <span style="font-family: 宋体;">中</span><span style="font-family: Courier New;">, </span><span style="font-family: 宋体;">集合接口有两个方法来生成流：</span></p>
<p class="25">　　　<span style="color: #ff00ff;">　　　stream() <span style="font-family: Times New Roman;">&minus; </span><span style="font-family: 宋体;">为集合创建串行流。</span><span style="font-family: 宋体;">（</span><span style="font-family: 宋体;">常用</span><span style="font-family: 宋体;">）</span></span></p>
<p class="25"><span style="color: #ff00ff;">　　　　　　parallelStream() <span style="font-family: Times New Roman;">&minus; </span><span style="font-family: 宋体;">为集合创建并行流。</span></span></p>
<p class="25"><strong>　　</strong><span style="font-size: 18px;"><strong>Stream<span style="font-family: 宋体;">常用方法：</span></strong></span></p>
<p class="25"><strong>　　ForEach:</strong></p>
<p class="p">　　　　　　Stream <span style="font-family: 宋体;">提供了新的方法 </span><span style="font-family: Helvetica;">'forEach' </span><span style="font-family: 宋体;">来迭代流中的每个数据。以下代码片段使用 </span><span style="font-family: Helvetica;">forEach </span><span style="font-family: 宋体;">输出了</span><span style="font-family: Helvetica;">10</span><span style="font-family: 宋体;">个随机数：</span></p>
<src class="cnblogs_code">
<pre><code>Random random = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();

random.ints().limit(</span>10).forEach(System.out::println);</code></pre>

<p class="25"><strong>　　map：</strong></p>
<p class="p">　　　　map <span style="font-family: 宋体;">方法用于映射每个元素到对应的结果，以下代码片段使用 </span><span style="font-family: Helvetica;">map </span><span style="font-family: 宋体;">输出了元素对应的平方数：</span></p>
<src class="cnblogs_code">
<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取对应的平方数 </span>
<span style="color: #000000;">
List</span>&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</code></pre>

<p class="25"><strong>　　filter：</strong></p>
<p class="p">　　　　filter <span style="font-family: 宋体;">方法用于通过设置的条件过滤出元素。以下代码片段使用 </span><span style="font-family: Helvetica;">filter </span><span style="font-family: 宋体;">方法过滤出空字符串：</span></p>
<src class="cnblogs_code">
<pre><code>List&lt;String&gt;strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"); <br /><br /><span style="color: #008000;">//</span><span style="color: #008000;"> 获取空字符串的数量 <br /><span style="color: #000000;">int count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span></span></code></pre>

<p class="25"><strong>　　limit：</strong></p>
<p class="p">　　　　limit <span style="font-family: 宋体;">方法用于获取指定数量的流。 以下代码片段使用 </span><span style="font-family: Helvetica;">limit </span><span style="font-family: 宋体;">方法打印出 </span><span style="font-family: Helvetica;">10 </span><span style="font-family: 宋体;">条数据：</span></p>
<src class="cnblogs_code">
<pre><code>Random random = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();

random.ints().limit(</span>10).forEach(System.out::println);</code></pre>

<p class="25"><strong>　　sorted：</strong></p>
<p class="p">　　　　sorted <span style="font-family: 宋体;">方法用于对流进行排序。以下代码片段使用 </span><span style="font-family: Helvetica;">sorted </span><span style="font-family: 宋体;">方法对输出的 </span><span style="font-family: Helvetica;">10 </span><span style="font-family: 宋体;">个随机数进行排序：</span></p>
<src class="cnblogs_code">
<pre><code>Random random = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();

random.ints().limit(</span>10).sorted().forEach(System.out::println);</code></pre>

<p class="25"><strong><span style="font-family: 宋体;">　　并行（</span>parallel<span style="font-family: 宋体;">）程序：</span></strong></p>
<p class="p">　　　　parallelStream <span style="font-family: 宋体;">是流并行处理程序的代替方法。以下实例我们使用 </span><span style="font-family: Helvetica;">parallelStream </span><span style="font-family: 宋体;">来输出空字符串的数量：</span></p>
<src class="cnblogs_code">
<pre><code>List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取空字符串的数量 </span>

<span style="color: #0000ff;">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</code></pre>

<p class="p"><span style="font-family: 宋体;">　　　　我们可以很容易的在顺序运行和并行直接切换。</span></p>
<p class="25"><strong>　　Collectors：</strong></p>
<p class="p">Collectors <span style="font-family: 宋体;">类实现了很多归约操作，例如将流转换成集合和聚合元素。</span><span style="font-family: Helvetica;">Collectors </span><span style="font-family: 宋体;">可用于返回列表或字符串：</span></p>
<src class="cnblogs_code">
<pre><code>List&lt;String&gt;strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl"<span style="color: #000000;">);

List</span>&lt;String&gt; filtered = strings.stream().filter(string -&gt; !<span style="color: #000000;">string.isEmpty()).collect(Collectors.toList());

System.out.println(</span>"筛选列表: " +<span style="color: #000000;"> filtered);

String mergedString </span>= strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(", "<span style="color: #000000;">));

System.out.println(</span>"合并字符串: " + mergedString);</code></pre>

<p>&nbsp;</p>
<p class="25"><span style="font-size: 14pt;">六、<strong>Optional<span style="font-family: 宋体;">：</span></strong></span></p>
<p class="25">　　Optional<span style="font-family: 宋体;">对象可以为空，所以</span>Optional <span style="font-family: 宋体;">类的引入很好的解决空指针异常</span><span style="font-family: 宋体;">。</span></p>
<p class="25"><span style="font-family: 宋体;">　　　　通过以下实例来了解</span>Optional<span style="font-family: 宋体;">类的使用：</span></p>
<src class="cnblogs_code">
<pre><code>Public <span style="color: #0000ff;">class</span><span style="color: #000000;"> User{

　　</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;

　　</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String password;

　　....

}</span></code></pre>

<p class="25"><span style="font-family: 宋体;">以往的判断方式：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Mytest{

　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){

    　　　User user </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> User();

　　　　User.setPassword(&ldquo;admin&rdquo;);

　　　　String name </span>=<span style="color: #000000;"> getPwd(user);

　　　　System.out.println(name);

　　}

　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> String getPwd(User u){

　　　　</span><span style="color: #0000ff;">if</span>(u==<span style="color: #0000ff;">null</span><span style="color: #000000;">){

 　　　　 </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> &ldquo;unknown&rdquo;;

　　}

　　　</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> u.getPassword();

}</span></code></pre>

<p>&nbsp;</p>
<p class="25"><span style="font-family: 宋体;">使用</span>Optional<span style="font-family: 宋体;">：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> String getPwd(User u){

　　</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Optional.ofNullable(u)

　　　　　　　　  .map(user</span>-&gt;<span style="color: #000000;">user.getPassword())

　　　　　　　　  .orElse(&ldquo;unknown&rdquo;);

};</span></code></pre>

<p>&nbsp;</p>
<p class="25"><span style="font-size: 14pt;">七、<strong><span style="font-family: 宋体;">日期</span>Api<span style="font-family: 宋体;">：</span></strong></span></p>
<p class="25">Jdk1.8<span style="font-family: 宋体;">给我们提供了三个本地日期时间类：</span>LocalDate<span style="font-family: 宋体;">、</span>LocalTime <span style="font-family: 宋体;">和 </span><span style="font-family: Courier New;">LocalDateTime </span><span style="font-family: 宋体;">类</span><span style="font-family: 宋体;">。</span></p>
<p class="25"><span style="font-family: 宋体;">在不需要处理时区问题的时候，使用本地日期时间</span>API<span style="font-family: 宋体;">（</span>LocalDate<span style="font-family: 宋体;">、</span>LocalTime <span style="font-family: 宋体;">和 </span><span style="font-family: Courier New;">LocalDateTime</span><span style="font-family: 宋体;">）</span>&nbsp;<span style="font-family: 宋体;">：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 获取当前的日期时间</span>
<span style="color: #000000;">
 LocalDateTime currentTime </span>=<span style="color: #000000;"> LocalDateTime.now();

 System.out.println(</span>"当前时间: " +<span style="color: #000000;"> currentTime);

LocalDate date1 </span>=<span style="color: #000000;"> currentTime.toLocalDate();

System.out.println(</span>"date1: " +<span style="color: #000000;"> date1);

Month month </span>=<span style="color: #000000;"> currentTime.getMonth();

</span><span style="color: #0000ff;">int</span> day =<span style="color: #000000;"> currentTime.getDayOfMonth();

</span><span style="color: #0000ff;">int</span> seconds =<span style="color: #000000;"> currentTime.getSecond();

System.out.println(</span>"月: " + month +", 日: " + day +", 秒: " + seconds);</code></pre>

<p>&nbsp;</p>
<p class="25"><span style="font-family: 宋体;">在需要处理时区的时候，使用时区的日期时间</span>API<span style="font-family: 宋体;">（</span>ZonedDateTime <span style="font-family: 宋体;">）：</span></p>
<src class="cnblogs_code">
<pre><code>ZonedDateTime dd=<span style="color: #000000;"> ZonedDateTime.now();
System.out.println(dd);
ZonedDateTime date1 </span>=<span style="color: #000000;"> ZonedDateTime.parse(dd.toString());
System.out.println(</span>"date1: " +<span style="color: #000000;"> date1);
ZoneId id </span>= ZoneId.of(ZoneId.SHORT_IDS.get("CTT"<span style="color: #000000;">));
System.out.println(</span>"ZoneId: " +<span style="color: #000000;"> id);
ZoneId currentZone </span>=<span style="color: #000000;"> ZoneId.systemDefault();
System.out.println(</span>"当期时区: " + currentZone);</code></pre>

<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>