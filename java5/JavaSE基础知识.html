<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JavaSE基础知识' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JavaSE基础知识</center></div><div class='banquan'>原文出处:本文由博客园博主linfuxian提供。<br/>
原文连接:https://www.cnblogs.com/linfuxian/p/11846854.html</div><br>
    <p><span style="font-family: 宋体; font-size: 14px;">前言</span></p>
<p><span style="font-family: 宋体;">&nbsp; JavaSE是Java开发者必须熟练掌握的基础知识，我在这里把一些平常比较容易忽视的点记录下来，以便后面查阅。</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">一、数据类型转换　　</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">　 Java数据类型主要分为两大类，基本数据类型和引用数据类型。基本数据类型分为四类八种基本类型，包括整数、浮点数、字符、布尔；引用数据类型主要为类、数组、接口等。</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">&nbsp; 四类八种数据类型</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">&nbsp;<img src="./images/JavaSE基础知识0.png" alt="" /></span></p>
<p><span style="font-family: 宋体; font-size: 14px;">1.1 自动类型转换</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">&nbsp; java在给数据类型赋值运算时，会自动将取值范围小的数据类型提升到取值范围大的数据类型（如byte、short、char运算时会自动提升为int）。</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">&nbsp; 值得一提的是，b3=1+2这句，编译没有报错，前面我们说过byte、short、char运算时会自动提升为int，此时我们并没有进行强制转换，为什么没有报错呢？原因是1和2是常量，在编译时期已经确定他们相加不会超过byte的取值范围，编译器会将</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">他们相加的结果转为byte类型。而b4=b1+b2，编译就会报错，这是因为b1和b2是两个变量，编译器无法在编译时期确定他们的值，会将他们相加的值作为int类型处理，用byte来接收自然会报错了。</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">&nbsp; +=、-=、*=、/=这些复合赋值运算符，在运算时，会隐式的将int向下转为byte、short、char等类型，所以b4+=1语句不会报错。</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
</span><span style="color: #008080;">2</span>   <span style="color: #0000ff;">byte</span> b1=1<span style="color: #000000;">;
</span><span style="color: #008080;">3</span>   <span style="color: #0000ff;">byte</span> b2=2<span style="color: #000000;">;
</span><span style="color: #008080;">4</span>   <span style="color: #0000ff;">byte</span> b3=1 + 2<span style="color: #000000;">; 
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">byte</span> b4=b1 +<span style="color: #000000;"> b2;
</span><span style="color: #008080;">6</span>   b4+=1<span style="color: #000000;">;
</span><span style="color: #008080;">7</span> <span style="color: #000000;">  System.out.println(b3);
</span><span style="color: #008080;">8</span> <span style="color: #000000;">  System.out.println(b4); 
</span><span style="color: #008080;">9</span> }</code></pre>

<p>&nbsp;</p>
<p><span style="font-family: 宋体; font-size: 14px;">1.2 强制类型转换</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">&nbsp; 在将取值范围大的数据类型的值赋值给取值范围小的数据类型变量时，必须进行强制转换，将取值范围大的数据类型的值转换成取值范围小的数据类型，否则编译会报错，并且转换过程中会造成一定的精度丢失。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体; font-size: 14px;">二、 参数传递</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">&nbsp; Java方法的参数是以值的形式传递的，而不是引用传递。方法的参数类型是基本类型就传递数据值，方法的参数类型是引用类型的话传递的就是地址值。以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，</span></p>
<p><span style="font-family: 宋体; font-size: 14px;">本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象时，那这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Dog {
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #000000;">    String name;
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span> <span style="color: #000000;">    Dog(String name) {
</span><span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> <span style="color: #000000;">    String getName() {
</span><span style="color: #008080;">10</span>         <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.name;
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>     <span style="color: #0000ff;">void</span><span style="color: #000000;"> setName(String name) {
</span><span style="color: #008080;">14</span>         <span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #000000;">    String getObjectAddress() {
</span><span style="color: #008080;">18</span>         <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">super</span><span style="color: #000000;">.toString();
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span> <span style="color: #000000;">}
</span><span style="color: #008080;">21</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PassByValueExample {
</span><span style="color: #008080;">22</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;">23</span>         Dog dog = <span style="color: #0000ff;">new</span> Dog("A"<span style="color: #000000;">);
</span><span style="color: #008080;">24</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> Dog@4554617c</span>
<span style="color: #008080;">25</span> <span style="color: #000000;">        System.out.println(dog.getObjectAddress());
</span><span style="color: #008080;">26</span> <span style="color: #000000;">        func(dog);
</span><span style="color: #008080;">27</span>         <span style="color: #008000;">//</span><span style="color: #008000;">Dog@4554617c</span>
<span style="color: #008080;">28</span> <span style="color: #000000;">        System.out.println(dog.getObjectAddress()); 
</span><span style="color: #008080;">29</span>         System.out.println(dog.getName());          <span style="color: #008000;">//</span><span style="color: #008000;"> A</span>
<span style="color: #008080;">30</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">31</span> 
<span style="color: #008080;">32</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func(Dog dog) {
</span><span style="color: #008080;">33</span> <span style="color: #000000;">        System.out.println(dog.getObjectAddress()); 
</span><span style="color: #008080;">34</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> Dog@4554617c</span>
<span style="color: #008080;">35</span>         dog = <span style="color: #0000ff;">new</span> Dog("B"<span style="color: #000000;">);
</span><span style="color: #008080;">36</span> <span style="color: #000000;">        System.out.println(dog.getObjectAddress()); 
</span><span style="color: #008080;">37</span>        <span style="color: #008000;">//</span><span style="color: #008000;"> Dog@74a14482</span>
<span style="color: #008080;">38</span>         System.out.println(dog.getName());          <span style="color: #008000;">//</span><span style="color: #008000;"> B</span>
<span style="color: #008080;">39</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">40</span> }</code></pre>

<p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PassByValueExample {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 3</span>         Dog dog = <span style="color: #0000ff;">new</span> Dog("A"<span style="color: #000000;">);
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">        func(dog);
</span><span style="color: #008080;"> 5</span>         System.out.println(dog.getName());          <span style="color: #008000;">//</span><span style="color: #008000;"> B</span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func(Dog dog) {
</span><span style="color: #008080;"> 9</span>         dog.setName("B"<span style="color: #000000;">);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span> }</code></pre>

<p>&nbsp;</p>
<p>三、 自动装箱与拆箱</p>
<p>3.1&nbsp; 包装类型</p>
<p>&nbsp; &nbsp; 8种基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。例如int：</p>
<src class="cnblogs_code">
<pre><code>Integer x = 2;     <span style="color: #008000;">//</span><span style="color: #008000;"> 装箱 调用了 Integer.valueOf(2)</span>
<span style="color: #0000ff;">int</span> y = x;         <span style="color: #008000;">//</span><span style="color: #008000;"> 拆箱 调用了 X.intValue()</span></code></pre>

<p>3.2&nbsp; 缓存池</p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<src class="highlight highlight-source-java">
<src class="cnblogs_code">
<pre><code>Integer x = <span style="color: #0000ff;">new</span> Integer(123<span style="color: #000000;">);
Integer y </span>= <span style="color: #0000ff;">new</span> Integer(123<span style="color: #000000;">);
System.out.println(x </span>== y);    <span style="color: #008000;">//</span><span style="color: #008000;"> false</span>
Integer z = Integer.valueOf(123<span style="color: #000000;">);
Integer k </span>= Integer.valueOf(123<span style="color: #000000;">);
System.out.println(z </span>== k);   <span style="color: #008000;">//</span><span style="color: #008000;"> true<br /></span></code></pre>


<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<src class="highlight highlight-source-java">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> Integer valueOf(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
    </span><span style="color: #0000ff;">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;=<span style="color: #000000;"> IntegerCache.high)
        </span><span style="color: #0000ff;">return</span> IntegerCache.cache[i + (-<span style="color: #000000;">IntegerCache.low)];
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Integer(i);
}</span></code></pre>

<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<src class="cnblogs_code">
<pre><code>Integer c = 128<span style="color: #000000;">;

Integer d </span>= 128<span style="color: #000000;">;

system.out.println(c</span>==d); <span style="color: #008000;">//</span><span style="color: #008000;">false</span></code></pre>

<h3>当Integer i=128时，128不在常量池范围内，所以在自动装箱过程中需new 128，所以地址不一样。</h3>
<p>以下是8种基本类型对应的缓存范围：</p>
<ul>
<li>boolean&nbsp; &nbsp; false和true</li>
<li>char&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0-127，即只缓存ascii码范围的char&nbsp;</li>
<li>byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-128-127，缓存范围即为类型的大小范围，所以byte一定是从缓存中取</li>
<li>short&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;-128-127</li>
<li>int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -128-127,可以在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小</li>
<li>long&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-128-127</li>
<li>float&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;不被缓存</li>
<li>double&nbsp; &nbsp; &nbsp; &nbsp;不被缓存</li>
</ul>

<p>&nbsp;</p>
<p>四、 Java虚拟机内存分配</p>
<p>&nbsp; &nbsp; 为了提高运算效率，Java虚拟机对内存空间进行了不同区域的划分，每一片区域都有特定的处理数据方式和内存管理方式。</p>
<p>4.1 Java虚拟机的内存划分</p>
<table style="height: 269px; width: 1349px;" border="1">
<tbody>
<tr>
<td>程序计数器（PC寄存器）</td>
<td>在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复到切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，<strong>程序计数器是每个线程所私有的</strong>。（给CPU使用，和开发无关）</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>
<src>JVM在使用操作系统功能的时候使用，也是属于线程私有的，每创建一个新的线程都会给它们分配栈空间和程序计数器。&nbsp;
</td>
</tr>
<tr>
<td>方法区</td>
<td>方法区是线程共有的，主要存储字节码文件对象，即.class文件，方法区内还有一个静态区，主要存储静态变量和全局变量。（字符串常量池于JDK7之后移到了堆内存）</td>
</tr>
<tr>
<td>堆内存</td>
<td>Java堆是虚拟机管理内存中最大的一块空间，并且被所有线程共享。堆内存主要存放着程序运行时期创建的各种对象，也是垃圾收集器管理的主要区域。在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To&nbsp;Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。java堆的大小是可扩展的， 通过-Xmx和-Xms控制。如果堆内存不够分配实例对象， 并且也无法再扩展时， 将会抛出outOfMemoryError异常。<br /><br /><br /></td>







</tr>
<tr>
<td>虚拟机栈</td>
<td>Java虚拟机栈是线程私有的，线程启动时会创建虚拟机栈，每个方法在执行时会在虚拟机栈中创建一个栈帧，用于存储局部变量表（类成员变量存储于堆中）、操作数栈、动态连接、方法返回地址、附加信息等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈（压栈）到出栈（弹栈）的过程。</td>







</tr>







</tbody>







</table>
<p>&nbsp;<span style="font-family: 宋体; font-size: 14px;">&nbsp;</span></p>
<p>五、 String&nbsp;概述<span style="font-size: 18px; font-family: 黑体;"> &nbsp;</span></p>
<p>&nbsp; &nbsp; &nbsp;String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）。在 Java 8 中，String 内部使用 char 数组存储数据。在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <span style="font-family: monospace;">coder</span>来标识使用了哪种编码。</p>
<p>5.1 字符串常量池</p>
<p>&nbsp; &nbsp; 字符串常量池（String Pool）保存着所有字符串字面量，这些字面量在编译时期就确定。如果是采用 "bbb" 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<p>&nbsp; &nbsp; 使用&nbsp;<span class="pl-k">new&nbsp;<span class="pl-smi">String(<span class="pl-s"><span class="pl-pds">"aaa<span class="pl-pds">")&nbsp;这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。</span></span></span></span></span></p>
<p>&nbsp; &nbsp;1.&nbsp; "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；</p>
<p>&nbsp; &nbsp;2.&nbsp; 而使用 new 的方式会在堆中创建一个字符串对象。</p>
<src class="highlight highlight-source-java">
<src class="cnblogs_code">
<pre><code>String s5 = "bbb"<span>;
String s6 = "bbb"<span>;
System.out.println(s5 == s6);  // true</span></span></code></pre>


<p>&nbsp; &nbsp; 不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字</p>
<p>符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>&nbsp; &nbsp; 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<src class="highlight highlight-source-java">
<src class="cnblogs_code">
<pre><code>String s1 = <span style="color: #0000ff;">new</span> String("aaa"<span style="color: #000000;">);
String s2 </span>= <span style="color: #0000ff;">new</span> String("aaa"<span style="color: #000000;">);
System.out.println(s1 </span>== s2);           <span style="color: #008000;">//</span><span style="color: #008000;"> false</span>
String s3 =<span style="color: #000000;"> s1.intern();
String s4 </span>=<span style="color: #000000;"> s1.intern();
System.out.println(s3 </span>== s4);           <span style="color: #008000;">//</span><span style="color: #008000;"> true</span></code></pre>


<p>&nbsp; &nbsp; 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<p>&nbsp;</p>
<p>参考：https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px; font-family: 黑体;">&nbsp;&nbsp;</span></strong></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>