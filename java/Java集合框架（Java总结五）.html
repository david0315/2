<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java集合框架（Java总结五）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java集合框架（Java总结五）</center></div><div class='banquan'>原文出处:本文由博客园博主落成提供。<br/>
原文连接:https://www.cnblogs.com/bobozz/p/11505257.html</div><br>
    <h5 class="md-end-block md-heading"><span class="md-plain md-expand">&rdquo;<a href="https://www.runoob.com/java/java-data-structures.html">https://www.runoob.com/java/</a>&rdquo;</span></h5>
<h2 class="md-end-block md-heading"><span class="md-plain md-expand">集合接口区别</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">List 接口存储一组不唯一，有序（插入顺序）的对象，允许有相同的元素。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Set 接口存储一组唯一，无序的对象，不保存重复的元素。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">SortedSet继承于Set保存有序的集合。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Map.Entry描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">SortedMap继承于 Map，使 Key 保持在升序排列。</span></p>
</li>
<li class="md-list-item md-focus-container">
<p class="md-end-block md-p md-focus"><span class="md-plain md-expand">Enumeration这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">Set和List的区别</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 <span><strong>&lt;实现类有HashSet,TreeSet&gt;</strong><span class="md-plain">。</span></span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <span><strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong><span class="md-plain"> 。</span></span></span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">LinkedList和ArrayList</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">LinkedList</span></p>
<p class="md-end-block md-p"><span class="md-plain">该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。LinkedList 查找效率低。</span></p>
<pre><code><span>Listlist=Collections.synchronizedList(newLinkedList(...));</span></code></pre>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">ArrayList</span></p>
<p class="md-end-block md-p"><span class="md-plain">该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">HashSet、LinkedHashSet和TreeSet</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">HashSet实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">LinkedHashSet具有可预知迭代顺序的 <span><code>Set</code><span class="md-plain"> 接口的哈希表和链接列表实现。</span></span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">TreeSet该类实现了Set接口，可以实现排序等功能。</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">HashMap、TreeMap、WeakHashMap、LinkedHashMap和IdentityHashMap</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">HashMap是一个散列表，它存储的内容是键值对(key-value)映射。<span class="md-softbreak"> <span class="md-plain">该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</span></span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">TreeMap继承了AbstractMap，并且使用一颗树。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">WeakHashMap继承AbstractMap类，使用弱密钥的哈希表。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">LinkedHashMap继承于HashMap，使用元素的自然顺序对元素进行排序。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">IdentityHashMap继承AbstractMap类，比较文档时使用引用相等。</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">java.util包中定义的类</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Vector类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Stack是Vector的一个子类，它实现了一个标准的后进先出的栈。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">BitSet类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">集合算法异常抛出</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">在尝试比较不兼容的类型时，一些方法能够抛出 <span><strong>ClassCastException</strong><span class="md-plain">异常。</span></span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">当试图修改一个不可修改的集合时，抛出<span><strong>UnsupportedOperationException</strong><span class="md-plain">异常。</span></span></span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">迭代器</span></h2>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">它是一个对象，实现了Iterator 接口或ListIterator接口。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。</span></p>
</li>
</ul>
<h4 class="md-end-block md-heading"><span class="md-plain">遍历 ArrayList</span></h4>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span> java.util.*<span style="color: #000000;">;
 
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test{
 </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
     List</span>&lt;String&gt; list=<span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
     list.add(</span>"Hello"<span style="color: #000000;">);
     list.add(</span>"World"<span style="color: #000000;">);
     list.add(</span>"HAHAHAHA"<span style="color: #000000;">);
     </span><span style="color: #008000;">//</span><span style="color: #008000;">第一种遍历方法使用 For-Each 遍历 List</span>
     <span style="color: #0000ff;">for</span> (String str : list) {            <span style="color: #008000;">//</span><span style="color: #008000;">也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式</span>
<span style="color: #000000;">        System.out.println(str);
     }
 
     </span><span style="color: #008000;">//</span><span style="color: #008000;">第二种遍历，把链表变为数组相关的内容进行遍历</span>
     String[] strArray=<span style="color: #0000ff;">new</span><span style="color: #000000;"> String[list.size()];
     list.toArray(strArray);
     </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;strArray.length;i++) <span style="color: #008000;">//</span><span style="color: #008000;">这里也可以改写为  for(String str:strArray) 这种形式</span>
<span style="color: #000000;">     {
        System.out.println(strArray[i]);
     }
     
    </span><span style="color: #008000;">//</span><span style="color: #008000;">第三种遍历 使用迭代器进行相关遍历</span>
<span style="color: #000000;">     
     Iterator</span>&lt;String&gt; ite=<span style="color: #000000;">list.iterator();
     </span><span style="color: #0000ff;">while</span>(ite.hasNext())<span style="color: #008000;">//</span><span style="color: #008000;">判断下一个元素之后有值</span>
<span style="color: #000000;">     {
         System.out.println(ite.next());
     }
 }
}</span></code></pre>

<h4 class="md-end-block md-heading"><span class="md-plain">遍历 Map</span></h4>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span> java.util.*<span style="color: #000000;">;
 
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test{
     </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
      Map</span>&lt;String, String&gt; map = <span style="color: #0000ff;">new</span> HashMap&lt;String, String&gt;<span style="color: #000000;">();
      map.put(</span>"1", "value1"<span style="color: #000000;">);
      map.put(</span>"2", "value2"<span style="color: #000000;">);
      map.put(</span>"3", "value3"<span style="color: #000000;">);
      
      </span><span style="color: #008000;">//</span><span style="color: #008000;">第一种：普遍使用，二次取值</span>
      System.out.println("通过Map.keySet遍历key和value："<span style="color: #000000;">);
      </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String key : map.keySet()) {
       System.out.println(</span>"key= "+ key + " and value= " +<span style="color: #000000;"> map.get(key));
      }
      
      </span><span style="color: #008000;">//</span><span style="color: #008000;">第二种</span>
      System.out.println("通过Map.entrySet使用iterator遍历key和value："<span style="color: #000000;">);
      Iterator</span>&lt;Map.Entry&lt;String, String&gt;&gt; it =<span style="color: #000000;"> map.entrySet().iterator();
      </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (it.hasNext()) {
       Map.Entry</span>&lt;String, String&gt; entry =<span style="color: #000000;"> it.next();
       System.out.println(</span>"key= " + entry.getKey() + " and value= " +<span style="color: #000000;"> entry.getValue());
      }
      
      </span><span style="color: #008000;">//</span><span style="color: #008000;">第三种：推荐，尤其是容量大时</span>
      System.out.println("通过Map.entrySet遍历key和value"<span style="color: #000000;">);
      </span><span style="color: #0000ff;">for</span> (Map.Entry&lt;String, String&gt;<span style="color: #000000;"> entry : map.entrySet()) {
       System.out.println(</span>"key= " + entry.getKey() + " and value= " +<span style="color: #000000;"> entry.getValue());
      }
    
      </span><span style="color: #008000;">//</span><span style="color: #008000;">第四种</span>
      System.out.println("通过Map.values()遍历所有的value，但不能遍历key"<span style="color: #000000;">);
      </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String v : map.values()) {
       System.out.println(</span>"value= " +<span style="color: #000000;"> v);
      }
     }
}</span></code></pre>

<h2 class="md-end-block md-heading"><span class="md-plain md-expand">任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。</span></h2>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>