<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java 学习 进阶之 一 （线程基础）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java 学习 进阶之 一 （线程基础）</center></div><div class='banquan'>原文出处:本文由博客园博主青青一笑很倾城提供。<br/>
原文连接:https://www.cnblogs.com/liu520/p/11789910.html</div><br>
    <h2><span style="color: #99cc00;">一、线程安全</span></h2>
<p><strong><span style="color: #ff0000;">线程安全的概念：</span></strong>当多个线程访问某一个类（对象或方法）时。这个类始终都能表现出正确的行为那么这个类（对象或方法）就是线程安全的。</p>
<p><strong><span style="color: #ff0000;">synchronized：</span></strong>可以在任何对象及方法上加锁，而加锁的这段代码称为&ldquo;互斥区&rdquo;或&ldquo;临界区&rdquo;</p>
<p><strong>示例：【com.study.base.thread.a_sync.sync001】MyThread</strong></p>
<src class="cnblogs_code" onclick="cnblogs_code_show('942f651c-e85f-4d9d-b289-85abe7020d5a')"><img id="code_img_closed_942f651c-e85f-4d9d-b289-85abe7020d5a" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_942f651c-e85f-4d9d-b289-85abe7020d5a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('942f651c-e85f-4d9d-b289-85abe7020d5a',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_942f651c-e85f-4d9d-b289-85abe7020d5a" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync001;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 
 *        线程安全概念：当多个线程访问某一个类（对象或方法）时，这个类始终都能表现出正确的行为，那么这个类（对象或方法）
 *    就是线程安全的
 *        synchronized:可以在任意对象及方法上加锁，而加锁的这段代码称为&ldquo;互斥区&rdquo;或&ldquo;临界区&rdquo;
 *    
 *    示例总结
 *        当多个线程访问myThread的run方法时，以排队的方式进处理（这里排队是按照CPU分配的先后顺序商定的），
 *    一个线程想要执行Synchronized修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行synchronized代码体内容；
 *    拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且是多个线程同时去竞争这把锁（也就是会有锁竞争的问题）。
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> count = 5<span style="color: #000000;">;
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">synchronized 加锁</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        count</span>--<span style="color: #000000;">;
        System.out.println(Thread.currentThread().getName()</span>+" count = "+<span style="color: #000000;">count);
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         *     分析：
         *         当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排队是按照cpu分配的先后顺序而定的）
         *         1  尝试获得锁
         *         2 如果拿到锁，执行synchronized代码体内容：拿不到锁出，这个线程就会不断的尝试获得这把锁，直到拿到为止
         *         而且是多个线程同时去竞争这把锁，也就是会有锁竞争的问题
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        MyThread mythread </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyThread();
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(mythread,"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(mythread,"t2"<span style="color: #000000;">);
        Thread t3 </span>= <span style="color: #0000ff;">new</span> Thread(mythread,"t3"<span style="color: #000000;">);
        Thread t4 </span>= <span style="color: #0000ff;">new</span> Thread(mythread,"t4"<span style="color: #000000;">);
        Thread t5 </span>= <span style="color: #0000ff;">new</span> Thread(mythread,"t5"<span style="color: #000000;">);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
         
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">MyThread</span>
<p><strong>示例总结</strong></p>
<p>&nbsp; &nbsp; 当多个线程访问myThread的run方法时，以排队的方式进处理（这里排队是按照CPU分配的先后顺序商定的），一个线程想要执行Synchronized修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且是多个线程同时去竞争这把锁（也就是会有锁竞争的问题）。</p>
<h2><span style="color: #99cc00;">二、多个线程多个锁</span></h2>
<p><span style="color: #000000;"><strong><span style="color: #ff0000;">多个线程多个锁：</span></strong>多个线程，每个线程都可以拿到自己指定的锁分别获得锁之后执行synchronized方法体的内容</span></p>
<p><span style="color: #000000;"><strong>示例：</strong>【com.study.base.thread.a_sync.sync002】MultiThread</span></p>
<src class="cnblogs_code" onclick="cnblogs_code_show('09c36f09-c2c1-40fc-a21c-34b3ed1e0f3c')"><img id="code_img_closed_09c36f09-c2c1-40fc-a21c-34b3ed1e0f3c" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_09c36f09-c2c1-40fc-a21c-34b3ed1e0f3c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('09c36f09-c2c1-40fc-a21c-34b3ed1e0f3c',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_09c36f09-c2c1-40fc-a21c-34b3ed1e0f3c" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync002;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 *     多个线程多个锁：多个线程，每个线程都可以拿到自己指定的锁分别获得锁之后执行synchronized方法体的内容
 *        关键字synchronized获取的锁都是对象锁，而不是把一段代码（方法）当做锁，所以示例代码中哪个线程先执行synchronized关键字的方法，哪个线下就持有该方法所属对象的锁（Lock），两个对象。线程获得的就是两个不同的锁，他们互不影响
 *    有一种情况则是相同的锁，即使在静态方法上加synchronized关键字，表示锁定.class，类一级别的锁（独占.class类）.
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MultiThread {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> num = 0<span style="color: #000000;">;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printNum(String tag) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span>(tag.equals("a"<span style="color: #000000;">)) {
                num </span>= 100<span style="color: #000000;">;
                System.out.println(</span>"tag a , set num over"<span style="color: #000000;">);
                Thread.sleep(</span>1000<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                num </span>= 200<span style="color: #000000;"> ;
                System.out.println(</span>"tag b , set num over"<span style="color: #000000;">);
            }
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        System.out.println(</span>"tag "+tag+" , num = "+<span style="color: #000000;">num);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">注意观察run方法的输出顺序</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">两个不同的对象</span>
        <span style="color: #0000ff;">final</span> MultiThread m1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MultiThread();
        </span><span style="color: #0000ff;">final</span> MultiThread m2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MultiThread();
        
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
                m1.printNum("a"<span style="color: #000000;">);
            }
        },</span>"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
                m2.printNum("b"<span style="color: #000000;">);
            }
        },</span>"t2"<span style="color: #000000;">);
        t1.start();
        t2.start();
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">MultiThread</span>
<p><strong>示例总结</strong></p>
<p>&nbsp; &nbsp; 关键字synchronized获取的锁都是对象锁，而不是把一段代码（方法）当做锁，所以示例代码中哪个线程先执行synchronized关键字的方法，哪个线下就持有该方法所属对象的锁（Lock），两个对象。线程获得的就是两个不同的锁，他们互不影响 有一种情况则是相同的锁，即使在静态方法上加synchronized关键字，表示锁定.class，类一级别的锁（独占.class类）.</p>
<h2><span style="color: #99cc00;">三、对象锁的同步和异步</span></h2>
<p><span style="color: #000000;"><strong><span style="color: #ff0000;">同步：</span></strong>synchronized&nbsp;同步的概念就是共享，我们要牢牢记住&ldquo;共享&rdquo;这两个字，如果不是共享的资源，就没有必要进行同步<br /></span></p>
<p><span style="color: #000000;"><strong><span style="color: #ff0000;">异步：</span></strong>asynchronized&nbsp;异步的概念就是独立，相互之间不受到任何制约。就好像我们学习http的时候，在页面发起的Ajax请求,我们还可以继续浏览操作页面的内容，两者之间没有任何关系</span></p>
<p><strong><span style="color: #000000;">同步的目的就是为了线程安全，其实对于线程安全来说，需要满足两个特性：</span></strong></p>
<p><span style="color: #000000;">　　<strong><span style="color: #ff0000;">原子性（同步）</span></strong></span></p>
<p><strong><span style="color: #ff0000;">　　可见性</span></strong></p>
<p><strong><span style="color: #000000;">示例：</span></strong><span style="color: #000000;">【</span><span style="color: #000000;">com.study.base.thread.a_sync.sync003】MyObject</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('95c82e9c-5249-4a3a-bca3-a2255b4454f3')"><img id="code_img_closed_95c82e9c-5249-4a3a-bca3-a2255b4454f3" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_95c82e9c-5249-4a3a-bca3-a2255b4454f3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('95c82e9c-5249-4a3a-bca3-a2255b4454f3',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_95c82e9c-5249-4a3a-bca3-a2255b4454f3" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync003;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 
 * 对象的同步和异步问题
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyObject {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1() {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            System.out.print(Thread.currentThread().getName());
            Thread.sleep(</span>4000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            e.printStackTrace();
        }
    }
    
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> synchronized </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2() {
        System.out.println(Thread.currentThread().getName());
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">final</span> MyObject mo = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyObject();
        </span><span style="color: #008000;">/**</span><span style="color: #008000;">
         * 分析：
         * t1线程先持有object对象的lock锁，t2线程可以以异步的方式调用对象中的非synchronized修饰的方法
         * t1线程先持有object对象的lock锁，t2线程如果在这个时候调用对象中的同步（synchronized）方法则需等待，也就是同步
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                mo.method1();
            }
        },</span>"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                mo.method2();
            }
        },</span>"t2"<span style="color: #000000;">);
        t1.start();
        t2.start();
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">MyObject</span>
<p>&nbsp;</p>
<p><strong><span style="color: #000000;">示例总结</span></strong></p>
<p><span style="color: #000000;">&nbsp; &nbsp; A线程先持有object对象的Lock锁，B线程如果在这个时候调用对象的同步（synchronized）方法则需要等待，也就是同步 ​ </span></p>
<p><span style="color: #000000;">&nbsp; &nbsp; A线程先持有object对象的Lock锁，B线程可以以异步的方式调用对象中的非synchronized修饰的方法</span></p>
<h2><span style="color: #000000;"><span style="color: #99cc00;">四、脏读</span><br /></span></h2>
<p><span style="color: #000000;">&nbsp; &nbsp; 对于对象的同步和异步方法，我们在设计自己的程序的时候，一定要考虑问题的整体，不然会出现数据不一致的错误，很经典的错误就是脏读（dirtyread）</span></p>
<p><strong>示例：</strong>【com.study.base.thread.a_sync.sync004】DirtyRead</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('04e4b100-d22a-4041-b574-a4faae099ca3')"><img id="code_img_closed_04e4b100-d22a-4041-b574-a4faae099ca3" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_04e4b100-d22a-4041-b574-a4faae099ca3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('04e4b100-d22a-4041-b574-a4faae099ca3',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_04e4b100-d22a-4041-b574-a4faae099ca3" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync004;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 业务整体需要使用完整的synchronized，保持业务的原子性
 * 
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> DirtyRead {
    </span><span style="color: #0000ff;">private</span> String username = "Rang"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> String password = "123"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setValue(String username, String password) {
        </span><span style="color: #0000ff;">this</span>.username =<span style="color: #000000;"> username;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>2000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            e.printStackTrace();
        }
        
        </span><span style="color: #0000ff;">this</span>.password =<span style="color: #000000;"> password;
        
        System.out.println(</span>"setValue最终结果, username = " + username + " password = " +<span style="color: #000000;"> password);
    } 
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> getValue() {
        System.out.println(</span>"getValue方法得到, username = " + username + " password = " +<span style="color: #000000;"> password);
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException {
        
        </span><span style="color: #0000ff;">final</span> DirtyRead dr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DirtyRead();
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {

            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                dr.setValue(</span>"z3", "456"<span style="color: #000000;">);
            }
            
        },</span>"t1"<span style="color: #000000;">);
        t1.start();
        Thread.sleep(</span>1000<span style="color: #000000;">);
        
        dr.getValue();
        
    }
            
}</span></code></pre>

<span class="cnblogs_code_collapse">DirtyRead</span>
<p><strong>示例总结：</strong></p>
<p>&nbsp; &nbsp; 在我们对一个对象的方法加锁的时候，需要考虑业务的整体性，即为setValue / getValue 方法同时加锁synchronized同步的关键字，保证业务（service）的原子性，不然会出现业务错误（也从侧面保证业务的一致性）。</p>
<h2>&nbsp;<span style="color: #99cc00;">五、synchronized 其他概念</span></h2>
<p><span style="color: #000000;"><strong><span style="color: #ff0000;">synchronized锁重入</span></strong><span style="color: #ff0000;">：</span>关键字synchronized拥有锁重入的功能，也就是使用synchronized时，当一个线程得到一个对象的锁后，再次请求此对象时是可以再次得到该对象的锁的。</span></p>
<p><span style="color: #000000;"><strong>示例：</strong>【com.study.base.thread.a_sync.sync005】SyncDubbo1</span></p>
<src class="cnblogs_code" onclick="cnblogs_code_show('b24dc504-e3d9-4eb8-8db8-3a4f55d7fbd5')"><img id="code_img_closed_b24dc504-e3d9-4eb8-8db8-3a4f55d7fbd5" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_b24dc504-e3d9-4eb8-8db8-3a4f55d7fbd5" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b24dc504-e3d9-4eb8-8db8-3a4f55d7fbd5',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_b24dc504-e3d9-4eb8-8db8-3a4f55d7fbd5" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync005;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * synchronized 的重入
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SyncDubbo1 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1() {
        System.out.println(</span>"method1......"<span style="color: #000000;">);
        method2();
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2() {
        System.out.println(</span>"method2......"<span style="color: #000000;">);
        method3();
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method3() {
        System.out.println(</span>"method3......"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">final</span> SyncDubbo1 sa = <span style="color: #0000ff;">new</span><span style="color: #000000;"> SyncDubbo1();
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                sa.method1();
            }
        });
        t1.start();
    }
    
}</span></code></pre>

<span class="cnblogs_code_collapse">SyncDubbo1</span>
<p><span style="color: #000000;"><strong>示例：</strong>【com.study.base.thread.a_sync.sync005】SyncDubbo2</span></p>
<src class="cnblogs_code" onclick="cnblogs_code_show('bb4e3517-d212-4ca0-962c-af159c512d21')"><img id="code_img_closed_bb4e3517-d212-4ca0-962c-af159c512d21" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_bb4e3517-d212-4ca0-962c-af159c512d21" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('bb4e3517-d212-4ca0-962c-af159c512d21',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_bb4e3517-d212-4ca0-962c-af159c512d21" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync005;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * synchronized 的重入
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SyncDubbo2 {
    
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main{
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> i = 10<span style="color: #000000;">;
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> operationSup() {
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                i</span>--<span style="color: #000000;">;
                System.out.println(</span>"Main print i = "+<span style="color: #000000;">i);
                Thread.sleep(</span>100<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 有父子继承关系的 互相之间调用有synchronized修饰的方法也是线程安全的
     *
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> Sub <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Main{
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> operationSub() {
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">while</span> (i &gt; 0<span style="color: #000000;">) {
                    i</span>--<span style="color: #000000;">;
                    System.out.println(</span>"Sub print i = "+<span style="color: #000000;">i);
                    Thread.sleep(</span>100<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.operationSup();
                }
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
     
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                 Sub sub </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Sub();
                 sub.operationSub();
            }
        });
        t1.start();
    }
    
}</span></code></pre>

<span class="cnblogs_code_collapse">SyncDubbo2</span>
<p><strong><span style="color: #000000;"><strong>示例：</strong></span></strong><span style="color: #000000;">【com.study.base.thread.a_sync.sync005】SyncException</span></p>
<src class="cnblogs_code" onclick="cnblogs_code_show('2476032a-880a-4b81-bbcf-11a9b0ab6caa')"><img id="code_img_closed_2476032a-880a-4b81-bbcf-11a9b0ab6caa" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_2476032a-880a-4b81-bbcf-11a9b0ab6caa" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2476032a-880a-4b81-bbcf-11a9b0ab6caa',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_2476032a-880a-4b81-bbcf-11a9b0ab6caa" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync005;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * synchronized 异常
 * 异常之后  前后是一个整体时  抛出异常 回滚
 * 前后不是一个整体没有关联关系的话 记录日志 continue 执行下个循环
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SyncException {
     
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> i = 0<span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> operation() {
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                i</span>++<span style="color: #000000;">;
                Thread.sleep(</span>200<span style="color: #000000;">);
                System.out.println(Thread.currentThread().getName()</span>+", i = "+<span style="color: #000000;">i);
                </span><span style="color: #0000ff;">if</span> (i == 10<span style="color: #000000;">) {
                    Integer.parseInt(</span>"a"<span style="color: #000000;">);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">throw new RuntimeException();</span>
<span style="color: #000000;">                }
            } </span><span style="color: #0000ff;">catch</span> (Exception e) { <span style="color: #008000;">//</span><span style="color: #008000;">InterruptedException</span>
<span style="color: #000000;">                e.printStackTrace();
                System.out.println(</span>" log  info i = "+<span style="color: #000000;">i);
                </span><span style="color: #008000;">//</span><span style="color: #008000;">throw new RuntimeException
                </span><span style="color: #008000;">//</span><span style="color: #008000;">continue;</span>
<span style="color: #000000;">            }
        }
    }
     
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">final</span> SyncException se = <span style="color: #0000ff;">new</span><span style="color: #000000;"> SyncException();
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                se.operation(); 
            }
        },</span>"t1"<span style="color: #000000;">);
        t1.start();
    }
    
}</span></code></pre>

<span class="cnblogs_code_collapse">SyncException</span>
<p><strong style="font-family: 'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px;"><span>示例说明：</span></strong></p>
<p>&nbsp; &nbsp;&nbsp;对于web应用程序。异常释放锁的情况，如果不及时处理，很可能对你的应用程序业务逻辑产生严重的错误，比如你现在执行一个队列任务，很多对象都去在等待第一个对象正常执行完毕再去释放锁。但是第一个对象由于异常的出现，导致业务逻辑没有正常执行完毕，就释放了锁。那么可想而知后续的对象执行的都是错误的逻辑。所以这一点一定要引起注意，在编写代码的时候，一定要考虑周全</p>
<h2><span style="color: #99cc00;">六、synchronized 代码块</span></h2>
<p><span style="color: #000000;">使用synchronized声明的方法在某些情况下是有弊端的，比如A线程调用同B线程就必须等待比较长的时间才能执行，这样的情况下可以使用synchronized代码块去优化代码执行时间，也就是通常所说的减小锁的粒度。</span></p>
<p><span style="color: #000000;"><strong>示例：</strong>【com.study.base.thread.a_sync.sync006】Optimize</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('98a005d8-f153-4938-8b0b-bf0c1fbc7a35')"><img id="code_img_closed_98a005d8-f153-4938-8b0b-bf0c1fbc7a35" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_98a005d8-f153-4938-8b0b-bf0c1fbc7a35" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('98a005d8-f153-4938-8b0b-bf0c1fbc7a35',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_98a005d8-f153-4938-8b0b-bf0c1fbc7a35" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync006;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.study.util.DateUtil;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 *    使用synchronized声明的方法在某些情况下是有弊端的，比如A线程调用同B线程就必须等待比较长的时间才能执行，
 *    这样的情况下可以使用synchronized代码块去优化代码执行时间，也就是通常所说的减小锁的粒度
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Optimize {
     
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1 () {
        System.out.println(</span>"当前线程："+Thread.currentThread().getName()+" 开始 "+<span style="color: #000000;">DateUtil.getCurrentTimes());
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>2000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>2000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>2000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        System.out.println(</span>"当前线程："+Thread.currentThread().getName()+" 结束"+<span style="color: #000000;">DateUtil.getCurrentTimes());
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2 () { 
        System.out.println(</span>"当前线程："+Thread.currentThread().getName()+" 开始"+<span style="color: #000000;">DateUtil.getCurrentTimes());
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>2000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        </span><span style="color: #0000ff;">synchronized</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">) {
            System.out.println(</span>"当前线程："+Thread.currentThread().getName()+" 执行锁代码块开始"+<span style="color: #000000;">DateUtil.getCurrentTimes());
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                Thread.sleep(</span>2000<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">                e.printStackTrace();
            }
        }
        System.out.println(</span>"当前线程："+Thread.currentThread().getName()+" 执行锁代码块结束"+<span style="color: #000000;">DateUtil.getCurrentTimes());
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>2000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
        System.out.println(</span>"当前线程："+Thread.currentThread().getName()+" 结束"+<span style="color: #000000;">DateUtil.getCurrentTimes());
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">final</span> Optimize optimize = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Optimize(); 
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                optimize.method1();
                </span><span style="color: #008000;">//</span><span style="color: #008000;">optimize.method2();</span>
<span style="color: #000000;">            }
        }, </span>"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                optimize.method1();
                </span><span style="color: #008000;">//</span><span style="color: #008000;">optimize.method2();</span>
<span style="color: #000000;">            }
        }, </span>"t2"<span style="color: #000000;">);
        t1.start();
        t2.start();
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">Optimize </span>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>synchronized可以使用任意的Object进行加锁，用法比较灵活。</strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #000000;"><strong>示例：</strong>【com.study.base.thread.a_sync.sync006】ObjectLock</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('3cf1c6c7-3fc9-470c-a8d0-7ea9aa3ce877')"><img id="code_img_closed_3cf1c6c7-3fc9-470c-a8d0-7ea9aa3ce877" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_3cf1c6c7-3fc9-470c-a8d0-7ea9aa3ce877" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3cf1c6c7-3fc9-470c-a8d0-7ea9aa3ce877',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_3cf1c6c7-3fc9-470c-a8d0-7ea9aa3ce877" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync006;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 使用synchronized代码块加锁，比较灵活
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ObjectLock {
     
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     *    对象锁
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1() {
        </span><span style="color: #0000ff;">synchronized</span> (<span style="color: #0000ff;">this</span>) { <span style="color: #008000;">//</span><span style="color: #008000;">对象锁</span>
            <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                System.out.println(</span>"do method1..."<span style="color: #000000;">);
                Thread.sleep(</span>2000<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     *     类锁
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2() {
        </span><span style="color: #0000ff;">synchronized</span> (ObjectLock.<span style="color: #0000ff;">class</span>) { <span style="color: #008000;">//</span><span style="color: #008000;">类锁</span>
            <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                System.out.println(</span>"do method2..."<span style="color: #000000;">);
                Thread.sleep(</span>2000<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    
    </span><span style="color: #0000ff;">private</span>  Object lock = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     *     任何对象都会锁
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method3() {
        </span><span style="color: #0000ff;">synchronized</span> (lock) { <span style="color: #008000;">//</span><span style="color: #008000;">任何对象</span>
            <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                System.out.println(</span>"do method3..."<span style="color: #000000;">);
                Thread.sleep(</span>2000<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">final</span> ObjectLock objLock = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ObjectLock();
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                objLock.method1();
            }
        });
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                objLock.method2();
            }
        });
        Thread t3 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                objLock.method3();
            }
        });
        t1.start();
        t2.start();
        t3.start();
    }
    
}</span></code></pre>

<span class="cnblogs_code_collapse">ObjectLock </span>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>另外特别注意一个问题，就是不要使用String的常量加锁，会出现死循环问题。</strong></span></p>
<p><strong>示例：</strong>【com.study.base.thread.a_sync.sync006】StringLock</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('4397b16c-bc49-4a53-b651-596449e34dba')"><img id="code_img_closed_4397b16c-bc49-4a53-b651-596449e34dba" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_4397b16c-bc49-4a53-b651-596449e34dba" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4397b16c-bc49-4a53-b651-596449e34dba',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_4397b16c-bc49-4a53-b651-596449e34dba" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync006;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * synchronized 代码块对字符串的锁，注意String常量池的缓存功能
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> StringLock {
      
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">new String ("字符串常量")</span>
        <span style="color: #0000ff;">synchronized</span> ("字符串常量") {  <span style="color: #008000;">//</span><span style="color: #008000;"> 在常量池中 "字符串常量" 只有一个引用</span>
            <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    System.out.println(</span>"当前线程："+Thread.currentThread().getName() +"开始"<span style="color: #000000;">);
                    Thread.sleep(</span>1000<span style="color: #000000;">);
                    System.out.println(</span>"当前线程："+Thread.currentThread().getName() +"结束"<span style="color: #000000;">);
                }
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String []  args) {
        </span><span style="color: #0000ff;">final</span> StringLock stringLock = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringLock();
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                stringLock.method();
            }
        },</span>"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                stringLock.method();
            }
        },</span>"t2"<span style="color: #000000;">);
        t1.start();
        t2.start();
    }
    
}</span></code></pre>

<span class="cnblogs_code_collapse">StringLock </span>
<p><strong><span style="color: #ff0000;">锁对象的改变问题。当使用一个对象进行加锁的时候，要注意对象本身发生改变的时候，那么持有的锁就不同。如果对象本身不发生改变，那么依然是同步的，即使是对象的属性发生了改变。</span></strong></p>
<p><strong>示例：</strong>【com.study.base.thread.a_sync.sync006】ChangeLock</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('410313c0-7be7-46f9-be70-9129992c12ab')"><img id="code_img_closed_410313c0-7be7-46f9-be70-9129992c12ab" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_410313c0-7be7-46f9-be70-9129992c12ab" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('410313c0-7be7-46f9-be70-9129992c12ab',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_410313c0-7be7-46f9-be70-9129992c12ab" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync006;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 锁对象的改变问题
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ChangeLock {
      
    </span><span style="color: #0000ff;">private</span> String lock = "lock"<span style="color: #000000;">;
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        </span><span style="color: #0000ff;">synchronized</span> (lock) {  <span style="color: #008000;">//</span><span style="color: #008000;"> 在常量池中 "字符串常量" 只有一个引用</span>
            <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                    System.out.println(</span>"当前线程："+Thread.currentThread().getName() +"开始"<span style="color: #000000;">);
                    lock </span>= "change lock";  <span style="color: #008000;">//</span><span style="color: #008000;"> 修改后锁发生变化了 锁将不在有效  。如果想锁生效不要在方法里修改锁对象的引用</span>
                    Thread.sleep(2000<span style="color: #000000;">);
                    System.out.println(</span>"当前线程："+Thread.currentThread().getName() +"结束"<span style="color: #000000;">);
                }
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String []  args) {
        </span><span style="color: #0000ff;">final</span> ChangeLock changeLock = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ChangeLock();
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                changeLock.method();
            }
        },</span>"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                changeLock.method();
            }
        },</span>"t2"<span style="color: #000000;">);
        t1.start();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>1000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
         t2.start();
    }
    
}</span></code></pre>

<span class="cnblogs_code_collapse">ChangeLock</span>
<p>示例：【com.study.base.thread.a_sync.sync006】ModifyLock</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('ee13e9e9-b7af-4549-bdf0-0de1b4952c27')"><img id="code_img_closed_ee13e9e9-b7af-4549-bdf0-0de1b4952c27" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_ee13e9e9-b7af-4549-bdf0-0de1b4952c27" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ee13e9e9-b7af-4549-bdf0-0de1b4952c27',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_ee13e9e9-b7af-4549-bdf0-0de1b4952c27" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync006;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 *    同一对象属性的修改不会影响锁的情况
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ModifyLock {
      
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name ;
    
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age ;
    
    
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setName(String name) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getAge() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> age;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setAge(<span style="color: #0000ff;">int</span><span style="color: #000000;"> age) {
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span> changeAttribute(String name, <span style="color: #0000ff;">int</span><span style="color: #000000;"> age ) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            System.out.println(</span>"当前线程："+Thread.currentThread().getName() +"开始"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setName(name);
            </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.setAge(age);
            System.out.println(</span>"当前线程："+Thread.currentThread().getName() +" 修改对象内容为"
                    +<span style="color: #0000ff;">this</span>.getName()+", "+<span style="color: #0000ff;">this</span><span style="color: #000000;">.getAge());
            Thread.sleep(</span>2000<span style="color: #000000;">);
            System.out.println(</span>"当前线程："+Thread.currentThread().getName() +"结束"<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String []  args) {
        </span><span style="color: #0000ff;">final</span> ModifyLock modifyLock = <span style="color: #0000ff;">new</span> ModifyLock(); <span style="color: #008000;">//</span><span style="color: #008000;"> 对象锁  一个对象一个锁</span>
        Thread t1 = <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
                modifyLock.changeAttribute("张三", 18<span style="color: #000000;">);
            }
        },</span>"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
                modifyLock.changeAttribute("李四", 21<span style="color: #000000;">);
            }
        },</span>"t2"<span style="color: #000000;">);
        t1.start();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>1000<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
         t2.start();
    }
    
}</span></code></pre>

<span class="cnblogs_code_collapse">ModifyLock </span>
<p><span style="color: #ff0000;"><strong>死锁问题</strong></span></p>
<p><strong>示例：</strong>【com.study.base.thread.a_sync.sync006】DeadLock</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('8e15c206-3408-417d-a5f4-b0e9f30a7273')"><img id="code_img_closed_8e15c206-3408-417d-a5f4-b0e9f30a7273" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_8e15c206-3408-417d-a5f4-b0e9f30a7273" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8e15c206-3408-417d-a5f4-b0e9f30a7273',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_8e15c206-3408-417d-a5f4-b0e9f30a7273" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync006;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 *    死锁问题 : 比较常见的死锁的产生是因为A线程执行需要得到B线程的占用锁  B线程执行的时候需要A线程占用的锁
 *</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> DeadLock {
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">final</span> Object a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
        </span><span style="color: #0000ff;">final</span> Object b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
        
        Thread t1 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(a) {
                    System.out.println(</span>"t1线程获取到锁a了"<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        Thread.sleep(</span>1000<span style="color: #000000;">);
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">                        e.printStackTrace();
                    }
                    System.out.println(</span>"t1线程准备获取锁b"<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(b) {
                        System.out.println(</span>"t1线程获取到锁b了"<span style="color: #000000;">);
                    } 
                    
                } 
            }
        },</span>"t1"<span style="color: #000000;">);
        Thread t2 </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(b) {
                    System.out.println(</span>"t2线程获取到锁b了"<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                        Thread.sleep(</span>2000<span style="color: #000000;">);
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">                        e.printStackTrace();
                    }
                    System.out.println(</span>"t2线程准备获取锁a"<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(a) {
                        System.out.println(</span>"t2线程获取到锁a了"<span style="color: #000000;">);
                    } 
                } 
                
            }
        },</span>"t2"<span style="color: #000000;">);
        t1.start();
        t2.start();
        
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">DeadLock </span>
<h2><span style="color: #99cc00;">七、volitail关键字的使用</span></h2>
<p><span style="color: #99cc00;"><strong><span style="color: #ff0000;">Volatile概念：</span></strong></span>volatile关键字的主要作用是使变量在多个线程间可见。</p>
<p><strong>示例：</strong>【com.study.base.thread.a_sync.sync007】</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('aacb8235-37c3-4dba-aedc-7150036b316a')"><img id="code_img_closed_aacb8235-37c3-4dba-aedc-7150036b316a" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_aacb8235-37c3-4dba-aedc-7150036b316a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('aacb8235-37c3-4dba-aedc-7150036b316a',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_aacb8235-37c3-4dba-aedc-7150036b316a" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync007;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * volatile关键字的主要作用是使变量在多个线程间可见
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> RunThread <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread {
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * volatile
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">boolean</span> isRunning  = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> setRunning(<span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isRunning) {
        </span><span style="color: #0000ff;">this</span>.isRunning =<span style="color: #000000;"> isRunning;
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        System.out.println(</span>"进入run方法"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span>(isRunning == <span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">..</span>
<span style="color: #000000;">        }
        System.out.print(</span>"线程停止"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException {
        RunThread rt </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> RunThread();
        rt.start();
        Thread.sleep(</span>3000<span style="color: #000000;">);
        rt.setRunning(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
        System.out.println(</span>"isRunning设置成立false"<span style="color: #000000;">);
        Thread.sleep(</span>1000<span style="color: #000000;">);
        System.out.println(rt.isRunning);
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">RunThread</span>
<p><strong>示例总结：</strong></p>
<p>&nbsp; &nbsp; 在java中，每一个线程都会有一块工作内存区，其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时，他在自己的工作内存区中操作这些变量。为了存取一个共享的变量，一个线程通常先获取锁定并去清除它的内存工作区，把这些共享变量从所有线程的共享内存区中正确的装入到他自己所在的工作内存区中，当线程解锁时保证该工作内存区中的变量的值写回到共享内存中。</p>
<p>&nbsp; &nbsp; 一个线程可以执行的操作有​使用（use）、 赋值（asslgn）、装载（load）、存储（store）、锁定（lock）、解锁（unlocK）</p>
<p>&nbsp; &nbsp; 而主内存可以执行的操作有读（read）、写（write）、锁定（lock）、解锁（unlock）每个操作都是原子的</p>
<p>&nbsp; &nbsp; volatile的作用就是强制线程到主内存（共享内存）里去读取变量，而不去线程工作的内存区里去读取，从而实现了线程之间的变量可见，也就满足线程安全的可见性​​​</p>
<p><strong>volatile关键字虽然拥有多个线程之间的可见性，但是却不具有同步性（也就是原子性），可以算上是一个轻量及的synchronized ，性能要比synchronized强很，不会照成阻塞（在很多开源的架构里），比如netty的底层代码就大量使用volatile，可见netty性能一定是非常不错的）这里需要注意：一般volatile用于只针对多个线程可见的变量操作，并不能代替synchronized的同步功能。</strong></p>
<p><strong>示例：</strong>【com.study.base.thread.a_sync.sync007】VolatileNoAtomic</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('d9d97557-ea4a-4dd3-bdee-30cebbc9f351')"><img id="code_img_closed_d9d97557-ea4a-4dd3-bdee-30cebbc9f351" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_d9d97557-ea4a-4dd3-bdee-30cebbc9f351" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('d9d97557-ea4a-4dd3-bdee-30cebbc9f351',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_d9d97557-ea4a-4dd3-bdee-30cebbc9f351" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync007;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * Volatile 关键字不具备synchronized关键字的原子性（同步）
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> Administrator
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> VolatileNoAtomic <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> count;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">private static AtomicInteger count = new AtomicInteger(0);</span>
    
    
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> addCount() {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; 1000; i++<span style="color: #000000;">) {
            count</span>++<span style="color: #000000;">;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">count.incrementAndGet();</span>
<span style="color: #000000;">        }
        System.out.println(count);
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        addCount();
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException {
        VolatileNoAtomic[] arr </span>= <span style="color: #0000ff;">new</span> VolatileNoAtomic[10<span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; 10; i++<span style="color: #000000;">) {
            arr[i] </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> VolatileNoAtomic();
        }
        
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; 10; i++<span style="color: #000000;">) {
            arr[i].start();
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">最后一次打印10000才是对的 中间可以忽略 （因为可能第一次循环1000次完成以后 后面的线程也在执行++ 导致数据在中间打印的不是完整的1000）。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果想要保持原子性推荐使用 AtomicInteger
        </span><span style="color: #008000;">//</span><span style="color: #008000;">CAS非阻塞算法</span>
<span style="color: #000000;">    }
}</span></code></pre>

<span class="cnblogs_code_collapse">VolatileNoAtomic </span>
<p><strong>示例总结：</strong></p>
<p>&nbsp; &nbsp; &nbsp;volatile关键字只具有可见性，没有原子性。要实现原子性建议使用Atomic类的系列对象，支持原子性操作（注意Atomic类只能保证本身方法的原子性，并不保证多次操作原子性）</p>
<p><strong>示例：</strong>【com.study.base.thread.a_sync.sync007】AtomicUse</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('4b81dbe3-019b-40fd-8ff9-5dfeb68b96a7')"><img id="code_img_closed_4b81dbe3-019b-40fd-8ff9-5dfeb68b96a7" class="code_img_closed" src="./images/java 学习 进阶之 一 （线程基础）0.png" alt="" /><img id="code_img_opened_4b81dbe3-019b-40fd-8ff9-5dfeb68b96a7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4b81dbe3-019b-40fd-8ff9-5dfeb68b96a7',event)" src="./images/java 学习 进阶之 一 （线程基础）1.png" alt="" />
<src id="cnblogs_code_open_4b81dbe3-019b-40fd-8ff9-5dfeb68b96a7" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.study.base.thread.a_sync.sync007;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.List;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.atomic.AtomicInteger;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> AtomicUse {
    </span><span style="color: #0000ff;">private</span> AtomicInteger count = <span style="color: #0000ff;">new</span> AtomicInteger(0<span style="color: #000000;">);
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">多个addAndGet在一个方法内是非原子性的，需要加synchronized进行修缮，保证4个addAndGet整体原子性</span>
    <span style="color: #008000;">/**</span><span style="color: #008000;"> synchronized </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> multiAdd() {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>100<span style="color: #000000;">);    
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            e.printStackTrace();
        }
        count.addAndGet(</span>1<span style="color: #000000;">);
        count.addAndGet(</span>2<span style="color: #000000;">);
        count.addAndGet(</span>3<span style="color: #000000;">);
        count.addAndGet(</span>4);<span style="color: #008000;">//</span><span style="color: #008000;"> +10</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> count.get();
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">final</span> AtomicUse au = <span style="color: #0000ff;">new</span><span style="color: #000000;"> AtomicUse();
        
        List</span>&lt;Thread&gt; ts = <span style="color: #0000ff;">new</span> ArrayList&lt;Thread&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; 100; i++<span style="color: #000000;">) {
            ts.add(</span><span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
                
                @Override
                </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
<span style="color: #000000;">                    System.out.println(au.multiAdd());
                }
            }));
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Thread t : ts) {
            t.start();
        }
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">AtomicUse </span>
<p><strong>示例总结：</strong></p>
<p><strong>　　在多线程中同一个方法中多次调用atomic类中的方法，不能保证这个<strong><strong>的方法中<strong>多次调用atomic类的方法（<strong><strong><strong><strong>整体的</strong></strong></strong></strong>）<strong>原子性</strong></strong></strong></strong>，如果想保证此方法中<strong><strong><strong><strong>多次调用atomic类的方法（整体的）<strong>原子性</strong></strong></strong></strong></strong>的那么需要添加synchronized关键字，否者最终结果可能是一致但是中间返回的数据可能不是满10（见示例）</strong></p>
<p>&nbsp; &nbsp;&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>