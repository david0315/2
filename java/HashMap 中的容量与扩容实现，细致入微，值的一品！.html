<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修HashMap 中的容量与扩容实现，细致入微，值的一品！' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>HashMap 中的容量与扩容实现，细致入微，值的一品！</center></div><div class='banquan'>原文出处:本文由博客园博主youzhibing2904提供。<br/>
原文连接:https://www.cnblogs.com/youzhibing/p/11833040.html</div><br>
    <h2>前言</h2>
<p>　　开心一刻　　</p>
<p>　　　　巴闭，你的脚怎么会有味道，我要闻闻看是不是好吃的，嗯~~爸比你的脚臭死啦！！ &hellip;&hellip;</p>
<h2><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！0.png" alt="" /></h2>
<h2>高手过招，招招致命</h2>
<p>　　JDK1.8 中 HashMap 的底层实现，我相信大家都能说上来个 一二，底层数据结构&nbsp;<span class="cnblogs_code">数组 + 链表（或红黑树）</span>&nbsp;，源码如下</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('b2207491-a72e-4440-bb90-7e7d0a84b4e4')"><img id="code_img_closed_b2207491-a72e-4440-bb90-7e7d0a84b4e4" class="code_img_closed" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！1.png" alt="" /><img id="code_img_opened_b2207491-a72e-4440-bb90-7e7d0a84b4e4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b2207491-a72e-4440-bb90-7e7d0a84b4e4',event)" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！2.png" alt="" />
<src id="cnblogs_code_open_b2207491-a72e-4440-bb90-7e7d0a84b4e4" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 数组
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">transient</span> Node&lt;K,V&gt;<span style="color: #000000;">[] table;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 链表结构
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> Node&lt;K,V&gt; <span style="color: #0000ff;">implements</span> Map.Entry&lt;K,V&gt;<span style="color: #000000;"> {
    </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> hash;
    </span><span style="color: #0000ff;">final</span><span style="color: #000000;"> K key;
    V value;
    Node</span>&lt;K,V&gt;<span style="color: #000000;"> next;

    Node(</span><span style="color: #0000ff;">int</span> hash, K key, V value, Node&lt;K,V&gt;<span style="color: #000000;"> next) {
        </span><span style="color: #0000ff;">this</span>.hash =<span style="color: #000000;"> hash;
        </span><span style="color: #0000ff;">this</span>.key =<span style="color: #000000;"> key;
        </span><span style="color: #0000ff;">this</span>.value =<span style="color: #000000;"> value;
        </span><span style="color: #0000ff;">this</span>.next =<span style="color: #000000;"> next;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> K getKey()        { <span style="color: #0000ff;">return</span><span style="color: #000000;"> key; }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> V getValue()      { <span style="color: #0000ff;">return</span><span style="color: #000000;"> value; }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> String toString() { <span style="color: #0000ff;">return</span> key + "=" +<span style="color: #000000;"> value; }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> hashCode() {
        </span><span style="color: #0000ff;">return</span> Objects.hashCode(key) ^<span style="color: #000000;"> Objects.hashCode(value);
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> V setValue(V newValue) {
        V oldValue </span>=<span style="color: #000000;"> value;
        value </span>=<span style="color: #000000;"> newValue;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> oldValue;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> equals(Object o) {
        </span><span style="color: #0000ff;">if</span> (o == <span style="color: #0000ff;">this</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (o <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Map.Entry) {
            Map.Entry</span>&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;<span style="color: #000000;">)o;
            </span><span style="color: #0000ff;">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<span style="color: #000000;">
                Objects.equals(value, e.getValue()))
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 红黑树结构
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span> TreeNode&lt;K,V&gt; <span style="color: #0000ff;">extends</span> LinkedHashMap.Entry&lt;K,V&gt;<span style="color: #000000;"> {
    TreeNode</span>&lt;K,V&gt; parent;  <span style="color: #008000;">//</span><span style="color: #008000;"> red-black tree links</span>
    TreeNode&lt;K,V&gt;<span style="color: #000000;"> left;
    TreeNode</span>&lt;K,V&gt;<span style="color: #000000;"> right;
    TreeNode</span>&lt;K,V&gt; prev;    <span style="color: #008000;">//</span><span style="color: #008000;"> needed to unlink next upon deletion</span>
    <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> red;
    ...</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！3.png" alt="" /></p>
<p>　　但面试往往会问的比较细，例如下面的容量问题，我们能答上来几个？</p>
<p>　　　　1、table 的初始化时机是什么时候，初始化的 table.length 是多少、阀值（threshold）是多少，实际能容下多少元素</p>
<p>　　　　2、什么时候触发扩容，扩容之后的 table.length、阀值各是多少？</p>
<p>　　　　3、table 的 length 为什么是 2 的 n 次幂</p>
<p>　　　　4、求索引的时候为什么是：h&amp;(length-1)，而不是 h&amp;length，更不是 h%length</p>
<p>　　　　5、&nbsp;<span class="cnblogs_code">Map map = <span style="color: #0000ff;">new</span> HashMap(1000);</span>&nbsp;当我们存入多少个元素时会触发map的扩容；&nbsp;<span class="cnblogs_code">Map map1 = <span style="color: #0000ff;">new</span> HashMap(10000);</span>&nbsp;我们存入第 10001个元素时会触发 map1 扩容吗</p>
<p>　　　　6、为什么加载因子的默认值是 0.75，并且不推荐我们修改</p>
<p>　　由于我们平时关注的少，一旦碰上这样的 连击 + 暴击，我们往往不知所措、无从应对；接下来我们看看上面的 6 个问题，是不是真的难到无法理解 ，还是我们不够细心、在自信的自我认为</p>
<h2>斗智斗勇，见招拆招</h2>
<p>　　上述的问题，我们如何去找答案 ? 方式有很多种，用的最多的，我想应该是上网查资料、看别人的博客，但我认为最有效、准确的方式是读源码</p>
<h3>　　问题 1：table 的初始化</h3>
<p>　　　　HashMap 的构造方法有如下 4 种</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('59b10cfa-302b-4f82-977b-bf4aa8c44716')"><img id="code_img_closed_59b10cfa-302b-4f82-977b-bf4aa8c44716" class="code_img_closed" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！1.png" alt="" /><img id="code_img_opened_59b10cfa-302b-4f82-977b-bf4aa8c44716" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('59b10cfa-302b-4f82-977b-bf4aa8c44716',event)" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！2.png" alt="" />
<src id="cnblogs_code_open_59b10cfa-302b-4f82-977b-bf4aa8c44716" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 构造方法 1
 *
 * 通过 指定的 initialCapacity 和 loadFactor 实例化一个空的 HashMap 对象
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> HashMap(<span style="color: #0000ff;">int</span> initialCapacity, <span style="color: #0000ff;">float</span><span style="color: #000000;"> loadFactor) {
    </span><span style="color: #0000ff;">if</span> (initialCapacity &lt; 0<span style="color: #000000;">)
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("Illegal initial capacity: " +<span style="color: #000000;">
                                           initialCapacity);
    </span><span style="color: #0000ff;">if</span> (initialCapacity &gt;<span style="color: #000000;"> MAXIMUM_CAPACITY)
        initialCapacity </span>=<span style="color: #000000;"> MAXIMUM_CAPACITY;
    </span><span style="color: #0000ff;">if</span> (loadFactor &lt;= 0 ||<span style="color: #000000;"> Float.isNaN(loadFactor))
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("Illegal load factor: " +<span style="color: #000000;">
                                           loadFactor);
    </span><span style="color: #0000ff;">this</span>.loadFactor =<span style="color: #000000;"> loadFactor;
    </span><span style="color: #0000ff;">this</span>.threshold =<span style="color: #000000;"> tableSizeFor(initialCapacity);
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 构造方法 2
 *
 * 通过指定的 initialCapacity 和 默认的 loadFactor(0.75) 实例化一个空的 HashMap 对象
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> HashMap(<span style="color: #0000ff;">int</span><span style="color: #000000;"> initialCapacity) {
    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">(initialCapacity, DEFAULT_LOAD_FACTOR);
}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 构造方法 3
 *
 * 通过默认的 initialCapacity 和 默认的 loadFactor(0.75) 实例化一个空的 HashMap 对象
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span><span style="color: #000000;"> HashMap() {
    </span><span style="color: #0000ff;">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span style="color: #008000;">//</span><span style="color: #008000;"> all other fields defaulted</span>
<span style="color: #000000;">}

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 *
 * 构造方法 4
 * 通过指定的 Map 对象实例化一个 HashMap 对象
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> HashMap(Map&lt;? <span style="color: #0000ff;">extends</span> K, ? <span style="color: #0000ff;">extends</span> V&gt;<span style="color: #000000;"> m) {
    </span><span style="color: #0000ff;">this</span>.loadFactor =<span style="color: #000000;"> DEFAULT_LOAD_FACTOR;
    putMapEntries(m, </span><span style="color: #0000ff;">false</span><span style="color: #000000;">);
}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>　　　　构造方式 4 和 构造方式 1 实际应用的不多，构造方式 2 直接调用的 1（底层实现完全一致），构造方式 2 和 构造方式 3 比较常用，而最常用的是构造方式 3；此时我们以构造方式 3 为前提来分析，而构造方式 2 我们则在问题 5 中来分析</p>
<p>　　　　 使用方式 1&nbsp;实例化 HashMap 的时候，table 并未进行初始化，那 table 是何时进行初始化的了 ？ 平时我们是如何使用 HashMap 的，先实例化、然后 put、然后进行其他操作，如下</p>
<src class="cnblogs_code">
<pre><code>Map&lt;String,Object&gt; map = new<span> HashMap();
map.put("name", "张三"<span>);
map.put("age", 21<span>);

// 后续操作
...</span></span></span></code></pre>

<p>　　　　既然实例化的时候未进行 table 的初始化，那是不是在 put 的时候初始化的了，我们来确认下</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！6.png" alt="" width="700" /></p>
<p>　　　　&nbsp;&nbsp;<span class="cnblogs_code">resize()</span>&nbsp;初始化 table 或 对 table 进行双倍扩容，源码如下（注意看注释）</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('9645c847-8f2e-49d5-9bf8-9760e469e258')"><img id="code_img_closed_9645c847-8f2e-49d5-9bf8-9760e469e258" class="code_img_closed" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！1.png" alt="" /><img id="code_img_opened_9645c847-8f2e-49d5-9bf8-9760e469e258" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9645c847-8f2e-49d5-9bf8-9760e469e258',event)" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！2.png" alt="" />
<src id="cnblogs_code_open_9645c847-8f2e-49d5-9bf8-9760e469e258" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * Initializes or doubles table size.  If null, allocates in
 * accord with initial capacity target held in field threshold.
 * Otherwise, because we are using power-of-two expansion, the
 * elements from each bin must either stay at same index, or move
 * with a power of two offset in the new table.
 *
 * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the table
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">final</span> Node&lt;K,V&gt;<span style="color: #000000;">[] resize() {
    Node</span>&lt;K,V&gt;[] oldTab = table;                    <span style="color: #008000;">//</span><span style="color: #008000;"> 第一次 put 的时候，table = null</span>
    <span style="color: #0000ff;">int</span> oldCap = (oldTab == <span style="color: #0000ff;">null</span>) ? 0 : oldTab.length; <span style="color: #008000;">//</span><span style="color: #008000;"> oldCap = 0</span>
    <span style="color: #0000ff;">int</span> oldThr = threshold;                        <span style="color: #008000;">//</span><span style="color: #008000;"> threshold=0, oldThr = 0</span>
    <span style="color: #0000ff;">int</span> newCap, newThr = 0<span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (oldCap &gt; 0) {    <span style="color: #008000;">//</span><span style="color: #008000;"> 条件不满足，往下走</span>
        <span style="color: #0000ff;">if</span> (oldCap &gt;=<span style="color: #000000;"> MAXIMUM_CAPACITY) {
            threshold </span>=<span style="color: #000000;"> Integer.MAX_VALUE;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> oldTab;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;<span style="color: #000000;">
                 oldCap </span>&gt;=<span style="color: #000000;"> DEFAULT_INITIAL_CAPACITY)
            newThr </span>= oldThr &lt;&lt; 1; <span style="color: #008000;">//</span><span style="color: #008000;"> double threshold</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (oldThr &gt; 0) <span style="color: #008000;">//</span><span style="color: #008000;"> initial capacity was placed in threshold</span>
        newCap =<span style="color: #000000;"> oldThr;
    </span><span style="color: #0000ff;">else</span> {               <span style="color: #008000;">//</span><span style="color: #008000;"> zero initial threshold signifies using defaults 走到这里，进行默认初始化</span>
        newCap = DEFAULT_INITIAL_CAPACITY;    <span style="color: #008000;">//</span><span style="color: #008000;"> DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 = 16, newCap = 16;</span>
        newThr = (<span style="color: #0000ff;">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    <span style="color: #008000;">//</span><span style="color: #008000;"> newThr = 0.75 * 16 = 12;</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">if</span> (newThr == 0) {    <span style="color: #008000;">//</span><span style="color: #008000;"> 条件不满足</span>
        <span style="color: #0000ff;">float</span> ft = (<span style="color: #0000ff;">float</span>)newCap *<span style="color: #000000;"> loadFactor;
        newThr </span>= (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span style="color: #0000ff;">float</span>)MAXIMUM_CAPACITY ?<span style="color: #000000;">
                  (</span><span style="color: #0000ff;">int</span><span style="color: #000000;">)ft : Integer.MAX_VALUE);
    }
    threshold </span>= newThr;        <span style="color: #008000;">//</span><span style="color: #008000;"> threshold = 12; 重置阀值为12</span>
    @SuppressWarnings({"rawtypes","unchecked"<span style="color: #000000;">})
        Node</span>&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span style="color: #0000ff;">new</span> Node[newCap];     <span style="color: #008000;">//</span><span style="color: #008000;"> 初始化 newTab, length = 16;</span>
    table = newTab;            <span style="color: #008000;">//</span><span style="color: #008000;"> table 初始化完成, length = 16;</span>
    <span style="color: #0000ff;">if</span> (oldTab != <span style="color: #0000ff;">null</span>) {    <span style="color: #008000;">//</span><span style="color: #008000;"> 此时条件不满足，后续扩容的时候，走此if分支 将数组元素复制到新数组</span>
        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = 0; j &lt; oldCap; ++<span style="color: #000000;">j) {
            Node</span>&lt;K,V&gt;<span style="color: #000000;"> e;
            </span><span style="color: #0000ff;">if</span> ((e = oldTab[j]) != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                oldTab[j] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (e.next == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                    newTab[e.hash </span>&amp; (newCap - 1)] =<span style="color: #000000;"> e;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (e <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> TreeNode)
                    ((TreeNode</span>&lt;K,V&gt;)e).split(<span style="color: #0000ff;">this</span><span style="color: #000000;">, newTab, j, oldCap);
                </span><span style="color: #0000ff;">else</span> { <span style="color: #008000;">//</span><span style="color: #008000;"> preserve order</span>
                    Node&lt;K,V&gt; loHead = <span style="color: #0000ff;">null</span>, loTail = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    Node</span>&lt;K,V&gt; hiHead = <span style="color: #0000ff;">null</span>, hiTail = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    Node</span>&lt;K,V&gt;<span style="color: #000000;"> next;
                    </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
                        next </span>=<span style="color: #000000;"> e.next;
                        </span><span style="color: #0000ff;">if</span> ((e.hash &amp; oldCap) == 0<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (loTail == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                                loHead </span>=<span style="color: #000000;"> e;
                            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
                                loTail.next </span>=<span style="color: #000000;"> e;
                            loTail </span>=<span style="color: #000000;"> e;
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            </span><span style="color: #0000ff;">if</span> (hiTail == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                                hiHead </span>=<span style="color: #000000;"> e;
                            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
                                hiTail.next </span>=<span style="color: #000000;"> e;
                            hiTail </span>=<span style="color: #000000;"> e;
                        }
                    } </span><span style="color: #0000ff;">while</span> ((e = next) != <span style="color: #0000ff;">null</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">if</span> (loTail != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                        loTail.next </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                        newTab[j] </span>=<span style="color: #000000;"> loHead;
                    }
                    </span><span style="color: #0000ff;">if</span> (hiTail != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                        hiTail.next </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                        newTab[j </span>+ oldCap] =<span style="color: #000000;"> hiHead;
                    }
                }
            }
        }
    }
    </span><span style="color: #0000ff;">return</span> newTab;    <span style="color: #008000;">//</span><span style="color: #008000;"> 新数组</span>
}</code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>&nbsp;　　　　自此，问题 1 的答案就明了了</p>
<src class="cnblogs_code">
<pre><code><span>table 的初始化时机是什么时候
    一般情况下，在第一次 put 的时候，调用 resize 方法进行 table 的初始化（懒初始化，懒加载思想在很多框架中都有应用！）
    
初始化的 table.length 是多少、阀值（threshold）是多少，实际能容下多少元素
    默认情况下，table.length = 16; 指定了 initialCapacity 的情况放到问题 5<span> 中分析
    默认情况下，threshold = 12; 指定了 initialCapacity 的情况放到问题 5<span> 中分析
    默认情况下，能存放 12 个元素，当存放第 13 个元素后进行扩容</span></span></span></code></pre>

<h3>　　问题 2 ：table 的扩容</h3>
<p>　　　　&nbsp;<span class="cnblogs_code">putVal</span>&nbsp;源码如下</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('ea2f7a45-3c80-437a-9b33-64d61f74b7f2')"><img id="code_img_closed_ea2f7a45-3c80-437a-9b33-64d61f74b7f2" class="code_img_closed" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！1.png" alt="" /><img id="code_img_opened_ea2f7a45-3c80-437a-9b33-64d61f74b7f2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ea2f7a45-3c80-437a-9b33-64d61f74b7f2',event)" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！2.png" alt="" />
<src id="cnblogs_code_open_ea2f7a45-3c80-437a-9b33-64d61f74b7f2" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * Implements Map.put and related methods
 *
 * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> hash hash for key
 * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> key the key
 * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> value the value to put
 * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> onlyIfAbsent if true, don't change existing value
 * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> evict if false, the table is in creation mode.
 * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> previous value, or null if none
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">final</span> V putVal(<span style="color: #0000ff;">int</span> hash, K key, V value, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> onlyIfAbsent,
               </span><span style="color: #0000ff;">boolean</span><span style="color: #000000;"> evict) {
    Node</span>&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span style="color: #0000ff;">int</span><span style="color: #000000;"> n, i;
    </span><span style="color: #0000ff;">if</span> ((tab = table) == <span style="color: #0000ff;">null</span> || (n = tab.length) == 0<span style="color: #000000;">)
        n </span>= (tab =<span style="color: #000000;"> resize()).length;
    </span><span style="color: #0000ff;">if</span> ((p = tab[i = (n - 1) &amp; hash]) == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
        tab[i] </span>= newNode(hash, key, value, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        Node</span>&lt;K,V&gt;<span style="color: #000000;"> e; K k;
        </span><span style="color: #0000ff;">if</span> (p.hash == hash &amp;&amp;<span style="color: #000000;">
            ((k </span>= p.key) == key || (key != <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> key.equals(k))))
            e </span>=<span style="color: #000000;"> p;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (p <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> TreeNode)
            e </span>= ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span style="color: #0000ff;">this</span><span style="color: #000000;">, tab, hash, key, value);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> binCount = 0; ; ++<span style="color: #000000;">binCount) {
                </span><span style="color: #0000ff;">if</span> ((e = p.next) == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    p.next </span>= newNode(hash, key, value, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">if</span> (binCount &gt;= TREEIFY_THRESHOLD - 1) <span style="color: #008000;">//</span><span style="color: #008000;"> -1 for 1st</span>
<span style="color: #000000;">                        treeifyBin(tab, hash);
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> (e.hash == hash &amp;&amp;<span style="color: #000000;">
                    ((k </span>= e.key) == key || (key != <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> key.equals(k))))
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                p </span>=<span style="color: #000000;"> e;
            }
        }
        </span><span style="color: #0000ff;">if</span> (e != <span style="color: #0000ff;">null</span>) { <span style="color: #008000;">//</span><span style="color: #008000;"> existing mapping for key</span>
            V oldValue =<span style="color: #000000;"> e.value;
            </span><span style="color: #0000ff;">if</span> (!onlyIfAbsent || oldValue == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                e.value </span>=<span style="color: #000000;"> value;
            afterNodeAccess(e);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> oldValue;
        }
    }
    </span>++<span style="color: #000000;">modCount;
    </span><span style="color: #0000ff;">if</span> (++size &gt; threshold)             <span style="color: #008000;">//</span><span style="color: #008000;"> 当size（已存放元素个数） &gt; thrshold（阀值），进行扩容</span>
<span style="color: #000000;">        resize();
    afterNodeInsertion(evict);
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>　　　　还是调用&nbsp;<span class="cnblogs_code">resize()</span>&nbsp;进行扩容，但与初始化时不同（注意看注释）</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('860bb083-bfaa-4959-b3d8-e8765776f58a')"><img id="code_img_closed_860bb083-bfaa-4959-b3d8-e8765776f58a" class="code_img_closed" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！1.png" alt="" /><img id="code_img_opened_860bb083-bfaa-4959-b3d8-e8765776f58a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('860bb083-bfaa-4959-b3d8-e8765776f58a',event)" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！2.png" alt="" />
<src id="cnblogs_code_open_860bb083-bfaa-4959-b3d8-e8765776f58a" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * Initializes or doubles table size.  If null, allocates in
 * accord with initial capacity target held in field threshold.
 * Otherwise, because we are using power-of-two expansion, the
 * elements from each bin must either stay at same index, or move
 * with a power of two offset in the new table.
 *
 * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the table
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">final</span> Node&lt;K,V&gt;<span style="color: #000000;">[] resize() {
    Node</span>&lt;K,V&gt;[] oldTab = table;                    <span style="color: #008000;">//</span><span style="color: #008000;"> 此时的 table != null，oldTab 指向旧的 table</span>
    <span style="color: #0000ff;">int</span> oldCap = (oldTab == <span style="color: #0000ff;">null</span>) ? 0 : oldTab.length; <span style="color: #008000;">//</span><span style="color: #008000;"> oldCap = table.length; 第一次扩容时是 16</span>
    <span style="color: #0000ff;">int</span> oldThr = threshold;                        <span style="color: #008000;">//</span><span style="color: #008000;"> threshold=12, oldThr = 12;</span>
    <span style="color: #0000ff;">int</span> newCap, newThr = 0<span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (oldCap &gt; 0) {    <span style="color: #008000;">//</span><span style="color: #008000;"> 条件满足，走此分支</span>
        <span style="color: #0000ff;">if</span> (oldCap &gt;=<span style="color: #000000;"> MAXIMUM_CAPACITY) {
            threshold </span>=<span style="color: #000000;"> Integer.MAX_VALUE;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> oldTab;
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;    <span style="color: #008000;">//</span><span style="color: #008000;"> oldCap左移一位; newCap = 16 &lt;&lt; 1 = 32;</span>
                 oldCap &gt;=<span style="color: #000000;"> DEFAULT_INITIAL_CAPACITY)
            newThr </span>= oldThr &lt;&lt; 1; <span style="color: #008000;">//</span><span style="color: #008000;"> double threshold            </span><span style="color: #008000;">//</span><span style="color: #008000;"> newThr = 12 &lt;&lt; 1 = 24;</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (oldThr &gt; 0) <span style="color: #008000;">//</span><span style="color: #008000;"> initial capacity was placed in threshold</span>
        newCap =<span style="color: #000000;"> oldThr;
    </span><span style="color: #0000ff;">else</span> {               <span style="color: #008000;">//</span><span style="color: #008000;"> zero initial threshold signifies using defaults</span>
        newCap = DEFAULT_INITIAL_CAPACITY;    <span style="color: #008000;">//</span><span style="color: #008000;"> DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 = 16, newCap = 16;</span>
        newThr = (<span style="color: #0000ff;">int</span>)(DEFAULT_LOAD_FACTOR *<span style="color: #000000;"> DEFAULT_INITIAL_CAPACITY);
    }
    </span><span style="color: #0000ff;">if</span> (newThr == 0) {    <span style="color: #008000;">//</span><span style="color: #008000;"> 条件不满足</span>
        <span style="color: #0000ff;">float</span> ft = (<span style="color: #0000ff;">float</span>)newCap *<span style="color: #000000;"> loadFactor;
        newThr </span>= (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span style="color: #0000ff;">float</span>)MAXIMUM_CAPACITY ?<span style="color: #000000;">
                  (</span><span style="color: #0000ff;">int</span><span style="color: #000000;">)ft : Integer.MAX_VALUE);
    }
    threshold </span>= newThr;        <span style="color: #008000;">//</span><span style="color: #008000;"> threshold = newThr = 24; 重置阀值为 24</span>
    @SuppressWarnings({"rawtypes","unchecked"<span style="color: #000000;">})
        Node</span>&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span style="color: #0000ff;">new</span> Node[newCap];     <span style="color: #008000;">//</span><span style="color: #008000;"> 初始化 newTab, length = 32;</span>
    table = newTab;            <span style="color: #008000;">//</span><span style="color: #008000;"> table 指向 newTab, length = 32;</span>
    <span style="color: #0000ff;">if</span> (oldTab != <span style="color: #0000ff;">null</span>) {    <span style="color: #008000;">//</span><span style="color: #008000;"> 扩容后，将 oldTab(旧table) 中的元素移到 newTab（新table）中</span>
        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = 0; j &lt; oldCap; ++<span style="color: #000000;">j) {
            Node</span>&lt;K,V&gt;<span style="color: #000000;"> e;
            </span><span style="color: #0000ff;">if</span> ((e = oldTab[j]) != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                oldTab[j] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (e.next == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                    newTab[e.hash </span>&amp; (newCap - 1)] = e;        <span style="color: #008000;">//</span> 
                <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (e <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> TreeNode)
                    ((TreeNode</span>&lt;K,V&gt;)e).split(<span style="color: #0000ff;">this</span><span style="color: #000000;">, newTab, j, oldCap);
                </span><span style="color: #0000ff;">else</span> { <span style="color: #008000;">//</span><span style="color: #008000;"> preserve order</span>
                    Node&lt;K,V&gt; loHead = <span style="color: #0000ff;">null</span>, loTail = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    Node</span>&lt;K,V&gt; hiHead = <span style="color: #0000ff;">null</span>, hiTail = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                    Node</span>&lt;K,V&gt;<span style="color: #000000;"> next;
                    </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
                        next </span>=<span style="color: #000000;"> e.next;
                        </span><span style="color: #0000ff;">if</span> ((e.hash &amp; oldCap) == 0<span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (loTail == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                                loHead </span>=<span style="color: #000000;"> e;
                            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
                                loTail.next </span>=<span style="color: #000000;"> e;
                            loTail </span>=<span style="color: #000000;"> e;
                        }
                        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            </span><span style="color: #0000ff;">if</span> (hiTail == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                                hiHead </span>=<span style="color: #000000;"> e;
                            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
                                hiTail.next </span>=<span style="color: #000000;"> e;
                            hiTail </span>=<span style="color: #000000;"> e;
                        }
                    } </span><span style="color: #0000ff;">while</span> ((e = next) != <span style="color: #0000ff;">null</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">if</span> (loTail != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                        loTail.next </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                        newTab[j] </span>=<span style="color: #000000;"> loHead;
                    }
                    </span><span style="color: #0000ff;">if</span> (hiTail != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                        hiTail.next </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                        newTab[j </span>+ oldCap] =<span style="color: #000000;"> hiHead;
                    }
                }
            }
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> newTab;
}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>　　　　自此，问题 2 的答案也就清晰了</p>
<src class="cnblogs_code">
<pre><code><span>什么时候触发扩容，扩容之后的 table.length、阀值各是多少
    当 size &gt;<span> threshold 的时候进行扩容
    扩容之后的 table.length = 旧 table.length * 2<span>,
    扩容之后的 threshold = 旧 threshold * 2</span></span></span></code></pre>

<h3>　　问题 3、4 ：2 的 n 次幂</h3>
<p>　　　　table 是一个数组，那么如何最快的将元素 e 放入数组 ？ 当然是找到元素 e 在 table 中对应的位置&nbsp;index ，然后 table[index] = e; 就好了；如何找到 e 在 table 中的位置了 ？ 我们知道只能通过数组下标（索引）操作数组，而数组的下标类型又是&nbsp; int ，如果 e 是 int 类型，那好说，就直接用 e 来做数组下标（若 e &gt; table.length，则可以 e % table.length 来获取下标），可&nbsp; key - value 中的 key 类型不一定，所以我们需要一种统一的方式将 key 转换成&nbsp; int ，最好是一个&nbsp; key 对应一个唯一的 int (目前还不可能, int有范围限制，对转换方法要求也极高)，所以引入了 hash 方法</p>
<src class="cnblogs_code">
<pre><code>static final int<span> hash(Object key) {
    int<span> h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16<span>);　　// 这里的处理，有兴趣的可以琢磨下；能够减少碰撞
}</span></span></span></code></pre>

<p>　　　　实现&nbsp;key 到 int 的转换（关于 hash，本文不展开讨论）。拿到了 key 对应的&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">int</span></span>&nbsp;h 之后，我们最容易想到的对 value 的&nbsp; put 和 get 操作也许如下</p>
<src class="cnblogs_code">
<pre><code>// put
table[h % table.length] =<span> value;

// get
e = table[h % table.length];</span></code></pre>

<p>　　　　直接取模是我们最容易想到的获取下标的方法，但是最高效的方法吗 ？</p>
<p>　　　　我们知道计算机中的四则运算最终都会转换成二进制的位运算</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！13.png" alt="" /></p>
<p>　　　　我们可以发现，只有 &amp; 数是1时，&amp; 运算的结果与被 &amp; 数一致</p>
<src class="cnblogs_code">
<pre><code>1&amp;1=1<span>;
0&amp;1=0<span>;
1&amp;0=0<span>;
0&amp;0=0;</span></span></span></code></pre>

<p>　　　　这同样适用于多位操作数</p>
<src class="cnblogs_code">
<pre><code>1010&amp;1111=1010;      =&gt; 10&amp;15=10<span>;
1011&amp;1111=1011;      =&gt; 11&amp;15=11<span>;
01010&amp;10000=00000;   =&gt; 10&amp;16=0<span>;
01011&amp;10000=00000;   =&gt; 11&amp;16=0;</span></span></span></code></pre>

<p>　　　　我们是不是又有所发现：&nbsp;10 &amp; 16 与 11 &amp; 16 得到的结果一样，也就是冲突（碰撞）了，那么 10 和 11 对应的 value 会在同一个链表中，而 table 的有些位置则永远不会有元素，这就导致 table 的空间未得到充分利用，同时还降低了 put 和 get 的效率（对比数组和链表）；由于是 2 个数进行 &amp; 运算，所以结果由这两个数决定，如果我们把这两个数都做下限制，那得到的结果是不是可控制在我们想要的范围内了 ？&nbsp; 我们需要利用好 &amp; 运算的特点，当右边的数的低位二进制是连续的 1 ，且左边是一个均匀的数（需要 hash 方法实现，尽量保证 key 的 h 唯一），那么得到的结果就比较完美了。低位二进制连续的 1，我们很容易想到 2^n - 1; 而关于左边均匀的数，则通过 hash 方法来实现，这里不做细究了。</p>
<p>　　　　自此，2 的 n 次幂的相关问题就清楚了</p>
<src class="cnblogs_code">
<pre><code>table 的 length 为什么是 2<span> 的 n 次幂
    为了利用位运算 &amp;<span> 求 key 的下标

求索引的时候为什么是：h&amp;(length-1)，而不是 h&amp;length，更不是 h%<span>length
    h%<span>length 效率不如位运算快
    h&amp;length 会提高碰撞几率，导致 table 的空间得不到更充分的利用、降低 table 的操作效率</span></span></span></span></code></pre>

<p>　　　　给各位留个疑问：<span style="color: #ff6600;">为什么不直接用 2^n-1 作为 table.length&nbsp;？</span> 欢迎评论区留言</p>
<h3>　　问题 5：指定&nbsp;initialCapacity</h3>
<p>　　　　当我们指定了&nbsp;initialCapacity，HashMap的构造方法有些许不同，如下所示　</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！14.png" alt="" width="700" /></p>
<p>　　　　调用&nbsp;<span class="cnblogs_code">tableSizeFor</span>&nbsp;进行&nbsp;<span class="cnblogs_code">threshold</span>&nbsp;的初始化</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('f8cab329-808d-44f1-8e9c-94f7a3fa90ec')"><img id="code_img_closed_f8cab329-808d-44f1-8e9c-94f7a3fa90ec" class="code_img_closed" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！1.png" alt="" /><img id="code_img_opened_f8cab329-808d-44f1-8e9c-94f7a3fa90ec" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f8cab329-808d-44f1-8e9c-94f7a3fa90ec',event)" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！2.png" alt="" />
<src id="cnblogs_code_open_f8cab329-808d-44f1-8e9c-94f7a3fa90ec" class="cnblogs_code_hide">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
 * Returns a power of two size for the given target capacity.
 * 返回 &gt;= cap 最小的 2^n
 * cap = 10, 则返回 2^4 = 16;
 * cap = 5, 则返回 2^3 = 8;
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> tableSizeFor(<span style="color: #0000ff;">int</span><span style="color: #000000;"> cap) {
    </span><span style="color: #0000ff;">int</span> n = cap - 1<span style="color: #000000;">;
    n </span>|= n &gt;&gt;&gt; 1<span style="color: #000000;">;
    n </span>|= n &gt;&gt;&gt; 2<span style="color: #000000;">;
    n </span>|= n &gt;&gt;&gt; 4<span style="color: #000000;">;
    n </span>|= n &gt;&gt;&gt; 8<span style="color: #000000;">;
    n </span>|= n &gt;&gt;&gt; 16<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1<span style="color: #000000;">;
}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>　　　　虽然此处初始化的是&nbsp;threshold，但后面初始化 table 的时候，会将其用于 table 的 length，同时会重置 threshold 为&nbsp;<span class="cnblogs_code">table.length * loadFactor</span>&nbsp;</p>
<p>　　　　自此，问题 5 也就清楚了</p>
<src class="cnblogs_code">
<pre><code>Map map = new HashMap(1000<span>); 当我们存入多少个元素时会触发map的扩容
    此时的 table.length = 2^10 = 1024; threshold = 1024 * 0.75 = 768; 所以存入第 769<span> 个元素时进行扩容

Map map1 = new HashMap(10000<span>); 我们存入第 10001个元素时会触发 map1 扩容吗
    此时的 table.length = 2^14 = 16384; threshold = 16384 * 0.75 = 12288; 所以存入第 10001 个元素时不会进行扩容</span></span></span></code></pre>

<h3>　　问题6：加载因子</h3>
<src class="cnblogs_code">
<pre><code>为什么加载因子的默认值是 0.75<span>，并且不推荐我们修改
    如果loadFactor太小，那么map中的table需要不断的扩容，扩容是个耗时的过程
    如果loadFactor太大，那么map中table放满了也不不会扩容，导致冲突越来越多，解决冲突而起的链表越来越长，效率越来越低
    而 0.75 这是一个折中的值，是一个比较理想的值</span></code></pre>

<h2>总结</h2>
<p>　　1、table.length = 2^n，是为了能利用位运算（&amp;）来求 key 的下标，而 h&amp;(length-1) 是为了充分利用 table 的空间，并减少 key 的碰撞</p>
<p>　　2、加载因子太小， table 需要不断的扩容，影响 put 效率；太大会导致碰撞越来越多，链表越来越长（转红黑树），影响效率；0.75 是一个比较理想的中间值</p>
<p>　　3、table.length = 2^n、hash 方法获取 key 的 h、加载因子 0.75、数组 + 链表（或红黑树），一环扣一环，保证了 key 在 table 中的均匀分配，充分利用了空间，也保证了操作效率</p>
<p>　　　　环环相扣的，而不是心血来潮的随意处理；缺了一环，其他的环就无意义了！</p>
<p>　　4、网上有个&nbsp;<span class="cnblogs_code">put</span>&nbsp;方法的流程图画的挺好，我就偷懒了</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/HashMap 中的容量与扩容实现，细致入微，值的一品！17.png" alt="" width="700" /></p>
<h2>参考</h2>
<p>　　<a href="https://www.cnblogs.com/chenssy/p/3521565.html" target="_blank">&nbsp;java提高篇（二三）-----HashMap</a><br />　　<a href="https://www.cnblogs.com/rjzheng/p/11302835.html%20" target="_blank">【原创】HashMap复习精讲</a><br />　　<a href="https://www.cnblogs.com/plokmju/p/hash_threshold.html" target="_blank">面试官："准备用HashMap存1w条数据，构造时传10000还会触发扩容吗？"</a></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>