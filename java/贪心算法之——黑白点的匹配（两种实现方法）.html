<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修贪心算法之——黑白点的匹配（两种实现方法）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>贪心算法之——黑白点的匹配（两种实现方法）</center></div><div class='banquan'>原文出处:本文由博客园博主脑热提供。<br/>
原文连接:https://www.cnblogs.com/Unicron/p/11574652.html</div><br>
    <h2>一、题目</h2>
<p><span style="font-size: 18px; font-family: 宋体;">设平面上分布着<span lang="EN-US">n个白点和<span lang="EN-US">n个黑点，每个点用一对坐标（<span lang="EN-US">x, y）表示。一个黑点<span lang="EN-US">b=（<span lang="EN-US">xb,yb）支配一个白点<span lang="EN-US">w=(xw, yw)当且仅当<span lang="EN-US">xb&gt;=xw和<span lang="EN-US">yb&gt;=yw。</span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 18px; font-family: 宋体;" lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">若黑点<span lang="EN-US">b支配白点<span lang="EN-US">w，则黑点<span lang="EN-US">b和白点<span lang="EN-US">w可匹配（可形成一个匹配对）。</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 18px; font-family: 宋体;" lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">在一个黑点最多只能与一个白点匹配，一个白点最多只能与一个黑点匹配的前提下，求<span lang="EN-US">n个白点和<span lang="EN-US">n个黑点的最大匹配对数。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<h2>二、解题思路</h2>
<p><span style="font-family: 宋体; font-size: 18px;">　　一看完题目，一开始的思路是先将黑白点分别存入两个数组中，再对两个数组分别进行对x和对y的排序，在实际实验过程中，发现排序完后数组的下标与点不好对应，这样就不容易确定一个点是否已经匹配过。</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">　　经过了解查阅后发现了最大匹配问题的算法，和本题类似，而且递归的操作复杂度远小于多次对数组的排序。</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">　　而且过多的排序也造成了算法思路难以理清。决定先学习掌握最大匹配度算法再考虑本题&hellip;</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">　　在查阅了最大匹配度问题的思想后，发现这是一种递归形式的方法，算法需要基于对二分图的遍历算法，这就需要学习DFS或者BFS，所以又去复习了一下这两个算法，在彻底掌握了之后终于可以步入正题了&hellip;</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">（dfs和bfs的执行动态图</span>）</p>
<p><a href="http://5b0988e595225.cdn.sohucs.com/images/20171101/f1f45fe9ca37425ba200180be89624b2.gif">http://5b0988e595225.cdn.sohucs.com/images/20171101/f1f45fe9ca37425ba200180be89624b2.gif</a></p>
<p><a href="http://5b0988e595225.cdn.sohucs.com/images/20171101/a85c0716fcc847f1915dddfcfd019c01.gif">http://5b0988e595225.cdn.sohucs.com/images/20171101/a85c0716fcc847f1915dddfcfd019c01.gif</a></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px; font-family: 宋体;">理解了最大匹配算法后，发现只要<span style="background-color: #00ff00;">在图遍历的基础上，多借助一个matching数组，用来储存各匹配点之间的联系，通过一些剪枝和判断就可以实现。</span></span></p>
<p><span style="font-size: 18px; font-family: 宋体;">我选择了DFS进行最大匹配算法的基础算法，DFS是对图做出处理，在空间上需要借助一张邻接矩阵，我的想法是将黑白点问题化作图，再根据题目的要求做出对应的邻接矩阵，这样再通过最大匹配就可以求解出来。</span></p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><span style="font-size: 18px; font-family: 宋体;">下面主要针对这两个问题讨论并通过具体例子演示最大匹配核心思想。</span></span></p>
<p><span style="color: #ff0000;"><strong>1</strong><strong>、如何将黑白点化作图：</strong></span></p>
<p>创建一个结构体</p>
<p>&nbsp;<img src="./images/贪心算法之——黑白点的匹配（两种实现方法）0.png" alt="" /></p>
<p>黑白点都看作顶点，只通过color进行区别</p>
<p><span style="color: #ff0000;"><strong>2</strong><strong>、如何求对应邻接矩阵：</strong></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对储存所有顶点的结构体数组做两次循环，若满足题目中黑点xy坐标大于白点，即将邻接矩阵该位置置为1。</p>
<p><span style="color: #ff0000;"><strong>3</strong><strong>、具体流程演示：</strong></span></p>
<p><img src="./images/贪心算法之——黑白点的匹配（两种实现方法）1.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="background-color: #00ff00; font-family: 幼圆; font-size: 14pt;">上图分析：</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">通过邻接表可以知道，2能控制4,7,8三点</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">一开始2就控制了4，跳过2点</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">接着5控制了7，跳过5点</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">6控制了7,但是7已经被5控制，这时回到5，</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">5控制了8，跳过5</span></p>
<p><span style="font-family: 宋体; font-size: 18px;">这时7没人控制，6控制7，流程结束，匹配度为3。</span></p>
<p>&nbsp;</p>
<h2>三、代码（DFS BFS两种实现方法）</h2>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">  1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MaxMatching {<span style="color: #008000;">//</span><span style="color: #008000;"> 基于DFS</span>
<span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> graph[][]; <span style="color: #008000;">//</span><span style="color: #008000;"> 邻接表 默认全为0</span>
<span style="color: #008080;">  4</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> n; <span style="color: #008000;">//</span><span style="color: #008000;"> 节点数</span>
<span style="color: #008080;">  5</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> visit[]; <span style="color: #008000;">//</span><span style="color: #008000;"> 是否访问</span>
<span style="color: #008080;">  6</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> matched[]; <span style="color: #008000;">//</span><span style="color: #008000;"> 是否已经匹配，对应的匹配点</span>
<span style="color: #008080;">  7</span>     <span style="color: #0000ff;">static</span> vertex V[];<span style="color: #008000;">////</span><span style="color: #008000;"> 结构体数组储存所有黑白</span>
<span style="color: #008080;">  8</span> 
<span style="color: #008080;">  9</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> vertex {<span style="color: #008000;">//</span><span style="color: #008000;"> 顶点结构体</span>
<span style="color: #008080;"> 10</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> color;<span style="color: #008000;">//</span><span style="color: #008000;"> 白:0 黑：1</span>
<span style="color: #008080;"> 11</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span><span style="color: #000000;"> Vx;
</span><span style="color: #008080;"> 12</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span><span style="color: #000000;"> Vy;
</span><span style="color: #008080;"> 13</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 14</span> 
<span style="color: #008080;"> 15</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Init() {
</span><span style="color: #008080;"> 16</span>         System.out.println("输入的黑白点总数为："<span style="color: #000000;">);
</span><span style="color: #008080;"> 17</span>         Scanner sc = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
</span><span style="color: #008080;"> 18</span>         n =<span style="color: #000000;"> sc.nextInt();
</span><span style="color: #008080;"> 19</span>         graph = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[n][n]; <span style="color: #008000;">//</span><span style="color: #008000;"> 邻接表 默认全为0</span>
<span style="color: #008080;"> 20</span>         visit = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[n]; <span style="color: #008000;">//</span><span style="color: #008000;"> 是否访问</span>
<span style="color: #008080;"> 21</span>         matched = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[n]; <span style="color: #008000;">//</span><span style="color: #008000;"> 是否已经匹配，对应的匹配点</span>
<span style="color: #008080;"> 22</span>         V = <span style="color: #0000ff;">new</span><span style="color: #000000;"> vertex[n];
</span><span style="color: #008080;"> 23</span>         InitGraph();<span style="color: #008000;">//</span><span style="color: #008000;"> 初始邻接矩阵</span>
<span style="color: #008080;"> 24</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 25</span> 
<span style="color: #008080;"> 26</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> InitGraph() {
</span><span style="color: #008080;"> 27</span>         Scanner sc = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
</span><span style="color: #008080;"> 28</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; i++) {<span style="color: #008000;">//</span><span style="color: #008000;"> 输入黑白点</span>
<span style="color: #008080;"> 29</span>             V[i] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> vertex();
</span><span style="color: #008080;"> 30</span>             System.out.println("please int color/x/y"<span style="color: #000000;">);
</span><span style="color: #008080;"> 31</span>             V[i].color =<span style="color: #000000;"> sc.nextInt();
</span><span style="color: #008080;"> 32</span>             V[i].Vx =<span style="color: #000000;"> sc.nextDouble();
</span><span style="color: #008080;"> 33</span>             V[i].Vy =<span style="color: #000000;"> sc.nextDouble();
</span><span style="color: #008080;"> 34</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 35</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; i++<span style="color: #000000;">) {
</span><span style="color: #008080;"> 36</span>             <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = 0; j &lt; n; j++<span style="color: #000000;">) {
</span><span style="color: #008080;"> 37</span>                 <span style="color: #0000ff;">if</span> (i != j &amp;&amp; (V[i].color == 1) &amp;&amp; (V[j].color == 0) &amp;&amp; (V[i].Vx &gt; V[j].Vx) &amp;&amp; (V[i].Vy &gt;<span style="color: #000000;"> V[j].Vy)) {
</span><span style="color: #008080;"> 38</span>                     graph[i][j] = 1<span style="color: #000000;">;
</span><span style="color: #008080;"> 39</span> <span style="color: #000000;">                }
</span><span style="color: #008080;"> 40</span> <span style="color: #000000;">            }
</span><span style="color: #008080;"> 41</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 42</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 43</span> 
<span style="color: #008080;"> 44</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 显示匹配结果</span>
<span style="color: #008080;"> 45</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
</span><span style="color: #008080;"> 46</span>         Arrays.fill(visit, 0<span style="color: #000000;">);
</span><span style="color: #008080;"> 47</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; i++<span style="color: #000000;">) {
</span><span style="color: #008080;"> 48</span>             <span style="color: #0000ff;">if</span> (visit[i] == 0<span style="color: #000000;">) {
</span><span style="color: #008080;"> 49</span>                 <span style="color: #0000ff;">if</span> (matched[i] != -1<span style="color: #000000;">) {
</span><span style="color: #008080;"> 50</span>                     System.out.println("(" + V[i].Vx + "," + V[i].Vy + ")与" + "(" + V[matched[i]].Vx + ","
<span style="color: #008080;"> 51</span>                             + V[matched[i]].Vy + ")" + "匹配"<span style="color: #000000;">);
</span><span style="color: #008080;"> 52</span>                     visit[i] = 1<span style="color: #000000;">;
</span><span style="color: #008080;"> 53</span>                     visit[matched[i]] = 1<span style="color: #000000;">;
</span><span style="color: #008080;"> 54</span> <span style="color: #000000;">                }
</span><span style="color: #008080;"> 55</span> <span style="color: #000000;">            }
</span><span style="color: #008080;"> 56</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 57</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 58</span> 
<span style="color: #008080;"> 59</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;"> 60</span> <span style="color: #008000;">     * dfs实现, params: x:起始的未匹配点 return: 1:找到增广路 0:未找到
</span><span style="color: #008080;"> 61</span>      <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 62</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> dfs_solve(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
</span><span style="color: #008080;"> 63</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 找到一个和节点存在边的点，并且该点在本轮中没有被访问过</span>
<span style="color: #008080;"> 64</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; i++<span style="color: #000000;">) {
</span><span style="color: #008080;"> 65</span>             <span style="color: #0000ff;">if</span> (graph[x][i] != 0 &amp;&amp; visit[i] == 0<span style="color: #000000;">) {
</span><span style="color: #008080;"> 66</span>                 visit[i] = 1; <span style="color: #008000;">//</span><span style="color: #008000;"> 标记为匹配过
</span><span style="color: #008080;"> 67</span>                 <span style="color: #008000;">//</span><span style="color: #008000;"> 按照交替路的模式找增广路，增广路相对于交替路的特性是就是，第一个节点和最后一个节点都是未匹配过的节点</span>
<span style="color: #008080;"> 68</span>                 <span style="color: #0000ff;">if</span> (matched[i] == -1 || dfs_solve(matched[i]) == 1) { <span style="color: #008000;">//</span><span style="color: #008000;"> 直接跳到matched[i]能够保证匹配边和未匹配边交替
</span><span style="color: #008080;"> 69</span>                     <span style="color: #008000;">//</span><span style="color: #008000;"> 说明找到了一个未匹配节点，将所有匹配边变为未匹配边，将所有未匹配边变为匹配边，这样匹配边数会加1,这个交换过程通过回溯实现</span>
<span style="color: #008080;"> 70</span> 
<span style="color: #008080;"> 71</span>                     matched[x] =<span style="color: #000000;"> i;
</span><span style="color: #008080;"> 72</span>                     matched[i] =<span style="color: #000000;"> x;
</span><span style="color: #008080;"> 73</span> 
<span style="color: #008080;"> 74</span> <span style="color: #000000;">                    System.out
</span><span style="color: #008080;"> 75</span>                             .println("(" + V[x].Vx + "," + V[x].Vy + ") 与 " + "(" + V[i].Vx + "," + V[i].Vy + ")" + "匹配"<span style="color: #000000;">);
</span><span style="color: #008080;"> 76</span>                     <span style="color: #0000ff;">return</span> 1<span style="color: #000000;">;
</span><span style="color: #008080;"> 77</span> <span style="color: #000000;">                }
</span><span style="color: #008080;"> 78</span> <span style="color: #000000;">            }
</span><span style="color: #008080;"> 79</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 80</span>         <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
</span><span style="color: #008080;"> 81</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 82</span> 
<span style="color: #008080;"> 83</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> hungarian1() {
</span><span style="color: #008080;"> 84</span>         Arrays.fill(matched, -1<span style="color: #000000;">);
</span><span style="color: #008080;"> 85</span>         <span style="color: #0000ff;">int</span> sum = 0<span style="color: #000000;">;
</span><span style="color: #008080;"> 86</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; i++<span style="color: #000000;">) {
</span><span style="color: #008080;"> 87</span>             <span style="color: #0000ff;">if</span> (matched[i] == -1<span style="color: #000000;">) {
</span><span style="color: #008080;"> 88</span>                 System.out.println("从 " + "(" + V[i].Vx + "," + V[i].Vy + ")" + " 开始匹配"<span style="color: #000000;">);
</span><span style="color: #008080;"> 89</span>                 Arrays.fill(visit, 0);<span style="color: #008000;">//</span><span style="color: #008000;"> 重置浏览数组，用来浏览邻接矩阵当前列</span>
<span style="color: #008080;"> 90</span>                 sum +=<span style="color: #000000;"> dfs_solve(i);
</span><span style="color: #008080;"> 91</span> <span style="color: #000000;">            }
</span><span style="color: #008080;"> 92</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 93</span>         System.out.println("\n"+"最后共有 " + sum + " 匹配项"<span style="color: #000000;">);
</span><span style="color: #008080;"> 94</span> <span style="color: #000000;">        show();
</span><span style="color: #008080;"> 95</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 96</span> 
<span style="color: #008080;"> 97</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 98</span>         MaxMatching mm = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MaxMatching();
</span><span style="color: #008080;"> 99</span> <span style="color: #000000;">        mm.Init();
</span><span style="color: #008080;">100</span> <span style="color: #000000;">        mm.hungarian1();
</span><span style="color: #008080;">101</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">102</span> }</code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>