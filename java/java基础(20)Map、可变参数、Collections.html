<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(20)Map、可变参数、Collections' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(20)Map、可变参数、Collections</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11650720.html</div><br>
    <h1>1.&nbsp;<strong>Map<span style="font-family: 宋体;">接口</span></strong></h1>
<h2><!--[if !supportLists]-->1.1&nbsp;<!--[endif]--><strong>Map<span style="font-family: 华文楷体;">接口概述</span></strong></h2>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">我们通过查看</span>Map<span style="font-family: 宋体;">接口描述，发现</span><span style="font-family: Calibri;">Map</span><span style="font-family: 宋体;">接口下的集合与</span><span style="font-family: Calibri;">Collection</span><span style="font-family: 宋体;">接口下的集合，它们存储数据的形式不同，如下图。</span></p>
<p>&nbsp;</p>
<blockquote>
<p class="16">Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</p>
<p>&nbsp;</p>
<p class="16">Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</p>
<p>&nbsp;</p>
<p class="16">Collection中的集合称为单列集合，Map中的集合称为双列集合。</p>
<p>&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">需要注意的是，</span>Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</p>
<p>&nbsp;</p>
<p class="16">Map中常用的集合为HashMap集合、LinkedHashMap集合。</p>
</blockquote>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections0.png" alt="" width="924" height="403" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><!--[if !supportLists]-->1.2&nbsp;<!--[endif]--><strong>Map<span style="font-family: 华文楷体;">接口中常用集合概述</span></strong></h2>
<p><span style="font-family: 宋体;">通过查看</span>Map<span style="font-family: 宋体;">接口描述，看到</span><span style="font-family: Calibri;">Map</span><span style="font-family: 宋体;">有多个子类，这里我们主要讲解常用的</span><span style="font-family: Calibri;">HashMap</span><span style="font-family: 宋体;">集合、</span><span style="font-family: Calibri;">LinkedHashMap</span><span style="font-family: 宋体;">集合。</span></p>
<p class="16"><!--[if !supportLists]--><strong>HashMap&lt;K,V&gt;</strong><span style="font-family: 宋体;">：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的</span>hashCode()方法、equals()方法。</p>
<p class="16"><!--[if !supportLists]--><strong>LinkedHashMap&lt;K,V&gt;</strong><span style="font-family: 宋体;">：</span>HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p>
<p class="16"><!--[if !supportLists]--><strong><span style="font-family: 宋体;">注意</span></strong><span style="font-family: 宋体;">：</span>Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
<h2><!--[if !supportLists]-->1.3&nbsp;<strong>Map<span style="font-family: 华文楷体;">接口中的常用方法</span></strong></h2>
<p><strong><span style="font-family: 华文楷体;"><img src="./images/java基础(20)Map、可变参数、Collections1.png" alt="" /></span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<blockquote>
<p class="16">put方法：将指定的键与值对应起来，并添加到集合中</p>
<p class="16">　　方法返回值为键所对应的值</p>
<p class="16"><span style="font-family: 宋体;">　　　　使用</span>put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；</p>
<p><span style="font-family: 宋体;">　　　　使用</span>put<span style="font-family: 宋体;">方法时，若指定的键</span><span style="font-family: Calibri;">(key)</span><span style="font-family: 宋体;">在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</span></p>
<p class="16">get方法：获取指定键(key)所对应的值(value)</p>
<p class="16">remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)。</p>
</blockquote>
<p class="16">Map接口的方法演示</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MapDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建Map对象</span>
        Map&lt;String, String&gt; map = <span style="color: #0000ff;">new</span> HashMap&lt;String,String&gt;<span style="color: #000000;">();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">给map中添加元素</span>
        map.put("星期一", "Monday"<span style="color: #000000;">);
        map.put(</span>"星期日", "Sunday"<span style="color: #000000;">);
        System.out.println(map); </span><span style="color: #008000;">//</span><span style="color: #008000;"> {星期日=Sunday, 星期一=Monday}

        </span><span style="color: #008000;">//</span><span style="color: #008000;">当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null</span>
        System.out.println(map.put("星期一", "Mon")); <span style="color: #008000;">//</span><span style="color: #008000;"> Monday</span>
        System.out.println(map); <span style="color: #008000;">//</span><span style="color: #008000;"> {星期日=Sunday, 星期一=Mon}

        </span><span style="color: #008000;">//</span><span style="color: #008000;">根据指定的key获取对应的value</span>
        String en = map.get("星期日"<span style="color: #000000;">);
        System.out.println(en); </span><span style="color: #008000;">//</span><span style="color: #008000;"> Sunday
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">根据key删除元素,会返回key对应的value值</span>
        String value = map.remove("星期日"<span style="color: #000000;">);
        System.out.println(value); </span><span style="color: #008000;">//</span><span style="color: #008000;"> Sunday</span>
        System.out.println(map); <span style="color: #008000;">//</span><span style="color: #008000;"> {星期一=Mon}</span>
<span style="color: #000000;">    }
}</span></code></pre>

<h2><!--[if !supportLists]-->1.4&nbsp;<!--[endif]--><strong>Map<span style="font-family: 华文楷体;">集合遍历键找值方式</span></strong></h2>
<p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>操作步骤与图解：</p>
<p>1.<span style="font-family: 宋体;">获取</span><span style="font-family: Calibri;">Map</span><span style="font-family: 宋体;">集合中所有的键，由于键是唯一的，所以返回一个</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">集合存储所有的键</span></p>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>2.<span style="font-family: 宋体;">遍历键的</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">集合，得到每一个键</span></p>
<p>3.<span style="font-family: 宋体;">根据键，获取键所对应的值</span></p>
<p><span style="font-family: 宋体;"><img src="./images/java基础(20)Map、可变参数、Collections3.png" alt="" /></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MapDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建Map对象</span>
        Map&lt;String, String&gt; map = <span style="color: #0000ff;">new</span> HashMap&lt;String,String&gt;<span style="color: #000000;">();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">给map中添加元素</span>
        map.put("邓超", "孙俪"<span style="color: #000000;">);
        map.put(</span>"李晨", "范冰冰"<span style="color: #000000;">);
                map.put(</span>"刘德华", "柳岩"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取Map中的所有key</span>
        Set&lt;String&gt; keySet =<span style="color: #000000;"> map.keySet();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历存放所有key的Set集合</span>
        Iterator&lt;String&gt; it =<span style="color: #000000;">keySet.iterator();
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">得到每一个key</span>
            String key =<span style="color: #000000;"> it.next();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">通过key获取对应的value</span>
            String value =<span style="color: #000000;"> map.get(key);
            System.out.println(key</span>+"="+<span style="color: #000000;">value);
        }
    }
}    </span></code></pre>

<h2><!--[if !supportLists]-->1.5&nbsp;<!--[endif]--><strong>Entry<span style="font-family: 华文楷体;">键值对对象</span></strong></h2>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">在</span>Map<span style="font-family: 宋体;">类设计时，提供了一个嵌套接口：</span><span style="font-family: Calibri;">Entry</span><span style="font-family: 宋体;">。</span><span style="font-family: Calibri;">Entry</span><span style="font-family: 宋体;">将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历</span><span style="font-family: Calibri;">Map</span><span style="font-family: 宋体;">集合时，就可以从每一个键值对（</span><span style="font-family: Calibri;">Entry</span><span style="font-family: 宋体;">）对象中获取对应的键与对应的值。</span></p>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections4.png" alt="" /></p>
<p>Entry是Map接口中提供的一个静态内部嵌套接口。</p>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections5.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>getKey()方法：获取Entry对象中的键</p>
<p class="16">getValue()方法：获取Entry对象中的值</p>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections6.png" alt="" /></p>
<p>entrySet()<span style="font-family: 宋体;">方法</span><span style="font-family: 宋体;">：用于返回</span>Map<span style="font-family: 宋体;">集合中所有的键值对</span><span style="font-family: Calibri;">(Entry)</span><span style="font-family: 宋体;">对象，以</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">集合形式返回。</span></p>
<h2><!--[if !supportLists]-->1.6&nbsp;<!--[endif]--><strong>Map<span style="font-family: 华文楷体;">集合遍历键值对方式</span></strong></h2>
<p><span style="font-family: 宋体;">键值对方式：即通过集合中每个键值对</span>(Entry)<span style="font-family: 宋体;">对象，获取键值对</span><span style="font-family: Calibri;">(Entry)</span><span style="font-family: 宋体;">对象中的键与值。</span></p>
<p>操作步骤与图解：</p>
<p>1.<span style="font-family: 宋体;">获取</span><span style="font-family: Calibri;">Map</span><span style="font-family: 宋体;">集合中，所有的键值对</span><span style="font-family: Calibri;">(Entry)</span><span style="font-family: 宋体;">对象，以</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">集合形式返回。</span></p>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections7.png" alt="" /></p>
<p>2.<span style="font-family: 宋体;">遍历包含</span><span style="font-family: 宋体;">键值对</span>(Entry)<span style="font-family: 宋体;">对象的</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">集合，得到每一个键值对</span><span style="font-family: Calibri;">(Entry)</span><span style="font-family: 宋体;">对象</span></p>
<p>3.<span style="font-family: 宋体;">通过键值对</span><span style="font-family: Calibri;">(Entry)</span><span style="font-family: 宋体;">对象，获取</span><span style="font-family: Calibri;">Entry</span><span style="font-family: 宋体;">对象中的键与值。</span></p>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections8.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/java基础(20)Map、可变参数、Collections9.png" alt="" /></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MapDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建Map对象</span>
        Map&lt;String, String&gt; map = <span style="color: #0000ff;">new</span> HashMap&lt;String,String&gt;<span style="color: #000000;">();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">给map中添加元素</span>
        map.put("邓超", "孙俪"<span style="color: #000000;">);
        map.put(</span>"李晨", "范冰冰"<span style="color: #000000;">);
        map.put(</span>"刘德华", "柳岩"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取Map中的所有key与value的对应关系</span>
        Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet =<span style="color: #000000;"> map.entrySet();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历Set集合</span>
        Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it =<span style="color: #000000;">entrySet.iterator();
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">得到每一对对应关系</span>
            Map.Entry&lt;String,String&gt; entry =<span style="color: #000000;"> it.next();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">通过每一对对应关系获取对应的key</span>
            String key =<span style="color: #000000;"> entry.getKey();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">通过每一对对应关系获取对应的value</span>
            String value =<span style="color: #000000;"> entry.getValue();
            System.out.println(key</span>+"="+<span style="color: #000000;">value);
        }
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">注意：</span>Map<span style="font-family: 宋体;">集合不能直接使用迭代器或者</span><span style="font-family: Calibri;">foreach</span><span style="font-family: 宋体;">进行遍历。但是转成</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">之后就可以使用了。</span></p>
<p>&nbsp;</p>
<h2><!--[if !supportLists]-->1.7&nbsp;<!--[endif]--><strong>HashMap</strong><strong>存储自定义类型键值</strong></h2>
<p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键,&nbsp;家庭住址作为值。</p>
<p>注意，学生姓名相同并且年龄相同视为同一名学生。</p>
<p class="16">学生类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Student {
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">编写构造方法，文档中已省略
    </span><span style="color: #008000;">//</span><span style="color: #008000;">编写get,set方法，文档中已省略
    </span><span style="color: #008000;">//</span><span style="color: #008000;">编写toString方法，文档中已省略</span>
}</code></pre>

<p class="16">测试类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> HashMapTest {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,创建hashmap集合对象。</span>
        Map&lt;Student,String&gt; map = <span style="color: #0000ff;">new</span> HashMap&lt;Student,String&gt;<span style="color: #000000;">();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,添加元素。</span>
        map.put(<span style="color: #0000ff;">new</span> Student("lisi",28), "上海"<span style="color: #000000;">);
        map.put(</span><span style="color: #0000ff;">new</span> Student("wangwu",22), "北京"<span style="color: #000000;">);
        map.put(</span><span style="color: #0000ff;">new</span> Student("zhaoliu",24), "成都"<span style="color: #000000;">);
        map.put(</span><span style="color: #0000ff;">new</span> Student("zhouqi",25), "广州"<span style="color: #000000;">);
        map.put(</span><span style="color: #0000ff;">new</span> Student("wangwu",22), "南京"<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3,取出元素。键找值方式</span>
        Set&lt;Student&gt; keySet =<span style="color: #000000;"> map.keySet();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(Student key : keySet){
            String value </span>=<span style="color: #000000;"> map.get(key);
            System.out.println(key.toString()</span>+"....."+<span style="color: #000000;">value);
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">取出元素。键值对方式</span>
        Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet =<span style="color: #000000;"> map.entrySet();
        </span><span style="color: #0000ff;">for</span> (Map.Entry&lt;Student, String&gt;<span style="color: #000000;"> entry : entrySet) {
            Student key </span>=<span style="color: #000000;"> entry.getKey();
            String value </span>=<span style="color: #000000;"> entry.getValue();
            System.out.println(key.toString()</span>+"....."+<span style="color: #000000;">value);
        }
    }
}</span></code></pre>

<p class="16"><span style="font-family: 宋体;">当给</span>HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</p>
<p class="16"><span style="font-family: 宋体;">如果要保证</span>map中存放的key和取出的顺序一致，可以使用LinkedHashMap集合来存放。</p>
<h2><!--[if !supportLists]-->1.8&nbsp;<!--[endif]--><strong>静态导入</strong></h2>
<p>在导包的过程中我们可以直接导入静态部分，这样某个类的静态成员就可以直接使用了。在源码中经常会出现静态导入。</p>
<p>静态导入格式：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span> <span style="color: #0000ff;">static</span> XXX.YYY;   导入后YYY可直接使用。 </code></pre>

<p><span style="font-family: 宋体;">例如：</span>Map.Entry<span style="font-family: 宋体;">的访问，简化后为</span><span style="font-family: Calibri;">Entry</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> java.util.Map.Entry;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> HashMapTest {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,创建hashmap集合对象。</span>
        Map&lt;Student,String&gt; map = <span style="color: #0000ff;">new</span> HashMap&lt;Student,String&gt;<span style="color: #000000;">();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">取出元素。键值对方式
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();</span>
        Set&lt;Entry&lt;Student, String&gt;&gt; entrySet =<span style="color: #000000;"> map.entrySet();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">for (Map.Entry&lt;Student, String&gt; entry : entrySet) {</span>
        <span style="color: #0000ff;">for</span> (Entry&lt;Student, String&gt;<span style="color: #000000;"> entry : entrySet) {
            Student key </span>=<span style="color: #000000;"> entry.getKey();
            String value </span>=<span style="color: #000000;"> entry.getValue();
            System.out.println(key.toString()</span>+"....."+<span style="color: #000000;">value);
        }
    }
}</span></code></pre>

<p>&nbsp;</p>
<h2><!--[if !supportLists]--><span style="font-family: 华文楷体; font-size: 16pt;">1.9&nbsp;</span><!--[endif]--><strong><span style="font-family: 华文楷体; font-size: 16pt;">可变参数</span></strong></h2>
<p>&nbsp;</p>
<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;"><span style="font-family: 宋体;">在</span>JDK1.5<span style="font-family: 宋体;">之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</span></span></p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code>修饰符 返回值类型 方法名(参数类型... 形参名){  }</code></pre>

<p class="16">&nbsp;</p>
<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">其实这个书写完全等价与</span></p>
<src class="cnblogs_code">
<pre><code>修饰符 返回值类型 方法名(参数类型[] 形参名){  }</code></pre>

<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</span></p>
<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; color: #ff0000; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">dk1.5<span style="font-family: 宋体;">以后。出现了简化操作。</span></span><strong><span style="font-family: 宋体; color: #ff0000; font-size: 10.5pt;">...</span></strong><span style="mso-spacerun: 'yes'; font-family: 宋体; color: #ff0000; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">&nbsp;<span style="font-family: 宋体;">用在参数上，称之为可变参数。</span></span></p>
<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;"><span style="font-family: 宋体;">同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组</span>(<span style="font-family: 宋体;">这就是简单之处</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">，直接将数组中的元素作为实际参数进行传递，其实编译成的</span><span style="font-family: Calibri;">class</span><span style="font-family: 宋体;">文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译</span><span style="font-family: Calibri;">.class</span><span style="font-family: 宋体;">文件时，自动完成了。</span></span></p>
<p class="16">&nbsp;</p>
<p class="MsoNormal"><span style="mso-spacerun: 'yes'; font-family: 宋体; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">代码演示：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ParamDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">int</span>[] arr = {21,89,32<span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> sum =<span style="color: #000000;"> add(arr);
        System.out.println(sum);
        sum </span>= add(21,89,32);<span style="color: #008000;">//</span><span style="color: #008000;">可变参数调用形式</span>
<span style="color: #000000;">        System.out.println(sum);
        
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">JDK1.5之后写法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;">...arr){
        </span><span style="color: #0000ff;">int</span> sum = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; arr.length; i++<span style="color: #000000;">) {
            sum </span>+=<span style="color: #000000;"> arr[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> sum;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">原始写法</span>
    <span style="color: #008000;">/*</span><span style="color: #008000;">
    public static int add(int[] arr) {
        int sum = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
    </span><span style="color: #008000;">*/</span><span style="color: #000000;">
}</span></code></pre>

<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;"><span style="font-family: 宋体;">上述</span>add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</span></p>
<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; color: #ff0000; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</span></p>
<h2><!--[if !supportLists]--><span style="font-family: 华文楷体; font-size: 16pt;">1.10&nbsp;</span><!--[endif]--><strong><span style="font-family: 华文楷体; font-size: 16pt;">Collections<span style="font-family: 华文楷体;">集合工具类</span></span></strong></h2>
<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;">Collections<span style="font-family: 宋体;">是集合工具类，用来对集合进行操作。部分方法如下：</span></span></p>
<p class="16"><img src="./images/java基础(20)Map、可变参数、Collections10.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 10.5pt; font-family: 宋体;">public static &lt;T&gt; void sort(List&lt;T&gt; list)</span><span style="font-size: 10.5pt; font-family: 宋体;">&nbsp;// 集合元素排序</span></p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">排序前元素list集合元素 [33,11,77,55]</span>
<span style="color: #000000;">Collections.sort( list );
</span><span style="color: #008000;">//</span><span style="color: #008000;">排序后元素list集合元素 [11,33,55,77]</span></code></pre>

<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">public static void shuffle(List&lt;?&gt; list)</span><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">&nbsp;// &nbsp;集合元素存储位置打乱</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">list集合元素 [11,33,55,77]</span>
<span style="color: #000000;">Collections.shuffle( list );
</span><span style="color: #008000;">//</span><span style="color: #008000;">使用shuffle方法后，集合中的元素为[77,33,11,55]，每次执行该方法，集合中存储的元素位置都会随机打乱</span></code></pre>

<h2 style="margin-right: 10.5000pt; margin-left: 10.5000pt; mso-para-margin-right: 1.0000gd; mso-para-margin-left: 1.0000gd; mso-list: l0 level2 lfo1;"><!--[if !supportLists]--><span style="font-family: 华文楷体; font-size: 16pt;">1.11&nbsp;</span><!--[endif]--><strong><span style="font-family: 华文楷体; font-size: 16pt;">集合嵌套</span></strong></h2>
<p class="MsoNormal" style="text-indent: 21.0000pt;"><span style="mso-spacerun: 'yes'; font-family: 宋体; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;"><span style="font-family: 宋体;">集合嵌套并不是一个新的知识点，仅仅是集合内容又是集合，如</span>Collection<span style="font-family: 宋体;">集合嵌套、</span><span style="font-family: Calibri;">Collection</span><span style="font-family: 宋体;">集合与</span><span style="font-family: Calibri;">Map</span><span style="font-family: 宋体;">集合相互嵌套、</span><span style="font-family: Calibri;">Map</span><span style="font-family: 宋体;">集合嵌套。</span></span></p>
<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">ArrayList嵌套 ArrayList</span></p>
<src class="cnblogs_code">
<pre><code>ArrayList&lt; ArrayList&lt;String&gt; &gt;<span style="color: #000000;">
Collection</span>&lt; ArrayList&lt;Integer&gt; &gt;</code></pre>

<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">Map嵌套 ArrayList</span></p>
<src class="cnblogs_code">
<pre><code>HashMap&lt;String, ArrayList&lt;Person&gt;&gt;<span style="color: #000000;">
ArrayList</span>&lt; HashMap&lt;String, String&gt;&gt;</code></pre>

<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">Map集合嵌套</span></p>
<src class="cnblogs_code">
<pre><code>HashMap&lt;String, HashMap&lt;String,String&gt;&gt;<span style="color: #000000;">
HashMap</span>&lt;String, HashMap&lt;Person,String&gt;&gt;</code></pre>

<h2><!--[if !supportLists]--><span style="font-family: 华文楷体; font-size: 16pt;">1.12&nbsp;</span><!--[endif]--><strong><span style="font-family: 华文楷体; font-size: 16pt;">集合继承体系的面向对象思想</span></strong></h2>
<p class="16"><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;"><img src="./images/java基础(20)Map、可变参数、Collections11.png" alt="" width="804" height="355" /></span></p>
<p>&nbsp;</p>
<p class="16">&nbsp;</p>
<p>&nbsp;</p>
<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">接口：用来明确所有集合中该具有的功能，相当于在定义集合功能标准；</span></p>
<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">抽象类：把多个集合中功能实现方式相同的方法，抽取到抽象类实现，具体集合不再遍写，继承使用即可；</span></p>
<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">具体类：继承抽象类，实现接口，重写所有抽象方法，达到具备指定功能的集合。每个具体集合类，根据自身的数据存储结构方式，对接口中的功能方法，进行不同方式的实现。</span></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>