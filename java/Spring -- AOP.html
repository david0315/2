<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Spring -- AOP' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Spring -- AOP</center></div><div class='banquan'>原文出处:本文由博客园博主累成一条狗提供。<br/>
原文连接:https://www.cnblogs.com/l-y-h/p/11567708.html</div><br>
    <h2>一、AOP</h2>
<h3>1、什么是AOP</h3>
<p>　　AOP（Aspect-Oriented Programming，面向切面编程），通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br />　　可以理解为是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构（可以理解为从上到下关系）。 简单的说，OOP是将 多个类似的对象的属性与行为封装在一起，并对其进行操作。而AOP是将 不同的对象的 相同行为 封装在一起，并进行操作（可以理解为从左到右的关系）。<br />　　比如：日志文件，使用OOP时，在不同的对象中可能需要进行同样的日志打印操作，这些代码大量重复出现，代码冗余且重用率低。而使用AOP后，其可以将这些相同的日志打印操作抽取出来，并进行一系列操作，最终降低代码冗余。</p>
<h3>2、基本概念</h3>
<p>（1）横切（cross-cutting）代码：<br />　　散布在各个类中，但与核心代码无关的代码。可以理解为 与业务代码无关，但是被经常使用到的代码。比如打印日志。</p>
<p>（2）核心关注点：<br />　　可以理解为 主要的业务流程。</p>
<p>（3）横切关注点：<br />　　可以理解为 与业务流程无关，但又出现在业务流程中的流程。比如：日志、权限认证、事务处理等。</p>
<p>（4）切面（Aspect）：<br />　　一种模块化机制，横切关注点的模块化，可以理解为 将各个类中的公共行为封装到一个可重用模块。</p>
<p>（5）连接点（Join point）：<br />　　连接点指的是在程序运行过程中，能够插入切面的一个点，这个点可以是类的某个方法调用前、调用后、方法抛出异常后等。切面代码可以利用这些点插入到应用的正常流程之中，并添加行为。</p>
<p>（6）通知/增强（Advice）：<br />　　在特定的连接点，AOP框架执行的动作。<br />　　分类：<br />　　　　前置通知（Before）：在目标方法被调用之前调用通知功能。<br />　　　　后置通知（After）：在目标方法完成之后调用通知，无论该方法是否发生异常。<br />　　　　后置返回通知（After-returning）：在目标方法成功执行之后调用通知。<br />　　　　后置异常通知（After-throwing）：在目标方法抛出异常后调用通知。<br />　　　　环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p>
<p>（7）切点（Pointcut）：<br />　　指的是一个通知将被引发的一系列连接点的集合。AOP 通过切点定位到特定的连接点。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。每个类都可以拥有多个连接点。</p>
<p>（8）引入（Introduction）：<br />　　添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。</p>
<p>（9）目标对象（Target Object）：<br />　　包含连接点的对象。也被称作被通知或被代理对象。</p>
<p>（10）AOP代理（AOP Proxy）：<br />　　AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
<p>（11）织入(Weaving)：<br />　　织入描述的是把切面应用到目标对象来创建新的代理对象的过程。 Spring AOP 的切面是在运行时被织入，原理是使用了动态代理技术。Spring支持两种方式生成代理对象：JDK动态代理和CGLib，默认的策略是如果目标类是接口，则使用JDK动态代理技术（只对实现接口的类产生代理对象），否则使用Cglib来生成代理。</p>
<p>&nbsp;</p>
<h2>二、AOP的使用</h2>
<h3>1、小案例分析</h3>
<p>　　现有功能：一个简单的计算器，能进行简单的加减乘除。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【实例一：】

【Calculator.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器接口，定义常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> Calculator {
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 加法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相加结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 减法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相减结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 乘法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相乘结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 除法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相除结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> div(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);
}


【CalculatorImpl.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器实现类，实现常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Calculator {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a -<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a *<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> div(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">if</span>(b == 0<span style="color: #000000;">){
            System.out.println(</span>"除数不能为0"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> a /<span style="color: #000000;"> b;
    }
}


【Main.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 测试类
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Calculator calculator </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> CalculatorImpl();
        </span><span style="color: #0000ff;">double</span> a = 3.0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> b = 2.0<span style="color: #000000;">;
        System.out.println(</span>"a + b = " + calculator.add(a, b)); <span style="color: #008000;">//</span><span style="color: #008000;"> a + b = 5.0</span>
        System.out.println("a - b = " + calculator.sub(a, b)); <span style="color: #008000;">//</span><span style="color: #008000;"> a - b = 1.0</span>
        System.out.println("a * b = " + calculator.mul(a, b)); <span style="color: #008000;">//</span><span style="color: #008000;"> a * b = 6.0</span>
        System.out.println("a / b = " + calculator.div(a, b)); <span style="color: #008000;">//</span><span style="color: #008000;"> a / b = 1.5</span>
<span style="color: #000000;">    }
}
}</span></code></pre>

<p>&nbsp;</p>
<p>　　需增加的功能：每次加减乘除的前后，都需要进行打印日志操作。</p>
<h3>2、不使用AOP时</h3>
<p>（1）思路：在加减乘除方法的前后，可以增加一个方法调用，进行日志输出。<br />（2）实现：（在实例一的基础上修改）</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【实例二：】

【CalculatorImpl.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器实现类，实现常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Calculator {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"add"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">double</span> c = a +<span style="color: #000000;"> b;
        afterMethod(</span>"add"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"sub"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">double</span> c = a -<span style="color: #000000;"> b;
        afterMethod(</span>"sub"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"mul"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">double</span> c = a *<span style="color: #000000;"> b;
        afterMethod(</span>"mul"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> div(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"div"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">if</span> (b == 0<span style="color: #000000;">) {
            System.out.println(</span>"除数不能为0"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">double</span> c = 0<span style="color: #000000;">;
            afterMethod(</span>"div"<span style="color: #000000;">, c);
            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">double</span> c = a /<span style="color: #000000;"> b;
        afterMethod(</span>"div"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 在业务方法前执行打印日志操作
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> methodName 方法名
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> beforeMethod(String methodName, <span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        System.out.println(</span>"This method " + methodName + " begins with " + a + " , " +<span style="color: #000000;"> b);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 在业务方法前执行后打印日志操作
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> methodName 方法名
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> afterMethod(String methodName, <span style="color: #0000ff;">double</span><span style="color: #000000;"> c) {
        System.out.println(</span>"This method " + methodName + " ends with " +<span style="color: #000000;"> c);
    }
}

【执行结果：】
This method add begins with </span>3.0 , 2.0<span style="color: #000000;">
This method add ends with </span>5.0<span style="color: #000000;">
a </span>+ b = 5.0<span style="color: #000000;">
This method sub begins with </span>3.0 , 2.0<span style="color: #000000;">
This method sub ends with </span>1.0<span style="color: #000000;">
a </span>- b = 1.0<span style="color: #000000;">
This method mul begins with </span>3.0 , 2.0<span style="color: #000000;">
This method mul ends with </span>6.0<span style="color: #000000;">
a </span>* b = 6.0<span style="color: #000000;">
This method div begins with </span>3.0 , 2.0<span style="color: #000000;">
This method div ends with </span>1.5<span style="color: #000000;">
a </span>/ b = 1.5</code></pre>

<p>&nbsp;</p>
<p>（3）优缺点分析：<br />　　代码直观，但是冗余严重，当修改某个部分时，可能会造成大量修改。</p>
<h3>3、不使用AOP时，代码稍微升点级</h3>
<p>（1）实例二可能会暴露的问题：对于不同的类，可能需要使用相同的日志操作，若是使用实例二的写法，那么在每个类里面都需定义日志操作方法，造成代码冗余。<br />　　解决： 在实例二的基础上，将日志操作抽取出来，形成一个类。当需要使用日志时，继承该类即可。</p>
<p><br />（2）实现：（在实例二的基础上修改）</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【实例三：】

【Message.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Message {
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 在业务方法前执行打印日志操作
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> methodName 方法名
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> beforeMethod(String methodName, <span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        System.out.println(</span>"This method " + methodName + " begins with " + a + " , " +<span style="color: #000000;"> b);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 在业务方法前执行后打印日志操作
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> methodName 方法名
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> afterMethod(String methodName, <span style="color: #0000ff;">double</span><span style="color: #000000;"> c) {
        System.out.println(</span>"This method " + methodName + " ends with " +<span style="color: #000000;"> c);
    }
}


【CalculatorImpl.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器实现类，实现常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorImpl <span style="color: #0000ff;">extends</span> Message <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Calculator {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"add"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">double</span> c = a +<span style="color: #000000;"> b;
        afterMethod(</span>"add"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"sub"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">double</span> c = a -<span style="color: #000000;"> b;
        afterMethod(</span>"sub"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"mul"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">double</span> c = a *<span style="color: #000000;"> b;
        afterMethod(</span>"mul"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> div(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        beforeMethod(</span>"div"<span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">if</span> (b == 0<span style="color: #000000;">) {
            System.out.println(</span>"除数不能为0"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">double</span> c = 0<span style="color: #000000;">;
            afterMethod(</span>"div"<span style="color: #000000;">, c);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
        }
        </span><span style="color: #0000ff;">double</span> c = a /<span style="color: #000000;"> b;
        afterMethod(</span>"div"<span style="color: #000000;">, c);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
    }
}


【结果：】
This method add begins with </span>3.0 , 2.0<span style="color: #000000;">
This method add ends with </span>5.0<span style="color: #000000;">
a </span>+ b = 5.0<span style="color: #000000;">
This method sub begins with </span>3.0 , 2.0<span style="color: #000000;">
This method sub ends with </span>1.0<span style="color: #000000;">
a </span>- b = 1.0<span style="color: #000000;">
This method mul begins with </span>3.0 , 2.0<span style="color: #000000;">
This method mul ends with </span>6.0<span style="color: #000000;">
a </span>* b = 6.0<span style="color: #000000;">
This method div begins with </span>3.0 , 2.0<span style="color: #000000;">
This method div ends with </span>1.5<span style="color: #000000;">
a </span>/ b = 1.5</code></pre>

<p>（3）优缺点：<br />　　采用纵向继承（从上到下），可以减少代码冗余，但是局限性太大。</p>
<h3>4、使用AOP</h3>
<p>（1）AOP思想采用横向抽取的方式（从左到右），将日志操作封装。实质是通过动态代理来实现的。</p>
<p>（2）动态代理分类：<br />　　JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。<br />　　Cglib动态代理：利用第三方jar包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>（3）动态代理区别：<br />　　JDK动态代理：只能对实现了接口的类产生代理。<br />　　Cglib动态代理：对没有实现接口的类产生代理对象，即针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。</p>
<p>（4）JDK动态代理：<br />　　可以参考：https://www.cnblogs.com/l-y-h/p/11111539.html#_label2</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【实例四：】
核心类、接口：
    Calculator.java          接口
    CalculatorImpl.java      接口实现类
    CalculatorProxy.java     接口实现类的代理类
    Main.java                测试类

【Calculator.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器接口，定义常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> Calculator {
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 加法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相加结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 减法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相减结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 乘法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相乘结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 除法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相除结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> div(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);
}


【CalculatorImpl.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器实现类，实现常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Calculator {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a -<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a *<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> div(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">if</span> (b == 0<span style="color: #000000;">) {
            System.out.println(</span>"除数不能为0"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> a /<span style="color: #000000;"> b;
    }
}


【CalculatorProxy.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.InvocationHandler;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Method;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Proxy;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Arrays;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * JDK动态代理
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorProxy <span style="color: #0000ff;">implements</span><span style="color: #000000;"> InvocationHandler {

    </span><span style="color: #0000ff;">private</span> Object calculator; <span style="color: #008000;">//</span><span style="color: #008000;"> 用于保存代理对象</span>
<span style="color: #000000;">
    CalculatorProxy(Object calculator) {
        </span><span style="color: #0000ff;">this</span>.calculator = calculator;  <span style="color: #008000;">//</span><span style="color: #008000;"> 获取代理的对象</span>
<span style="color: #000000;">    }

    @Override
    </span><span style="color: #0000ff;">public</span> Object invoke(Object proxy, Method method, Object[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
        String methodName </span>= method.getName(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取方法名</span>
        System.out.println("This is " + methodName + " starts with " +<span style="color: #000000;"> Arrays.asList(args));
        Object obj </span>= method.invoke(<span style="color: #0000ff;">this</span><span style="color: #000000;">.calculator, args);
        System.out.println(</span>"This is " + methodName + " ends with " +<span style="color: #000000;"> obj);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> obj;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 获取动态代理的对象
     *
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 动态代理的对象
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Object getJDKProxy() {
        </span><span style="color: #0000ff;">return</span> Proxy.newProxyInstance(<span style="color: #0000ff;">this</span>.calculator.getClass().getClassLoader(), <span style="color: #0000ff;">this</span>.calculator.getClass().getInterfaces(), <span style="color: #0000ff;">this</span><span style="color: #000000;">);
    }
}


【Main.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Proxy;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 测试类
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Calculator realCalculator </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> CalculatorImpl();
        </span><span style="color: #0000ff;">double</span> a = 3.0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> b = 2.0<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">        方式一</span>
        CalculatorProxy calculatorProxy = <span style="color: #0000ff;">new</span><span style="color: #000000;"> CalculatorProxy(realCalculator);
        Calculator calculator </span>=<span style="color: #000000;"> (Calculator) Proxy.newProxyInstance(calculatorProxy.getClass().getClassLoader(),
                realCalculator.getClass().getInterfaces(), calculatorProxy);

        System.out.println(</span>"a + b = " +<span style="color: #000000;"> calculator.add(a, b));
        System.out.println(</span>"a - b = " +<span style="color: #000000;"> calculator.sub(a, b));
        System.out.println(</span>"a * b = " +<span style="color: #000000;"> calculator.mul(a, b));
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator.div(a, b));

        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();

</span><span style="color: #008000;">//</span><span style="color: #008000;">        方式二</span>
        Calculator calculator2 = (Calculator) (<span style="color: #0000ff;">new</span><span style="color: #000000;"> CalculatorProxy(realCalculator).getJDKProxy());
        System.out.println(</span>"a + b = " +<span style="color: #000000;"> calculator2.add(a, b));
        System.out.println(</span>"a - b = " +<span style="color: #000000;"> calculator2.sub(a, b));
        System.out.println(</span>"a * b = " +<span style="color: #000000;"> calculator2.mul(a, b));
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator2.div(a, b));
    }
}

【结果：】
This is add starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is add ends with </span>5.0<span style="color: #000000;">
a </span>+ b = 5.0<span style="color: #000000;">
This is sub starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is sub ends with </span>1.0<span style="color: #000000;">
a </span>- b = 1.0<span style="color: #000000;">
This is mul starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is mul ends with </span>6.0<span style="color: #000000;">
a </span>* b = 6.0<span style="color: #000000;">
This is div starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is div ends with </span>1.5<span style="color: #000000;">
a </span>/ b = 1.5<span style="color: #000000;">





This is add starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is add ends with </span>5.0<span style="color: #000000;">
a </span>+ b = 5.0<span style="color: #000000;">
This is sub starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is sub ends with </span>1.0<span style="color: #000000;">
a </span>- b = 1.0<span style="color: #000000;">
This is mul starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is mul ends with </span>6.0<span style="color: #000000;">
a </span>* b = 6.0<span style="color: #000000;">
This is div starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is div ends with </span>1.5<span style="color: #000000;">
a </span>/ b = 1.5</code></pre>

<p>&nbsp;</p>
<p>（5）Cglib动态代理<br />　　要使用cglib，需要引入jar包（比如：cglib-2.2.2.jar， asm-3.3.1.jar）。</p>
<p>　　引入jar包不对的话，可能会引起下面的问题：<br />　　　　Question1：java.lang.NoClassDefFoundError: org/objectweb/asm/Type<br />　　　　Answer1：只引入了 cglib-2.2.2.jar， 未引入  asm-3.3.1.jar</p>
<p>　　　　Question2：class net.sf.cglib.core.DebuggingClassWriter overrides final method visit.<br />　　　　Answer2：引入了 asm-3.3.1.jar， 但是 版本不对，引发冲突。</p>
<p><img src="./images/Spring -- AOP0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【实例五：】
核心类：
    CalculatorImpl.java              某个类
    CalculatorCglibProxy.java        某个类的代理类
    Main.java                        测试类
    
【CalculatorImpl.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器类，定义常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CalculatorImpl {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a -<span style="color: #000000;"> b;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a *<span style="color: #000000;"> b;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> div(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">if</span> (b == 0<span style="color: #000000;">) {
            System.out.println(</span>"除数不能为0"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> a /<span style="color: #000000;"> b;
    }
}


【CalculatorCglibProxy.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> net.sf.cglib.proxy.Enhancer;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> net.sf.cglib.proxy.MethodInterceptor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> net.sf.cglib.proxy.MethodProxy;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Method;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Arrays;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * Cglib实现动态代理
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorCglibProxy <span style="color: #0000ff;">implements</span><span style="color: #000000;"> MethodInterceptor{
    </span><span style="color: #0000ff;">private</span> Object calculator; <span style="color: #008000;">//</span><span style="color: #008000;"> 用于保存代理对象</span>
<span style="color: #000000;">
    CalculatorCglibProxy(Object calculator) {
        </span><span style="color: #0000ff;">this</span>.calculator = calculator;  <span style="color: #008000;">//</span><span style="color: #008000;"> 获取代理的对象</span>
<span style="color: #000000;">    }

    @Override
    </span><span style="color: #0000ff;">public</span> Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
        String methodName </span>= method.getName(); <span style="color: #008000;">//</span><span style="color: #008000;"> 获取方法名</span>
        System.out.println("This is " + methodName + " starts with " +<span style="color: #000000;"> Arrays.asList(objects));
        Object obj </span>= method.invoke(<span style="color: #0000ff;">this</span><span style="color: #000000;">.calculator, objects);
        System.out.println(</span>"This is " + methodName + " ends  with " +<span style="color: #000000;"> obj);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> obj;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 获取Cglib动态代理的对象
     *
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 动态代理的对象
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Object getCglibProxy(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 1.创建cglib的核心类对象</span>
        Enhancer enhancer = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Enhancer();

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 2.设置父类</span>
<span style="color: #000000;">        enhancer.setSuperclass(calculator.getClass());

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 3.设置回调（类似于jdk动态代理中的InvocationHandler对象）</span>
        enhancer.setCallback(<span style="color: #0000ff;">this</span><span style="color: #000000;">);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 4.返回代理对象</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> enhancer.create();
    }
}


【Main.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.company;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> net.sf.cglib.proxy.Enhancer;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Proxy;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 测试类
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Main {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        CalculatorImpl realCalculator </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> CalculatorImpl();
        </span><span style="color: #0000ff;">double</span> a = 3.0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> b = 2.0<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">        方式一</span>
        CalculatorCglibProxy calculatorCglibProxy = <span style="color: #0000ff;">new</span><span style="color: #000000;"> CalculatorCglibProxy(realCalculator);
        CalculatorImpl calculator </span>= (CalculatorImpl) <span style="color: #0000ff;">new</span><span style="color: #000000;"> Enhancer().create(realCalculator.getClass(), calculatorCglibProxy);

        System.out.println(</span>"a + b = " +<span style="color: #000000;"> calculator.add(a, b));
        System.out.println(</span>"a - b = " +<span style="color: #000000;"> calculator.sub(a, b));
        System.out.println(</span>"a * b = " +<span style="color: #000000;"> calculator.mul(a, b));
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator.div(a, b));

        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println();

</span><span style="color: #008000;">//</span><span style="color: #008000;">        方式二</span>
        CalculatorImpl calculator2 = (CalculatorImpl) (<span style="color: #0000ff;">new</span><span style="color: #000000;"> CalculatorCglibProxy(realCalculator).getCglibProxy());
        System.out.println(</span>"a + b = " +<span style="color: #000000;"> calculator2.add(a, b));
        System.out.println(</span>"a - b = " +<span style="color: #000000;"> calculator2.sub(a, b));
        System.out.println(</span>"a * b = " +<span style="color: #000000;"> calculator2.mul(a, b));
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator2.div(a, b));
    }
}


【结果：】
This is add starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is add ends  with </span>5.0<span style="color: #000000;">
a </span>+ b = 5.0<span style="color: #000000;">
This is sub starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is sub ends  with </span>1.0<span style="color: #000000;">
a </span>- b = 1.0<span style="color: #000000;">
This is mul starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is mul ends  with </span>6.0<span style="color: #000000;">
a </span>* b = 6.0<span style="color: #000000;">
This is div starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is div ends  with </span>1.5<span style="color: #000000;">
a </span>/ b = 1.5<span style="color: #000000;">





This is add starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is add ends  with </span>5.0<span style="color: #000000;">
a </span>+ b = 5.0<span style="color: #000000;">
This is sub starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is sub ends  with </span>1.0<span style="color: #000000;">
a </span>- b = 1.0<span style="color: #000000;">
This is mul starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is mul ends  with </span>6.0<span style="color: #000000;">
a </span>* b = 6.0<span style="color: #000000;">
This is div starts with [</span>3.0, 2.0<span style="color: #000000;">]
This is div ends  with </span>1.5<span style="color: #000000;">
a </span>/ b = 1.5</code></pre>

<p>&nbsp;</p>
<h2>三、Spring中使用AOP</h2>
<h3>1、切入点表达式</h3>
<p>（1）切入点表达式的写法: （基于execution的函数完成的）</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">execution([访问修饰符] 返回值类型 包路径.类名.方法名(参数))

execution(modifiers</span>-pattern? ret-type-pattern declaring-type-pattern? name-pattern (param-pattern) <span style="color: #0000ff;">throws</span>-pattern?<span style="color: #000000;">)
其中：（</span>?<span style="color: #000000;">表示为可选项）
    modifiers</span>-pattern?<span style="color: #000000;">                修饰符匹配
    ret</span>-type-<span style="color: #000000;">pattern                  返回值类型
    declaring</span>-type-pattern?<span style="color: #000000;">           类路径匹配
    name</span>-<span style="color: #000000;">pattern                      方法名匹配 
    (param</span>-<span style="color: #000000;">pattern)                   参数匹配
    </span><span style="color: #0000ff;">throws</span>-pattern?<span style="color: #000000;">                  异常类型匹配
    &ldquo;</span>*<span style="color: #000000;">&rdquo; 表示任意返回值类型
    &ldquo;..&rdquo; 表示任意参数
    
【举例：】
全匹配方式:
    execution(</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> com.company.CalculatorImpl.add(..))

访问修饰符可省略
    execution(</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> com.company.CalculatorImpl.add(..))

可使用</span>*<span style="color: #000000;">,表示任意返回值
    execution(</span>*<span style="color: #000000;"> com.company.CalculatorImpl.add(..))
    
包路径可以使用</span>*,表示任意包. 但是*.的个数要和包的层级数相匹配，可以使用*<span style="color: #000000;">..,表示当前包,及其子包
    execution(</span>* *.*<span style="color: #000000;">.CalculatorImpl.add(..))
    
类名可以使用</span>*<span style="color: #000000;">,表示任意类
    execution(</span>* *..*<span style="color: #000000;">.add(..))
    
方法名可以使用</span>*<span style="color: #000000;">,表示任意方法
    execution(</span>* *..*.*<span style="color: #000000;">(..))
    
参数列表可以使用</span>*<span style="color: #000000;">,表示参数可以是任意数据类型,但是必须存在参数
     execution(</span>* *..*.*(*<span style="color: #000000;">))
     
参数列表可以使用..表示有无参数均可,有参数可以是任意类型
    execution(</span>* *..*.*<span style="color: #000000;">(..))
    
全通配方式,可以匹配匹配任意方法
    execution(</span>* *..*.*(..))</code></pre>

<p>&nbsp;</p>
<h3>2、xml版 配置文件的写法、规则</h3>
<p>（1）配置 通知类（切面） 与 被通知的类（目标对象）。</p>
<src class="cnblogs_code">
<pre><code> &lt;!-- 配置目标对象，即被增强的对象 --&gt;
&lt;bean id="calculator" <span style="color: #0000ff;">class</span>="com.company.CalculatorImpl"/&gt;

&lt;!-- 将增强类(切面类)交给Spring管理 --&gt;
&lt;bean id="calculatorEnhancer" <span style="color: #0000ff;">class</span>="com.company.CalculatorEnhancer"/&gt;</code></pre>

<p>（2）&lt;aop:config&gt;<br />　　用于声明AOP配置，所有的AOP配置代码均写在其中。</p>
<src class="cnblogs_code">
<pre><code>&lt;aop:config&gt;
    &lt;!-- AOP配置的代码都写在此处 --&gt;
&lt;/aop:config&gt;</code></pre>

<p>（3）&lt;aop:aspect&gt;<br />　　用于配置切面。<br />　　其属性：<br />　　　　id ： 为指定切面的id， <br />　　　　ref ：为引用通知类的 id。</p>
<src class="cnblogs_code">
<pre><code>&lt;aop:config&gt;
    &lt;!-- AOP配置的代码都写在此处 --&gt;
    &lt;aop:aspect id="calculatorAdvice" ref="calculatorEnhancer"&gt;
        &lt;!--配置通知的类型要写在此处--&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre>

<p>（4）&lt;aop:pointcut&gt;<br />　　用于配置切点表达式，用于指定对哪些方法进行增强。<br />　　其属性：<br />　　　　id：为指定切点表达式的id。<br />　　　　expression: 指定切入点表达式。</p>
<src class="cnblogs_code">
<pre><code>&lt;aop:config&gt;
    &lt;!-- AOP配置的代码都写在此处 --&gt;
    
    &lt;!--配置切点表达式--&gt;
     &lt;aop:pointcut id="aspect1" expression="execution(* com.company.CalculatorImpl.*(..))"&gt;&lt;/aop:pointcut&gt;
        
    &lt;!--配置切面，通知的类型要写在此处--&gt;
    &lt;aop:aspect id="calculatorAdvice" ref="calculatorEnhancer"&gt;
          
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre>

<p>（5）配置通知方法<br />	　　&lt;aop:before&gt;: 配置前置通知,指定的增强方法在切入点方法之前执行。<br />	　　&lt;aop:after-returning&gt;: 配置后置返回通知,指定的增强方法在切入点方法正常执行之后执行。<br />	　　&lt;aop:after-throwing&gt;: 配置后置异常通知,指定的增强方法在切入点方法产生异常后执行。<br />	　　&lt;aop:after&gt;: 配置后置通知,无论切入点方法执行时是否发生异常,指定的增强方法都会最后执行。<br />	　　&lt;aop:around&gt;: 配置环绕通知,可以在代码中手动控制增强代码的执行时机。<br />其属性：<br />	　　method：用于指定 通知类中的 通知方法名。<br />	　　ponitcut-ref：指定切入点的表达式的id。<br />	　　poinitcut：指定切入点表达式。</p>
<src class="cnblogs_code">
<pre><code>&lt;aop:config&gt;
    &lt;!-- AOP配置的代码都写在此处 --&gt;
   &lt;!--配置切点表达式--&gt;
   &lt;aop:pointcut id="aspect1" expression="execution(* com.company.CalculatorImpl.*(..))"&gt;&lt;/aop:pointcut&gt;
         
     &lt;!--配置通知的类型要写在此处--&gt;
    &lt;aop:aspect id="calculatorAdvice" ref="calculatorEnhancer"&gt;
       &lt;!--配置各种类型的通知--&gt;
        &lt;aop:before method="printLogBefore" pointcut-ref="aspect1"&gt;&lt;/aop:before&gt;
        &lt;aop:after-returning method="printLogAfterReturning" pointcut-ref="aspect1"&gt;&lt;/aop:after-returning&gt;
            &lt;aop:after-throwing method="printLogAfterThrowing" pointcut-ref="aspect1"&gt;&lt;/aop:after-throwing&gt;
        &lt;aop:after method="printLogAfter" pointcut-ref="aspect1"&gt;&lt;/aop:after&gt;
        &lt;!--环绕通知一般单独使用--&gt;       
        &lt;!-- &lt;aop:around method="printLogAround" pointcut-ref="aspect1"&gt;&lt;/aop:around&gt; --&gt;
     &lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre>

<p>&nbsp;</p>
<h3>3、xml版</h3>
<p>（1）导入junit、aop、Spring等相关jar包。</p>
<p><img src="./images/Spring -- AOP1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>注：若使用 junit 报错： java.lang.NoClassDefFoundError: org/hamcrest/SelfDescribing 。<br />可以导入hamcrest-core-1.3.jar。</p>
<p>&nbsp;</p>
<p>（2）目录结构</p>
<p><img src="./images/Spring -- AOP2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>（3）代码<br />　　注：环绕通知的返回值必须是Object，形参必须是ProceedingJoingPoint。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【实例六：】
核心类、接口：
    Calculator.java            接口
    CalculatorImpl.java        接口实现类，被通知类
    CalculatorEnhancer.java    通知（切面）类，用于定义相关通知方法
    applicationContext.xml     配置文件，用于 通知类  与  被通知类 关联  
    CalculatorTest.java        使用Junit进行单元测试
    

【Calculator.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.service;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器接口，定义常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> Calculator {
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 加法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相加结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 减法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相减结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 乘法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相乘结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 除法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相除结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> div(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
}


【CalculatorImpl.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.service.impl;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.lyh.service.Calculator;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器实现类，实现常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Calculator{
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a -<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a *<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> div(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a /<span style="color: #000000;"> b;
    }
}


【CalculatorEnhancer.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.enhancer;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.aspectj.lang.JoinPoint;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.aspectj.lang.ProceedingJoinPoint;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Arrays;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 定义一个切面类
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CalculatorEnhancer {

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 前置通知:在方法执行前执行的代码
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> beforeExecute(JoinPoint joinPoint){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"beforeExecute"<span style="color: #000000;">);
        System.out.println(</span>"This is " + methodName + " starts with " +<span style="color: #000000;"> Arrays.asList(joinPoint.getArgs()));
        System.out.println();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 后置通知:在方法执行后执行的代码(无论该方法是否发生异常),注意后置通知拿不到执行的结果
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> afterExecute(JoinPoint joinPoint){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"afterExecute"<span style="color: #000000;">);
        System.out.println();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 后置返回通知:在方法正常执行后执行的代码,可以获取到方法的返回值
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> result 方法执行的结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> afterReturningExecute(JoinPoint joinPoint, Object result){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"afterReturningExecute"<span style="color: #000000;">);
        System.out.println(</span>"This is " + methodName + " ends with " +<span style="color: #000000;"> result);
        System.out.println();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 后置异常通知:在方法抛出异常之后执行,可以访问到异常信息。
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> exception 异常信息
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> afterExceptionExecute(JoinPoint joinPoint,  Exception exception){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"afterExceptionExecute"<span style="color: #000000;">);
        System.out.println(</span>"This is " + methodName + " exception with: " +<span style="color: #000000;"> exception);
        System.out.println();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 环绕通知。
     * Spring框架为我们提供一个接口ProceedingJoinPoint,它的实例对象可以作为环绕通知方法的参数,通过参数控制被增强方法的执行时机。
     * ProceedingJoinPoint对象的getArgs()方法返回被拦截的参数
     * ProceedingJoinPoint对象的proceed()方法执行被拦截的方法
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 连接点
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 方法计算的结果值
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Object aroundExecute(ProceedingJoinPoint joinPoint){
        Object result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
            System.out.println(</span>"beforeExecute"<span style="color: #000000;">);
            result </span>=<span style="color: #000000;"> joinPoint.proceed(joinPoint.getArgs());
            System.out.println(</span>"afterReturningExecute"<span style="color: #000000;">);
        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable e){
            System.out.println(</span>"afterExceptionExecute"<span style="color: #000000;">);
        }</span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            System.out.println(</span>"afterExecute"<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
    }
}


【applicationContext.xml】
</span>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"<span style="color: #000000;">
       xmlns:xsi</span>="http://www.w3.org/2001/XMLSchema-instance"<span style="color: #000000;">
       xmlns:aop</span>="http://www.springframework.org/schema/aop"<span style="color: #000000;">
       xsi:schemaLocation</span>="http://www.springframework.org/schema/beans
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/beans/spring-beans.xsd</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/aop</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/aop/spring-aop.xsd"&gt;</span>

        &lt;!-- 配置目标对象，即被增强的对象 --&gt;
        &lt;bean id="calculator" <span style="color: #0000ff;">class</span>="com.lyh.service.impl.CalculatorImpl"/&gt;

        &lt;!-- 将增强类(切面类)交给Spring管理 --&gt;
        &lt;bean id="calculatorEnhancer" <span style="color: #0000ff;">class</span>="com.lyh.enhancer.CalculatorEnhancer"/&gt;

        &lt;aop:config&gt;
            &lt;!-- AOP配置的代码都写在此处 --&gt;

            &lt;!--配置切点表达式--&gt;
            &lt;aop:pointcut id="beforeTest" expression="execution(* com.lyh.service.impl.CalculatorImpl.add(..))"&gt;&lt;/aop:pointcut&gt;
            &lt;aop:pointcut id="afterTest" expression="execution(* com.lyh.service.impl.CalculatorImpl.add(..))"&gt;&lt;/aop:pointcut&gt;
            &lt;aop:pointcut id="afterReturningTest" expression="execution(* com.lyh.service.impl.CalculatorImpl.add(..))"&gt;&lt;/aop:pointcut&gt;
            &lt;aop:pointcut id="afterThrowingTest" expression="execution(* com.lyh.service.impl.CalculatorImpl.div(..))"&gt;&lt;/aop:pointcut&gt;
            &lt;aop:pointcut id="aroundTest" expression="execution(* com.lyh.service.impl.CalculatorImpl.sub(..))"&gt;&lt;/aop:pointcut&gt;


            &lt;!--配置通知的类型要写在此处--&gt;
            &lt;aop:aspect id="calculatorAdvice" ref="calculatorEnhancer"&gt;
                &lt;!--配置各种类型的通知--&gt;
                &lt;aop:before method="beforeExecute" pointcut-ref="beforeTest"&gt;&lt;/aop:before&gt;
                &lt;aop:after method="afterExecute" pointcut-ref="afterTest"&gt;&lt;/aop:after&gt;
                &lt;aop:after-returning method="afterReturningExecute" pointcut-ref="afterReturningTest" returning="result"&gt;&lt;/aop:after-returning&gt;
                &lt;aop:after-throwing method="afterExceptionExecute" pointcut-ref="afterThrowingTest" throwing="exception"&gt;&lt;/aop:after-throwing&gt;
                &lt;aop:around method="aroundExecute" pointcut-ref="aroundTest"&gt;&lt;/aop:around&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;

&lt;/beans&gt;<span style="color: #000000;">


【CalculatorTest.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.test;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.lyh.service.Calculator;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.junit.Test;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.junit.runner.RunWith;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.beans.factory.annotation.Autowired;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.test.context.ContextConfiguration;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.math.BigDecimal;

@RunWith(SpringJUnit4ClassRunner.</span><span style="color: #0000ff;">class</span><span style="color: #000000;">)
@ContextConfiguration(locations </span>= {"classpath:applicationContext.xml"<span style="color: #000000;">})
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CalculatorTest {
    @Autowired
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Calculator calculator;

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 测试 前置通知，后置通知，后置返回通知
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test(){
        </span><span style="color: #0000ff;">double</span> a = 3.0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> b = 2.0<span style="color: #000000;">;
        System.out.println(</span>"a + b = " +<span style="color: #000000;"> calculator.add(a, b));
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 测试后置异常通知,
     * 对于除数为0的情况（即b = 0时），
     * 如果二者均为int型(long也是int型)，结果会抛出异常：java.lang.ArithmeticException: / by zero。
     * 如果其中有一个为double或者float型，结果则是Infinity。
     * 为了测试异常，此处将数据置为int型的。
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test2(){
        </span><span style="color: #0000ff;">int</span> a = 3<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> b = 0<span style="color: #000000;">;
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator.div(a, b));
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 测试环绕通知
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test3(){
        </span><span style="color: #0000ff;">int</span> a = 3<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> b = 0<span style="color: #000000;">;
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator.sub(a, b));
    }
}


【测试结果：】
【运行test()】
beforeExecute
This is add starts with [</span>3.0, 2.0<span style="color: #000000;">]

afterReturningExecute
This is add ends with </span>5.0<span style="color: #000000;">

afterExecute

a </span>+ b = 5.0<span style="color: #000000;">


【运行test1()】
afterExceptionExecute
This is div exception with: java.lang.ArithmeticException: </span>/<span style="color: #000000;"> by zero


java.lang.ArithmeticException: </span>/<span style="color: #000000;"> by zero

    at com.lyh.service.impl.CalculatorImpl.div(CalculatorImpl.java:</span>29<span style="color: #000000;">)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:</span>62<span style="color: #000000;">)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:</span>43<span style="color: #000000;">)
    at java.lang.reflect.Method.invoke(Method.java:</span>498<span style="color: #000000;">)
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:</span>333<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:</span>190<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:</span>157<span style="color: #000000;">)
    at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:</span>62<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:</span>179<span style="color: #000000;">)
    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:</span>92<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:</span>179<span style="color: #000000;">)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:</span>213<span style="color: #000000;">)
    at com.sun.proxy.$Proxy13.div(Unknown Source)
    at com.lyh.test.CalculatorTest.test2(CalculatorTest.java:</span>39<span style="color: #000000;">)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:</span>62<span style="color: #000000;">)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:</span>43<span style="color: #000000;">)
    at java.lang.reflect.Method.invoke(Method.java:</span>498<span style="color: #000000;">)
    at org.junit.runners.model.FrameworkMethod$</span>1.runReflectiveCall(FrameworkMethod.java:50<span style="color: #000000;">)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:</span>12<span style="color: #000000;">)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:</span>47<span style="color: #000000;">)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:</span>17<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:</span>75<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:</span>86<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:</span>84<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:</span>325<span style="color: #000000;">)
    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:</span>252<span style="color: #000000;">)
    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:</span>94<span style="color: #000000;">)
    at org.junit.runners.ParentRunner$</span>3.run(ParentRunner.java:290<span style="color: #000000;">)
    at org.junit.runners.ParentRunner$</span>1.schedule(ParentRunner.java:71<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:</span>288<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.access$</span>000(ParentRunner.java:58<span style="color: #000000;">)
    at org.junit.runners.ParentRunner$</span>2.evaluate(ParentRunner.java:268<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:</span>61<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:</span>70<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:</span>363<span style="color: #000000;">)
    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:</span>191<span style="color: #000000;">)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:</span>137<span style="color: #000000;">)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:</span>68<span style="color: #000000;">)
    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:</span>47<span style="color: #000000;">)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:</span>242<span style="color: #000000;">)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:</span>70<span style="color: #000000;">)


【运行test3()】
beforeExecute
afterReturningExecute
afterExecute
a </span>/ b = 3.0</code></pre>

<p>注：</p>
<p>　　使用xml版的时候，执行的顺序 按照 配置文件中的 顺序执行。</p>
<p>　　可能会出现&nbsp; 前置通知&nbsp; -》&nbsp; 后置通知（最终通知） -》&nbsp; 后置返回通知&nbsp; 的情况。</p>
<p><img src="./images/Spring -- AOP3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　也可能会出现&nbsp; 前置通知&nbsp; -》&nbsp; 后置返回通知&nbsp;&nbsp;-》&nbsp; 后置通知（最终通知） &nbsp;的情况。</p>
<p><img src="./images/Spring -- AOP4.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>4、注解版</h3>
<p>（1）在上例 xml 版的基础上，在 applicationContext.xml 中 添加 &lt;aop:aspectj-autoproxy /&gt; 用于自动代理，同时在相应的地方添加上注解标记。</p>
<p>（2）代码<br />　　注： 使用 @Aspect 后执行顺序是 前置通知,后置通知,后置返回通知，可以用 环绕通知 来解决。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">【实例七：】
核心类、接口：
    Calculator.java            接口
    CalculatorImpl.java        接口实现类，被通知类
    CalculatorEnhancer.java    通知（切面）类，用于定义相关通知方法
    applicationContext.xml     配置文件，用于 通知类  与  被通知类 关联  
    CalculatorTest.java        使用Junit进行单元测试


【Calculator.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.service;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器接口，定义常用方法
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> Calculator {
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 加法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相加结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 减法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相减结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 乘法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相乘结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b);

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 除法操作
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> a 实数
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> b 实数
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 相除结果
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> div(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
}


【CalculatorImpl.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.service.impl;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.lyh.service.Calculator;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.stereotype.Service;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.xml.ws.ServiceMode;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 计算器实现类，实现常用方法
 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
@Service
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculatorImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Calculator{
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> add(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> sub(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a -<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> mul(<span style="color: #0000ff;">double</span> a, <span style="color: #0000ff;">double</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a *<span style="color: #000000;"> b;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> div(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a /<span style="color: #000000;"> b;
    }
}


【CalculatorEnhancer.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.enhancer;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.aspectj.lang.JoinPoint;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.aspectj.lang.ProceedingJoinPoint;
</span><span style="color: #0000ff;">import</span> org.aspectj.lang.annotation.*<span style="color: #000000;">;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.stereotype.Component;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Arrays;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 定义一个切面类
 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
@Component
@Aspect
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CalculatorEnhancer {

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 前置通知:在方法执行前执行的代码
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Before(</span>"execution(* com.lyh.service.impl.CalculatorImpl.add(..))"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> beforeExecute(JoinPoint joinPoint){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"beforeExecute"<span style="color: #000000;">);
        System.out.println(</span>"This is " + methodName + " starts with " +<span style="color: #000000;"> Arrays.asList(joinPoint.getArgs()));
        System.out.println();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 后置返回通知:在方法正常执行后执行的代码,可以获取到方法的返回值
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> result 方法执行的结果
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @AfterReturning(returning </span>= "result", value = "execution(* com.lyh.service.impl.CalculatorImpl.add(..))"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> afterReturningExecute(JoinPoint joinPoint, Object result){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"afterReturningExecute"<span style="color: #000000;">);
        System.out.println(</span>"This is " + methodName + " ends with " +<span style="color: #000000;"> result);
        System.out.println();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 后置通知:在方法执行后执行的代码(无论该方法是否发生异常),注意后置通知拿不到执行的结果
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @After(</span>"execution(* com.lyh.service.impl.CalculatorImpl.add(..))"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> afterExecute(JoinPoint joinPoint){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"afterExecute"<span style="color: #000000;">);
        System.out.println();
    }



    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 后置异常通知:在方法抛出异常之后执行,可以访问到异常信息。
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 切入点
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> exception 异常信息
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @AfterThrowing(throwing </span>="exception", value = "execution(* com.lyh.service.impl.CalculatorImpl.div(..))"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> afterExceptionExecute(JoinPoint joinPoint,  Exception exception){
        String methodName </span>=<span style="color: #000000;"> joinPoint.getSignature().getName();
        System.out.println(</span>"afterExceptionExecute"<span style="color: #000000;">);
        System.out.println(</span>"This is " + methodName + " exception with: " +<span style="color: #000000;"> exception);
        System.out.println();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 环绕通知。
     * Spring框架为我们提供一个接口ProceedingJoinPoint,它的实例对象可以作为环绕通知方法的参数,通过参数控制被增强方法的执行时机。
     * ProceedingJoinPoint对象的getArgs()方法返回被拦截的参数
     * ProceedingJoinPoint对象的proceed()方法执行被拦截的方法
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> joinPoint 连接点
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 方法计算的结果值
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Around(</span>"execution(* com.lyh.service.impl.CalculatorImpl.sub(..))"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Object aroundExecute(ProceedingJoinPoint joinPoint){
        Object result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
            System.out.println(</span>"beforeExecute"<span style="color: #000000;">);
            result </span>=<span style="color: #000000;"> joinPoint.proceed(joinPoint.getArgs());
            System.out.println(</span>"afterReturningExecute"<span style="color: #000000;">);
        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable e){
            System.out.println(</span>"afterExceptionExecute"<span style="color: #000000;">);
        }</span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            System.out.println(</span>"afterExecute"<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
    }
}

【applicationContext.xml 】
</span>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"<span style="color: #000000;">
       xmlns:xsi</span>="http://www.w3.org/2001/XMLSchema-instance"<span style="color: #000000;">
       xmlns:aop</span>="http://www.springframework.org/schema/aop"<span style="color: #000000;">
       xmlns:context</span>="http://www.springframework.org/schema/context"<span style="color: #000000;">
       xsi:schemaLocation</span>="http://www.springframework.org/schema/beans
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/beans/spring-beans.xsd</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/aop</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/aop/spring-aop.xsd</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/context</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/context/spring-context-4.0.xsd"&gt;</span>


    &lt;!-- 自动扫描的包 --&gt;
    &lt;context:component-scan base-<span style="color: #0000ff;">package</span>="com.lyh"&gt;&lt;/context:component-scan&gt;

    &lt;!-- 启用AspectJ自动代理 --&gt;
    &lt;aop:aspectj-autoproxy /&gt;

&lt;/beans&gt;<span style="color: #000000;">



【CalculatorTest.java】
</span><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.lyh.test;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.lyh.service.Calculator;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.junit.Test;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.junit.runner.RunWith;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.beans.factory.annotation.Autowired;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.test.context.ContextConfiguration;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.math.BigDecimal;

@RunWith(SpringJUnit4ClassRunner.</span><span style="color: #0000ff;">class</span><span style="color: #000000;">)
@ContextConfiguration(locations </span>= {"classpath:applicationContext.xml"<span style="color: #000000;">})
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CalculatorTest {
    @Autowired
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Calculator calculator;

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 测试 前置通知，后置通知，后置返回通知
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test(){
        </span><span style="color: #0000ff;">double</span> a = 3.0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> b = 2.0<span style="color: #000000;">;
        System.out.println(</span>"a + b = " +<span style="color: #000000;"> calculator.add(a, b));
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 测试后置异常通知,
     * 对于除数为0的情况（即b = 0时），
     * 如果二者均为int型(long也是int型)，结果会抛出异常：java.lang.ArithmeticException: / by zero。
     * 如果其中有一个为double或者float型，结果则是Infinity。
     * 为了测试异常，此处将数据置为int型的。
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test2(){
        </span><span style="color: #0000ff;">int</span> a = 3<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> b = 0<span style="color: #000000;">;
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator.div(a, b));
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 测试环绕通知
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test3(){
        </span><span style="color: #0000ff;">int</span> a = 3<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> b = 0<span style="color: #000000;">;
        System.out.println(</span>"a / b = " +<span style="color: #000000;"> calculator.sub(a, b));
    }
}


【测试结果：】
【运行test()】
这里可以看到这里的执行顺序是 前置通知,后置通知,后置返回通知

beforeExecute
This is add starts with [</span>3.0, 2.0<span style="color: #000000;">]

afterExecute

afterReturningExecute
This is add ends with </span>5.0<span style="color: #000000;">

a </span>+ b = 5.0<span style="color: #000000;">


【运行test2()】
afterExceptionExecute
This is div exception with: java.lang.ArithmeticException: </span>/<span style="color: #000000;"> by zero


java.lang.ArithmeticException: </span>/<span style="color: #000000;"> by zero

    at com.lyh.service.impl.CalculatorImpl.div(CalculatorImpl.java:</span>30<span style="color: #000000;">)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:</span>62<span style="color: #000000;">)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:</span>43<span style="color: #000000;">)
    at java.lang.reflect.Method.invoke(Method.java:</span>498<span style="color: #000000;">)
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:</span>333<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:</span>190<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:</span>157<span style="color: #000000;">)
    at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:</span>62<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:</span>179<span style="color: #000000;">)
    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:</span>92<span style="color: #000000;">)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:</span>179<span style="color: #000000;">)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:</span>213<span style="color: #000000;">)
    at com.sun.proxy.$Proxy20.div(Unknown Source)
    at com.lyh.test.CalculatorTest.test2(CalculatorTest.java:</span>39<span style="color: #000000;">)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:</span>62<span style="color: #000000;">)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:</span>43<span style="color: #000000;">)
    at java.lang.reflect.Method.invoke(Method.java:</span>498<span style="color: #000000;">)
    at org.junit.runners.model.FrameworkMethod$</span>1.runReflectiveCall(FrameworkMethod.java:50<span style="color: #000000;">)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:</span>12<span style="color: #000000;">)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:</span>47<span style="color: #000000;">)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:</span>17<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:</span>75<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:</span>86<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:</span>84<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:</span>325<span style="color: #000000;">)
    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:</span>252<span style="color: #000000;">)
    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:</span>94<span style="color: #000000;">)
    at org.junit.runners.ParentRunner$</span>3.run(ParentRunner.java:290<span style="color: #000000;">)
    at org.junit.runners.ParentRunner$</span>1.schedule(ParentRunner.java:71<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:</span>288<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.access$</span>000(ParentRunner.java:58<span style="color: #000000;">)
    at org.junit.runners.ParentRunner$</span>2.evaluate(ParentRunner.java:268<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:</span>61<span style="color: #000000;">)
    at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:</span>70<span style="color: #000000;">)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:</span>363<span style="color: #000000;">)
    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:</span>191<span style="color: #000000;">)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:</span>137<span style="color: #000000;">)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:</span>68<span style="color: #000000;">)
    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:</span>47<span style="color: #000000;">)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:</span>242<span style="color: #000000;">)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:</span>70<span style="color: #000000;">)


【运行test3()】
beforeExecute
afterReturningExecute
afterExecute
a </span>/ b = 3.0</code></pre>

<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>