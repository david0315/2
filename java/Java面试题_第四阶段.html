<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java面试题_第四阶段' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java面试题_第四阶段</center></div><div class='banquan'>原文出处:本文由博客园博主佩奇er提供。<br/>
原文连接:https://www.cnblogs.com/hxun/p/11771955.html</div><br>
    <h2><span style="background-color: #ffff00;">1.1&nbsp;<strong>电商行业特点</strong></span></h2>
<p><span style="color: #ff0000;">1.分布式</span></p>
<p><span style="font-family: 宋体;">&nbsp; 垂直拆分</span>:<span style="font-family: 宋体;">根据功能模块进行拆分</span></p>
<p><span style="font-family: 宋体;">&nbsp; 水平拆分</span>:<span style="font-family: 宋体;">根据业务层级进行拆分</span></p>
<p><span style="color: #ff0000;">2.高并发</span></p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-family: 宋体;">用户单位时间内访问服务器数量</span>,<span style="font-family: 宋体;">是电商行业中面临的主要问题</span></p>
<p><span style="color: #ff0000;">3.集群</span></p>
<p><span style="font-family: 宋体;">&nbsp; 抗击高兵发的有效手段</span>,<span style="font-family: 宋体;">同时集群内部实现高可用</span></p>
<p><span style="color: #ff0000;">4.海量数据处理</span></p>
<p><span style="font-family: 宋体;">&nbsp; 随着公司数据的不断积累</span>.<span style="font-family: 宋体;">自身的数据量很庞大</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果高效的处理数据</span><span style="font-family: Calibri;">/</span><span style="font-family: 宋体;">分析</span></p>
<h2><span style="background-color: #ffff00;">1.2&nbsp;<strong>框架调用流程</strong></span></h2>
<p>&nbsp;<img src="./images/Java面试题_第四阶段0.png" alt="" /></p>
<h2><span style="background-color: #ffff00;">1.3&nbsp;<strong>EasyUI<span style="font-family: 宋体;">后台调用流程</span></strong></span></h2>
<p>&nbsp;<img src="./images/Java面试题_第四阶段1.png" alt="" /></p>
<h2><span style="background-color: #ffff00;">1.4&nbsp;<strong>分布式项目的设计思想</strong></span></h2>
<p><span style="font-family: 宋体;">为了实现架构之间的松耦合</span>,<span style="font-family: 宋体;">将项目根据分布式的思想进行拆分</span><span style="font-family: Calibri;">.</span></p>
<p><span style="color: #ff0000;">1.项目的垂直拆分</span></p>
<p class="19"><span style="font-family: 宋体;">根据功能模块的不同将项目进行拆分</span>.</p>
<p><span style="color: #ff0000;">2.项目的水平拆分</span></p>
<p class="19"><span style="font-family: 宋体;">在大型项目中</span>,<span style="font-family: 宋体;">由于开发的人数众多</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">项目复杂度高</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">为了保证项目开发的耦合性低</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">实现项目的水平拆分</span><span style="font-family: Calibri;">.</span></p>
<p class="19"><span style="font-family: 宋体;">将一个大型项目根据层级模块进行拆分</span>.Controller<span style="font-family: 宋体;">项目</span><span style="font-family: Calibri;">/Service</span><span style="font-family: 宋体;">项目</span><span style="font-family: Calibri;">Mapper</span><span style="font-family: 宋体;">项目</span></p>
<p class="19">项目创建时采用<span style="color: #ff0000;"><strong>聚合项目</strong></span>的方式进行管理</p>
<p>&nbsp;</p>
<h2><span style="background-color: #ffff00;">1.5&nbsp;<strong><span style="font-family: 宋体;">分布式项目的</span>jar<span style="font-family: 宋体;">包如何管理</span></strong></span></h2>
<p><span style="font-family: 宋体;">将项目中用到公共的</span>jar<span style="font-family: 宋体;">包使用服务支撑项目</span><span style="font-family: Calibri;">jt-parent</span><span style="font-family: 宋体;">进行添加</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">其他的项目只需要继承</span><span style="font-family: Calibri;">jt-parent</span><span style="font-family: 宋体;">后获取对应的</span><span style="font-family: Calibri;">jar</span><span style="font-family: 宋体;">包全部依赖</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">从而实现了</span><span style="font-family: Calibri;">jar</span><span style="font-family: 宋体;">包的统一管理</span></p>
<h2><span style="background-color: #ffff00;">1.6&nbsp;<strong><span style="font-family: 宋体;">介绍一下通用</span>Mapper</strong></span></h2>
<ol>
<li><span style="font-family: 宋体;">早期使用</span>JDBC<span style="font-family: 宋体;">操作数据库</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">该操作特别的繁琐</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">并且所有的数据需要自己手动的封装</span><span style="font-family: Calibri;">.</span></li>
<li>JPA:<span style="font-family: 宋体;">是</span>java<span style="font-family: 宋体;">持久化的</span><span style="font-family: Calibri;">API(</span><span style="font-family: 宋体;">用面向对象的方式操作数据库</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">思想</span></li>
</ol>
<src class="cnblogs_code">
<pre><code>User user = <span style="color: #0000ff;">new</span><span style="color: #000000;"> User(); setXXXX 
User.setId(</span>1<span style="color: #000000;">);
User.setName(tom);
工具API.insert(user);  JPA内部将对象自动转化为sql语句
Insert into &hellip;&hellip;.</span></code></pre>

<p>　　3.Haibernate<span style="font-family: 宋体;">框架</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">号称是自动化的</span><span style="font-family: Calibri;">(ORM)</span></p>
<p class="19"><span style="font-family: 宋体;">程序员只需要操作对象</span>,<span style="font-family: 宋体;">从而完成了对数据库的操作</span><span style="font-family: Calibri;">.</span></p>
<p class="19"><span style="font-family: 宋体;">缺点</span>:</p>
<ol>
<li><span style="font-family: 宋体;">做新增</span>/<span style="font-family: 宋体;">删除</span><span style="font-family: Calibri;">/</span><span style="font-family: 宋体;">修改会产生一些冗余的</span><span style="font-family: Calibri;">sql</span>(出于安全性性考虑)</li>
<li><span style="font-family: 宋体;">如果做多表关联操作</span>(CRUD) ,<span style="font-family: 宋体;">需要装备配置文件</span>,<span style="font-family: 宋体;">通过配置文件进行数据关联设定</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">同时需要学习</span><span style="font-family: Calibri;">H</span>ql(语句)</li>
<li><span style="font-family: 宋体;">早期数据库容量是有限</span>,<span style="font-family: 宋体;">超过</span><span style="font-family: Calibri;">5</span>00<span style="font-family: 宋体;">万后查询效率开始变低</span>.</li>
</ol>
<p>4.Mybatis，<span style="font-family: 宋体;">优点</span>:<span style="font-family: 宋体;">继承</span><span style="font-family: Calibri;">ORM,</span><span style="font-family: 宋体;">摈弃了冗余的</span><span style="font-family: Calibri;">sql(</span><span style="font-family: 宋体;">自己手写</span><span style="font-family: Calibri;">),</span></p>
<p>&nbsp;&nbsp;5.<span style="font-family: 宋体;">通用</span><span style="font-family: Calibri;">Mapper</span><span style="font-family: 宋体;">插件基于</span><span style="font-family: Calibri;">mybaits</span><span style="font-family: 宋体;">的</span><span style="font-family: 宋体;">效果，</span><span style="font-family: 宋体;">可以实现单表</span><span style="font-family: Calibri;">CRUD</span><span style="font-family: 宋体;">使用对象操作</span><span style="font-family: Calibri;">.(</span><span style="font-family: 宋体;">反射机制</span><span style="font-family: Calibri;">)</span></p>
<h2><span style="background-color: #ffff00;">1.7&nbsp;<strong>Nginx</strong><strong><span style="font-family: 宋体;">是什么</span>,<span style="font-family: 宋体;">有什么作用？</span></strong></span></h2>
<p><em>Nginx</em>&nbsp;(engine x) <span style="font-family: 宋体;">是一个</span><span style="color: #ff0000;"><span style="font-family: 宋体;">轻量级的是一个高性能的</span>HTTP<span style="font-family: 宋体;">和反向代理服务器</span></span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">其特点是占有内存少，</span><a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91"><span style="text-decoration: underline;"><span style="font-family: 宋体;">并发</span></span></a><span style="font-family: 宋体;">能力强</span></p>
<p><span style="font-family: 宋体;">主要是用来反向代理和实现负载均衡</span>.</p>
<h2><span style="background-color: #ffff00;">1.8&nbsp;<strong>谈一下反向代理和负载均衡</strong></span></h2>
<p><span style="font-family: 宋体;"><img src="./images/Java面试题_第四阶段2.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">说明</span>:</p>
<ol>
<li>Nginx<span style="font-family: 宋体;">首先需要监听特定的域名</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">当用户根据域名进行资源访问时</span>.<span style="font-family: 宋体;">首先会访问</span><span style="font-family: Calibri;">nginx</span></li>
<li><span style="font-family: 宋体;">之后</span>nginx<span style="font-family: 宋体;">代替请求者根据内部的配置文件</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">实现反向代理</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">将请求转化为特定的请求路径进行资源访问</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">当</span>Nginx<span style="font-family: 宋体;">获取资源后将数据返回给用户</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">完成请求的正确的响应</span><span style="font-family: Calibri;">.</span></li>
</ol>
<p><span style="font-family: 宋体;">负载均衡</span>:<span style="font-family: 宋体;">访问量高时</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">可以让服务器尽量分摊压力</span><span style="font-family: Calibri;">,</span></p>
<p><span style="font-family: Calibri;"><img src="./images/Java面试题_第四阶段3.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">实现策略</span>:<span style="font-family: 宋体;">轮询</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">权重</span><span style="font-family: Calibri;">,IP_HASH(</span><span style="font-family: 宋体;">一般不用</span><span style="font-family: Calibri;">)</span></p>
<h2><span style="background-color: #ffff00;">1.9&nbsp;<strong>Nginx<span style="font-family: 宋体;">的健康监测机制</span></strong></span></h2>
<p><span style="font-family: 宋体;">当后台的服务器出现宕机的现象</span>,<span style="font-family: 宋体;">当时</span><span style="font-family: Calibri;">nginx</span><span style="font-family: 宋体;">中的配置文件并没有改变时</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">请求依然会发往故障的机器</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">需要人为的维护配置文件</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">这样的操作不智能</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">那么</span><span style="color: #ff0000;"><span style="font-family: 宋体;">采用健康检测机制</span>.<span style="font-family: 宋体;">可以实现故障的自动的迁移</span></span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">属性介绍</span>:</p>
<p>1.max_fails=1 &nbsp;<span style="font-family: 宋体;">当检测服务器是否正常时</span>,<span style="font-family: 宋体;">如果检测失败的次数达到规定的次数时</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">则断定该服务器故障</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">在规定的时间周期内</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">不会将请求发往该机器</span><span style="font-family: Calibri;">.</span></p>
<p>2.fail_timeout=60s定义时钟周期</p>
<p>&nbsp;</p>
<h2><span style="background-color: #adff2f;">1.10&nbsp;<strong>Nginx<span style="font-family: 宋体;">如何保证请求参数不丢</span></strong></span></h2>
<p><span style="font-family: 宋体;">在</span>nginx<span style="font-family: 宋体;">中添加请求头的参数</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">表示每次请求时</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">携带请求者的请求头信息</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">访问服务器</span><span style="font-family: Calibri;">.</span></p>
<src class="cnblogs_code">
<pre><code>proxy_set_header X-Forwarded-<span style="color: #000000;">Host $host;
proxy_set_header X</span>-Forwarded-<span style="color: #000000;">Server $host;
proxy_set_header X</span>-Forwarded-For $proxy_add_x_forwarded_for;</code></pre>

<h2><span style="background-color: #adff2f;">1.11&nbsp;<strong><span style="font-family: 宋体;">数据库数据如何备份</span>(<span style="font-family: 宋体;">数据备份策略</span><span style="font-family: Calibri;">)</span></strong></span></h2>
<ol>
<li><span style="font-family: 宋体;">冷备份</span>:<span style="font-family: 宋体;">定期将数据库中的文件进行转储</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">定期进行数据备份</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">热备份</span>:<span style="font-family: 宋体;">搭建数据库主从结构</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">当主库数据发生改变时</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">从库根据主库的二进制日志文件进行备份</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">双机热备</span>:<span style="font-family: 宋体;">数据库互为主从</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">数据库代理服务器对主库进行心跳检测</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">实现数据的高可用</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">为了防止主库宕机后发生雪崩现象</span></li>
</ol>
<h2><span style="background-color: #adff2f;">1.12&nbsp;<strong><span style="font-family: 宋体;">数据库压力大时</span>,<span style="font-family: 宋体;">怎么实现高可用</span></strong></span></h2>
<p>1.<span style="font-family: 宋体;">用数据库代理服务器搭建数据库的读写分离进行分流</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">读取从库数据</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">写数据在主库</span></p>
<p><span style="font-family: 宋体;">可用的数据库代理服务器有</span>Amoeba<span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">Mycat</span></p>
<p><span style="font-family: 宋体;">由于大量的用户的数据库操作都需要通过数据库来完成</span>.<span style="font-family: 宋体;">造成数据库负载过高</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">因为数据库操作中查询的操作占很大的比重</span><span style="font-family: Calibri;">.</span></p>
<p>2.<span style="font-family: 宋体;">数据库实现双机热备</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #adff2f;">1.13&nbsp;<strong>数据库的优化策略</strong></span></h2>
<ol>
<li><span style="font-family: 宋体;">优化</span>sql<span style="font-family: 宋体;">语句</span><span style="font-family: Calibri;">(</span><span style="font-family: 宋体;">多表操作</span><span style="font-family: Calibri;">)</span>&nbsp;&nbsp;where&nbsp;<span style="font-family: 宋体;">左连接</span> <span style="font-family: 宋体;">右连接</span> <span style="font-family: 宋体;">内连接</span></li>
</ol>
<p><span style="font-family: 宋体;">原则</span>:<span style="font-family: 宋体;">尽可能根据主键查询</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">尽可能少用关联查询</span><span style="font-family: Calibri;">.</span></p>
<ol>
<li><span style="font-family: 宋体;">创建索引</span>(<span style="font-family: 宋体;">对经常查询的数据创建索引</span><span style="font-family: Calibri;">)</span></li>
<li><span style="font-family: 宋体;">添加缓存</span>(Redis/MemCache)</li>
<li><span style="font-family: 宋体;">定期进行数据转储</span>(<span style="font-family: 宋体;">将一些查询较少的数据保存到历史表</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">让当前表维护可控的数据量</span><span style="font-family: Calibri;">)</span></li>
<li><span style="font-family: 宋体;">分库分表</span>(<span style="font-family: 宋体;">需要大量的数据库服务器</span><span style="font-family: Calibri;">)</span></li>
</ol>
<h2><span style="background-color: #adff2f;">1.14&nbsp;<strong><span style="font-family: 宋体;">什么是</span>Mycat</strong></span></h2>
<p><span style="font-family: 宋体;">是一个数据库中间件</span>,<span style="font-family: 宋体;">实现读写分离</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">分库分表和数据库故障迁移</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #adff2f;">1.15&nbsp;<strong><span style="font-family: 宋体;">什么是</span>Redis,<span style="font-family: 宋体;">运行在哪里</span></strong></span></h2>
<p><span style="font-family: 宋体;">开源的内存中的数据结构存储系统</span>,<span style="font-family: 宋体;">可以用做数据库</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">缓存和消息中间件</span></p>
<p><span style="font-family: 宋体;">基于</span>C<span style="font-family: 宋体;">语言开发</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">运行时在内存中</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">运行速度很快</span></p>
<p>https://mp.weixin.qq.com/s/0Fqp2aGq7c_x_bEK9pOeeg</p>
<h2><span style="background-color: #adff2f;">1.16&nbsp;<strong>Redis<span style="font-family: 宋体;">中的数据持久化策略</span></strong></span></h2>
<p><span style="font-family: 宋体;">如果使用时允许丢失部分数据</span>(<span style="font-family: 宋体;">少量的</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">则使用</span><span style="font-family: Calibri;">RDB</span><span style="font-family: 宋体;">模式</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">它的效率高</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">也是</span><span style="font-family: Calibri;">redis</span><span style="font-family: 宋体;">默认的策略</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">如果不允许丢失数据则采用</span><span style="font-family: Calibri;">AOF</span><span style="font-family: 宋体;">模式</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">它的安全性高</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">但是效率较低</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #adff2f;">1.17&nbsp;<strong>Redis<span style="font-family: 宋体;">中的内存维护策略</span></strong></span></h2>
<p><span style="font-family: 宋体;">问题</span>:<span style="font-family: 宋体;">如果数据都存储到</span><span style="font-family: Calibri;">redis</span><span style="font-family: 宋体;">中</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">如果内存占满了</span><span style="font-family: Calibri;">,redis</span><span style="font-family: 宋体;">如何维护</span><span style="font-family: Calibri;">?</span></p>
<p><span style="font-family: 宋体;">解决方案</span>:</p>
<ol>
<li><span style="font-family: 宋体;">动态的扩容</span>redis<span style="font-family: 宋体;">节点</span><span style="font-family: Calibri;">(</span><span style="font-family: 宋体;">不科学</span><span style="font-family: Calibri;">)</span></li>
<li>为数据设定超时时间</li>
<li><span style="font-family: 宋体;">动态的将不用的数据删除</span>.(LRU<span style="font-family: 宋体;">算法</span><span style="font-family: Calibri;">)</span></li>
</ol>
<p>&nbsp;&nbsp;<span style="font-family: 宋体;">算法介绍</span>:</p>
<p><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5633616"><span style="text-decoration: underline;"><span style="font-family: 宋体;">内存管理</span></span></a><span style="font-family: 宋体;">的一种页面置换算法，对于在内存中但又不用的</span><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%9D%97/107672"><span style="text-decoration: underline;"><span style="font-family: 宋体;">数据块</span></span></a><span style="font-family: 宋体;">（内存块）叫做</span>LRU<span style="font-family: 宋体;">，操作系统会根据哪些数据属于</span><span style="font-family: Arial;">LRU</span><span style="font-family: 宋体;">而将其移出内存而腾出空间来加载另外的数据。</span></p>
<h2><span style="background-color: #adff2f;">1.18&nbsp;<strong>redis<span style="font-family: 宋体;">为什么要分片</span></strong></span></h2>
<p><span style="font-family: 宋体;">特点</span>:<span style="font-family: 宋体;">实现动态内存扩容</span></p>
<p><span style="font-family: 宋体;">数据存储机制</span>:</p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段4.png" alt="" /></p>
<h2><span style="background-color: #adff2f;">1.19&nbsp;<strong>Hash<span style="font-family: 宋体;">一致性</span></strong></span></h2>
<p>1.均衡性：尽可能均匀分片节点中的数据</p>
<p>2.单调性：实现数据的动态迁移</p>
<p>3.分散性：<span style="font-family: 宋体;">由于分布式原因</span>,<span style="font-family: 宋体;">导致不能获取全部节点信息</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">使得一个</span><span style="font-family: Calibri;">key</span><span style="font-family: 宋体;">有多个位置</span></p>
<p>4.负载：<span style="font-family: 宋体;">是分散性另一种表现形式</span>.<span style="font-family: 宋体;">表现为一个位置有多个</span><span style="font-family: Calibri;">ke</span>y</p>
<h2><span style="background-color: #87cefa;">1.20&nbsp;<strong><span style="font-family: 宋体;">知道哨兵机制吗</span>,<span style="font-family: 宋体;">怎么实现的</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">实现了什么功能</span></strong></span></h2>
<p><span style="font-family: 宋体;">功能</span>:<span style="font-family: 宋体;">实现</span><span style="font-family: Calibri;">redis</span><span style="font-family: 宋体;">高可用</span></p>
<p><span style="font-family: 宋体;">机制</span>:<span style="font-family: 宋体;">心跳检测</span></p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段5.png" alt="" /></p>
<h2><span style="background-color: #87cefa;">1.21&nbsp;<strong>哨兵和分片的优缺点</strong></span></h2>
<p><span style="font-family: 宋体;">优点</span>:</p>
<ol>
<li><span style="font-family: 宋体;">分片可以使</span>redis<span style="font-family: 宋体;">动态内存扩容</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">分片可以将数据均匀的分配到不同的节点中</span>,<span style="font-family: 宋体;">使数据分散保存</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">哨兵可以实现</span>redis<span style="font-family: 宋体;">高可用</span><span style="font-family: Calibri;">.</span></li>
</ol>
<p>&nbsp;&nbsp;<span style="font-family: 宋体;">缺点</span>:</p>
<ol>
<li><span style="font-family: 宋体;">分片如果有一个节点出现宕机则整个分片都不能正常使用</span>.</li>
<li><span style="font-family: 宋体;">哨兵如果发生宕机现象</span>,<span style="font-family: 宋体;">则影响整个</span><span style="font-family: Calibri;">redis</span><span style="font-family: 宋体;">服务</span><span style="font-family: Calibri;">.</span></li>
</ol>
<p><span style="font-family: 宋体;">升级</span>:</p>
<ol>
<li><span style="font-family: 宋体;">使用多台</span>redis<span style="font-family: 宋体;">实现内存空间的动态扩容</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">实现在</span>redis<span style="font-family: 宋体;">内存实现高可用</span><span style="font-family: Calibri;">(</span><span style="font-family: 宋体;">不再使用哨兵机制</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">使用组件</span><span style="font-family: Calibri;">(</span><span style="color: #ff0000;"><strong>ruby</strong></span>)</li>
</ol>
<p><span style="font-family: 宋体;">搭建集群</span>,<span style="font-family: 宋体;">实现分片和高可用的全部功能</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #87cefa;">1.22&nbsp;<strong>Redis<span style="font-family: 宋体;">集群</span></strong></span></h2>
<p><span style="font-family: 宋体;">使用</span>ruby<span style="font-family: 宋体;">工具创建集群</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">集群中全部的节点相互之间互相通讯</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">在</span><span style="font-family: Calibri;">redis</span><span style="font-family: 宋体;">内部实现高可用</span><span style="font-family: Calibri;">.redis</span><span style="font-family: 宋体;">集群是分片和哨兵的集合体</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #87cefa;">1.23&nbsp;<strong>伪静态技术</strong></span></h2>
<p><span style="font-family: 宋体;">动态页面不能被搜索引擎收录</span>.<span style="font-family: 宋体;">为了保证搜索引擎的友好性</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">则以</span><span style="font-family: Calibri;">.html</span><span style="font-family: 宋体;">的静态页面形式展现动态页面数据</span></p>
<h2><span style="background-color: #87cefa;">1.24&nbsp;<strong>跨域问题</strong></span></h2>
<p><span style="font-family: 宋体;">说明</span>:<span style="font-family: 宋体;">在</span><span style="text-decoration: underline;"><a href="http://www.jt.com中调用manage.jt.com">www.jt.com</a><span style="font-family: 宋体;"><a href="http://www.jt.com中调用manage.jt.com">中</a></span></span><span style="font-family: 宋体;"><span style="color: #000000;">调用</span></span><span style="text-decoration: underline;"><a href="http://www.jt.com中调用manage.jt.com"><span style="font-family: Calibri;">manage.jt.com</span></a></span><span style="font-family: 宋体;">时访问不成功</span>.<span style="font-family: 宋体;">原因该操作是一个跨域请求</span><span style="font-family: Calibri;">.</span></p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段6.png" alt="" /></p>
<p><span style="font-family: 宋体;">浏览器不允许进行跨域请求</span>.<span style="font-family: 宋体;">会将成功返回的数据进行拦截</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">不予显示</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">一切出于安全性的考虑</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #87cefa;">1.25&nbsp;<strong>同源策略</strong></span></h2>
<p><span style="font-family: 宋体;">规则：</span>请求<span style="color: #ff0000;"><strong><span style="font-family: 宋体;">协议</span>/<span style="font-family: 宋体;">域名</span><span style="font-family: Calibri;">/</span><span style="font-family: 宋体;">端口号</span></strong></span><span style="font-family: 宋体;">是否相同</span>,<span style="font-family: 宋体;">如果三者都一致</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">那么是同域访问</span><span style="font-family: Calibri;">.(</span><span style="font-family: 宋体;">即同源策略</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">浏览器可以正常执行</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">除此之外的全部的请求都是跨域请求</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #87cefa;">1.26&nbsp;<strong><span style="font-family: 宋体;">怎么解决跨域问题</span>?</strong></span></h2>
<p><span style="font-family: 宋体;">利用</span>javascript<span style="font-family: 宋体;">中</span>src<span style="font-family: 宋体;">属性实现跨域</span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">客户端定义回调函数</span> callback=hello</p>
<p><span style="font-family: 宋体;">服务端程序封装特定的</span>JSON<span style="font-family: 宋体;">格式 </span>&nbsp;&nbsp;callback(JSON) &nbsp;执行回调函数</p>
<p>&nbsp;</p>
<p>JSONP<span style="font-family: 宋体;">就是基于这个原理实现的</span><span style="font-family: Calibri;">.</span></p>
<p class="17"><span style="background-color: #87cefa;">JSONP(JSON with Padding)<span style="font-family: 微软雅黑;">是</span><a href="https://baike.baidu.com/item/JSON"><span style="background-color: #87cefa;">JSON</span></a><span style="font-family: 微软雅黑;">的一种</span>&ldquo;<span style="font-family: 微软雅黑;">使用模式</span><span style="font-family: Consolas;">&rdquo;</span><span style="font-family: 微软雅黑;">，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 </span><span style="font-family: Consolas;">server1.example.com </span><span style="font-family: 微软雅黑;">的网页无法与不是 </span><span style="font-family: Consolas;">server1.example.com</span><span style="font-family: 微软雅黑;">的服务器沟通，而 </span><span style="font-family: Consolas;">HTML </span><span style="font-family: 微软雅黑;">的</span><span style="font-family: Consolas;">&lt;script&gt; </span><span style="font-family: 微软雅黑;">元素是一个例外。利用 </span><span style="font-family: Consolas;">&lt;script&gt; </span><span style="font-family: 微软雅黑;">元素的这个开放策略，网页可以得到从其他来源动态产生的 </span><span style="font-family: Consolas;">JSON </span><span style="font-family: 微软雅黑;">资料，而这种使用模式就是所谓的 </span><span style="font-family: Consolas;">JSONP</span><span style="font-family: 微软雅黑;">。用 </span><span style="font-family: Consolas;">JSONP </span><span style="font-family: 微软雅黑;">抓到的资料并不是 </span><span style="font-family: Consolas;">JSON</span><span style="font-family: 微软雅黑;">，而是任意的</span><span style="font-family: Consolas;">JavaScript</span><span style="font-family: 微软雅黑;">，用 </span><span style="font-family: Consolas;">JavaScript </span><span style="font-family: 微软雅黑;">直译器执行而不是用 </span><span style="font-family: Consolas;">JSON </span><span style="font-family: 微软雅黑;">解析器解析</span></span></p>
<p>&nbsp;</p>
<h2><span style="background-color: #87cefa;">1.27&nbsp;<strong>JQuery<span style="font-family: 宋体;">中怎么使用</span><span style="font-family: Calibri;">JSONP</span></strong></span></h2>
<p><span style="font-family: 宋体;">跨域的缺点</span>:<span style="font-family: 宋体;">回调的函数需要提前定义</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">程序员自己定义</span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">解决方案</span>:&nbsp;<span style="font-family: 宋体;">采用</span>jQuery<span style="font-family: 宋体;">中的</span><span style="font-family: Calibri;">JSONP</span><span style="font-family: 宋体;">实现跨域的请求</span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">语法</span>:</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">        $.ajax({
            url:</span>"http://manage.jt.com/web/testJSONP"<span style="color: #000000;">,
            type:</span>"get"<span style="color: #000000;">,
            dataType:</span>"jsonp",       <span style="color: #008000;">//</span><span style="color: #008000;">返回值的类型 JSONP必须添加否则不能回调 函数</span>
            jsonp: "callback",   <span style="color: #008000;">//</span><span style="color: #008000;">指定参数名称</span>
            jsonpCallback: "hello",  <span style="color: #008000;">//</span><span style="color: #008000;">指定回调函数名称</span>
            success:<span style="color: #0000ff;">function</span><span style="color: #000000;"> (data){
                alert(data.id);
                alert(data.name);
                </span><span style="color: #008000;">//</span><span style="color: #008000;">转化为字符串使用</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">var obj = eval("("+data+")");</span>
                <span style="color: #008000;">//</span><span style="color: #008000;">alert(obj.name);</span>
<span style="color: #000000;">            }    
        });</span></code></pre>

<h2><span style="background-color: #87cefa;">1.28&nbsp;<strong>HttpClient</strong></span></h2>
<p>HTTP <span style="font-family: 宋体;">协议可能是现在 </span><span style="font-family: Calibri;">Internet </span><span style="font-family: 宋体;">上使用得最多、最重要的协议了，越来越多的 </span><span style="font-family: Calibri;">Java </span><span style="font-family: 宋体;">应用程序需要直接通过 </span><span style="font-family: Calibri;">HTTP </span><span style="font-family: 宋体;">协议来访问网络资源。虽然在 </span><span style="font-family: Calibri;">JDK </span><span style="font-family: 宋体;">的 </span><span style="font-family: Calibri;">java net</span><span style="font-family: 宋体;">包中已经提供了访问 </span><span style="font-family: Calibri;">HTTP </span><span style="font-family: 宋体;">协议的基本功能，但是对于大部分应用程序来说，</span><span style="font-family: Calibri;">JDK </span><span style="font-family: 宋体;">库本身提供的功能还不够丰富和灵活。</span><span style="font-family: Calibri;">HttpClient </span><span style="font-family: 宋体;">是 </span><span style="font-family: Calibri;">Apache Jakarta Common </span><span style="font-family: 宋体;">下的子项目，用来提供高效的、最新的、功能丰富的支持 </span><span style="font-family: Calibri;">HTTP </span><span style="font-family: 宋体;">协议的客户端编程工具包，并且它支持 </span><span style="font-family: Calibri;">HTTP </span><span style="font-family: 宋体;">协议最新的版本和建议。</span><span style="font-family: Calibri;">HttpClient </span><span style="font-family: 宋体;">已经应用在很多的项目中，比如 </span><span style="font-family: Calibri;">Apache Jakarta </span><span style="font-family: 宋体;">上很著名的另外两个开源项目 </span><span style="font-family: Calibri;">Cactus </span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">&nbsp;</span><a href="https://baike.baidu.com/item/HTMLUnit"><span style="text-decoration: underline;">HTMLUnit</span></a>&nbsp;<span style="font-family: 宋体;">都使用了 </span><span style="font-family: Calibri;">HttpClient</span><span style="font-family: 宋体;">。现在</span><span style="font-family: Calibri;">HttpClient</span><span style="font-family: 宋体;">最新版本为 </span><span style="font-family: Calibri;">HttpClient 4.5 (GA) </span><span style="font-family: 宋体;">（</span><span style="font-family: Calibri;">2015-09-11</span><span style="font-family: 宋体;">）</span></p>
<p><span style="font-family: 宋体;">总结</span>:<span style="color: #ff0000;"><strong>Http</strong><strong>Client</strong><strong><span style="font-family: 宋体;">是</span>java<span style="font-family: 宋体;">为了远程请求开发的</span><span style="font-family: Calibri;">http</span><span style="font-family: 宋体;">请求工具包</span></strong><strong>.</strong></span></p>
<h2><span style="background-color: #87cefa;">1.29&nbsp;<strong>HttpClient<span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">JSONP</span><span style="font-family: 宋体;">的区别</span></strong></span></h2>
<ol>
<li>JSONP<span style="font-family: 宋体;">是基于浏览器的</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">解决跨域问题的</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">而</span><span style="font-family: Calibri;">http</span>Client<span style="font-family: 宋体;">是基于代码</span>.<span style="font-family: 宋体;">模拟</span><span style="font-family: Calibri;">http</span><span style="font-family: 宋体;">请求</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">获取服务端的参数的</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">功能上类似</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">但是经过的环节不同</span><span style="font-family: Calibri;">.</span></li>
<li>安全性不同：JSONP<span style="font-family: 宋体;">的全部信息都可以通过浏览器进行监控</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">但是</span><span style="font-family: Calibri;">Http</span>Client<span style="font-family: 宋体;">浏览器不能监控</span>.</li>
</ol>
<p>　　3.代码调用层级不同：Jsonp需要调用服务端业务逻辑,<span style="font-family: 宋体;">最多</span>3<span style="font-family: 宋体;">层，</span>HttpClient<span style="font-family: 宋体;">需要调用</span><span style="font-family: Calibri;">5</span><span style="font-family: 宋体;">层</span></p>
<p><span style="font-family: 宋体;">适用场景：</span><span style="font-family: 宋体;">如果从服务端获取数据</span>,js<span style="font-family: 宋体;">可以直接解析</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">使用</span><span style="font-family: Calibri;">JSONP,</span><span style="font-family: 宋体;">如果服务端的程序的返回值</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">需要进一步处理</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">这时使用</span><span style="font-family: Calibri;">Http</span>Client</p>
<p><img src="./images/Java面试题_第四阶段7.png" alt="" /></p>
<h2><span style="background-color: #ffa07a;">1.30&nbsp;<strong>你的单点登录是怎么调用的</strong></span></h2>
<p><span style="font-family: 宋体;">流程图</span>:</p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段8.png" alt="" /></p>
<p><span style="font-family: 宋体;">原理</span>:</p>
<p><span style="font-family: 宋体;">实现步骤</span>:</p>
<p><span style="font-family: 宋体;">当用户登陆时</span>,<span style="font-family: 宋体;">通过</span><span style="font-family: Calibri;">nginx</span><span style="font-family: 宋体;">访问</span><span style="font-family: Calibri;">jt-web</span><span style="font-family: 宋体;">中任意的服务器之后输入用户名和密码访问</span><span style="font-family: Calibri;">J</span>T-SSO<span style="font-family: 宋体;">单点登录服务器</span>.</p>
<p><span style="font-family: 宋体;">获取用户的登陆信息查询数据库</span>,<span style="font-family: 宋体;">校验用户名和密码是否正确</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果用户名和密码是正确的</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">将用户信息转化为</span><span style="font-family: Calibri;">JSON</span><span style="font-family: 宋体;">串</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">之后生成加密的秘钥</span><span style="font-family: Calibri;">TOKEN</span>(MD5(<span style="font-family: 宋体;">盐值</span>+<span style="font-family: 宋体;">随机数</span>)).<span style="font-family: 宋体;">将</span><span style="font-family: Calibri;">token</span>:userJSON<span style="font-family: 宋体;">保存</span>redis<span style="font-family: 宋体;">中</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">并且将</span><span style="font-family: Calibri;">token</span><span style="font-family: 宋体;">信息返回给客户端</span><span style="font-family: Calibri;">(jt</span>-web).</p>
<p>Jt-web<span style="font-family: 宋体;">接收到服务端数据时首先校验数据是否有效</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果数据准确无误</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">将</span><span style="font-family: Calibri;">token</span><span style="font-family: 宋体;">信息写入到浏览器的</span><span style="font-family: Calibri;">Cookie(</span>4K)<span style="font-family: 宋体;">中</span></p>
<p><span style="font-family: 宋体;">当用户再次访问</span>jt-web<span style="font-family: 宋体;">时</span>,<span style="font-family: 宋体;">首先应该获取用户的</span><span style="font-family: Calibri;">Token</span><span style="font-family: 宋体;">信息</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">之后查询</span><span style="font-family: Calibri;">redis</span><span style="font-family: 宋体;">缓存服务器获取</span><span style="font-family: Calibri;">user</span>JSON<span style="font-family: 宋体;">数据</span>,<span style="font-family: 宋体;">之后将</span><span style="font-family: Calibri;">user</span>JSON<span style="font-family: 宋体;">转化为</span>User<span style="font-family: 宋体;">对象进行使用</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">实现免密登录</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果</span><span style="font-family: Calibri;">token</span><span style="font-family: 宋体;">数据为</span><span style="font-family: Calibri;">null</span>,<span style="font-family: 宋体;">那么则让用户访问登陆页面</span>.</p>
<h2><span style="background-color: #ffa07a;">1.31&nbsp;<strong><span style="font-family: 宋体;">同一线程内的数据怎么实现共享</span>(ThreadLocal)</strong></span></h2>
<p><span style="font-family: 宋体;">名称</span>:<span style="font-family: 宋体;">本地线程变量</span></p>
<p><span style="font-family: 宋体;">作用</span>:<span style="font-family: 宋体;">在同一线程内实现数据共享</span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">原理</span>:</p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段9.png" alt="" /></p>
<p><span style="font-family: 宋体;">说明</span>:ThreadLocal<span style="font-family: 宋体;">是线程安全的</span>,<span style="font-family: 宋体;">在同一个线程内实现数据的共享</span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">注意</span>:<span style="font-family: 宋体;">使用完成后</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">切记销毁</span><span style="font-family: Calibri;">thread</span>Local<span style="font-family: 宋体;">对象</span>,<span style="font-family: 宋体;">否则</span><span style="font-family: Calibri;">gc</span><span style="font-family: 宋体;">不能回收</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">导致</span><span style="font-family: Calibri;">J</span>VM<span style="font-family: 宋体;">内存泄漏</span>.</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> UserThreadLocal {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果保存数据有多个,则使用Map集合</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> ThreadLocal&lt;User&gt; userThread = <span style="color: #0000ff;">new</span> ThreadLocal&lt;User&gt;<span style="color: #000000;">();
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> set(User user){
        userThread.set(user);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> User get(){
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> userThread.get();
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">线程销毁方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> remove(){
        userThread.remove();
    }
}</span></code></pre>

<p>&nbsp;</p>
<h2><span style="background-color: #ffa07a;">1.32&nbsp;<strong><span style="font-family: 宋体;">如何实现的单点登录</span>S</strong><strong>SO</strong></span></h2>
<p><span style="font-family: 宋体;">问题</span>:<span style="font-family: 宋体;">因为后台的服务器采用的是集群的部署方式</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">肯定有多台服务器</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果将用户的登陆信息保存到服务器端</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">因为多个服务器之间不能共享</span><span style="font-family: Calibri;">session</span>.<span style="font-family: 宋体;">所以相互之间不同实现</span>Session<span style="font-family: 宋体;">共享</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">导致用户频繁登陆</span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">初级</span>:<span style="font-family: 宋体;">使用</span><span style="font-family: Calibri;">Nginx</span><span style="font-family: 宋体;">提供的</span><span style="font-family: Calibri;">IP_Hash</span></p>
<p><span style="font-family: 宋体;">高级</span>:</p>
<ol>
<li><span style="font-family: 宋体;">当用户登陆操作时</span>,<span style="font-family: 宋体;">首选访问时单点登录服务器</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">进行登录操作</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">如果登录正确</span>.<span style="font-family: 宋体;">则生成用户的秘钥</span><span style="font-family: Calibri;">to</span>ken.<span style="font-family: 宋体;">将用户信息转化为</span>JSON<span style="font-family: 宋体;">串和</span><span style="font-family: Calibri;">token</span><span style="font-family: 宋体;">一起保存到</span><span style="font-family: Calibri;">redis</span><span style="font-family: 宋体;">缓存中</span><span style="font-family: Calibri;">.</span></li>
</ol>
<p>3.<span style="font-family: 宋体;">将</span><span style="font-family: Calibri;">token</span><span style="font-family: 宋体;">信息返回给客户端</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">将数据保存到客户端浏览器中的</span><span style="font-family: Calibri;">cookie</span><span style="font-family: 宋体;">中</span><span style="font-family: Calibri;">.</span></p>
<p>4.<span style="font-family: 宋体;">当用户进行其他操作需要用到用户信息时</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">首先检测</span><span style="font-family: Calibri;">Cookie</span><span style="font-family: 宋体;">中是否有</span><span style="font-family: Calibri;">token</span>,<span style="font-family: 宋体;">第二步检测</span>redis<span style="font-family: 宋体;">中的数据是否为</span><span style="font-family: Calibri;">null</span>.<span style="font-family: 宋体;">如果一切正确</span>,<span style="font-family: 宋体;">则允许跳转到指定页面中</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果其中有一项有误</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">则表示用户登陆异常</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">让用户重新登陆</span><span style="font-family: Calibri;">.</span></p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段10.png" alt="" /></p>
<h2><span style="background-color: #ffa07a;">1.33&nbsp;<strong>当</strong><strong>zk</strong><strong><span style="font-family: 宋体;">如果宕机后</span>,<span style="font-family: 宋体;">消费者能否正确消费</span><span style="font-family: Calibri;">?????</span></strong></span></h2>
<p><span style="font-family: 宋体;">说明</span>:</p>
<p><span style="font-family: 宋体;">答案</span>:<span style="font-family: 宋体;">可以</span></p>
<p><span style="font-family: 宋体;">因为</span>zk<span style="font-family: 宋体;">会动态的向客户端更新服务列表信息</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">当</span><span style="font-family: Calibri;">zk</span><span style="font-family: 宋体;">宕机后</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">由于之前已经同步了</span><span style="font-family: Calibri;">zk</span><span style="font-family: 宋体;">的服务列表信息</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">所以客户端可以按照自己已经缓存的清单进行访问</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果在这个期间服务端程序发现宕机现象</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">那么则访问故障机时由于不能通信</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">则等待超时时间</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">则访问下一台服务器</span><span style="font-family: Calibri;">.</span></p>
<p><span style="font-family: 宋体;">如果这时</span>,<span style="font-family: 宋体;">所有的服务端程序都宕机</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">则整个服务陷入瘫痪</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #ffa07a;">1.34&nbsp;<strong><span style="font-family: 宋体;">微服务治理方案</span>(ZooKeeper)</strong></span></h2>
<p><span style="font-family: 宋体;">说明</span>:<span style="font-family: 宋体;">增加服务器或者减少服务器都是自动完成</span></p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段11.png" alt="" /></p>
<p><span style="font-family: 宋体;">业务逻辑说明</span>:</p>
<ol>
<li><span style="font-family: 宋体;">当服务的提供者启动时</span>,<span style="font-family: 宋体;">会将服务的名称</span><span style="font-family: Calibri;">:IP:</span><span style="font-family: 宋体;">端口会写入注册中心</span><span style="font-family: Calibri;">.</span></li>
<li>注册中心内部会维护服务列表</li>
<li><span style="font-family: 宋体;">当消费者需要访问服务时</span>,<span style="font-family: 宋体;">需要先访问注册中心获取服务列表信息</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">之后将服务列表保存到本地缓存中</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">方便后续的访问</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">在客户端内部有负载均衡的算法</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">筛选出一台服务器</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">之后进行访问</span><span style="font-family: Calibri;">.</span></li>
<li><span style="font-family: 宋体;">如果后台服务器出现宕机现象</span>.<span style="font-family: 宋体;">这时注册中心通过心跳检测的方式判断服务器是否宕机</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">如果服务器宕机则会将该服务器信息从服务列表中删除</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">之后将新的服务列表发送消费者</span><span style="font-family: Calibri;">(</span><span style="font-family: 宋体;">客户端</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">进行更新</span><span style="font-family: Calibri;">.</span></li>
</ol>
<h2><span style="background-color: #ffa07a;">1.35&nbsp;<strong>你怎么理解</strong><strong>SOA(</strong><strong>面向服务</strong><strong>)</strong></span></h2>
<p><span style="color: #ff0000;"><span style="font-family: 宋体;">面向服务的架构</span><span style="font-family: 宋体;">（</span>SOA</span><span style="font-family: 宋体;"><span style="color: #ff0000;">）</span>是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间</span><span style="font-family: 宋体; color: #ff0000;">定义良好的接口</span><span style="font-family: 宋体;">和契约联系起来。</span><span style="font-family: 宋体; color: #ff0000;">接口是采用中立的方式进行定义的</span><span style="font-family: 宋体;">，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。</span></p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段12.png" alt="" /></p>
<h2><span style="background-color: #ffa07a;">1.36&nbsp;<strong><span style="font-family: 宋体;">知道</span>R</strong><strong>PC</strong><strong>协议吗</strong></span></h2>
<p><span style="font-family: 宋体;">总结</span>:RPC<span style="font-family: 宋体;">调用的规则可以传输</span>java<span style="font-family: 宋体;">对象</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">底层实现时将数据转化流</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">并且该流经过加密处理</span><span style="font-family: Calibri;">.</span><span style="font-family: 宋体;">并且</span>rpc<span style="font-family: 宋体;">内部使用</span>UTF-8编码格式</p>
<p><span style="font-family: 宋体;">要求</span>:<span style="color: #ff0000;"><span style="font-family: 宋体;">传输的</span><span style="font-family: Calibri;">java</span><span style="font-family: 宋体;">对象必须序列化</span></span></p>
<p>&nbsp;</p>
<h2><span style="background-color: #ffa07a;">1.37&nbsp;<strong><span style="font-family: 宋体;">什么是</span>Dubbo<span style="font-family: 宋体;">框架</span></strong></span></h2>
<p>Dubbo<span style="font-family: 宋体;">是</span><span style="font-family: Calibri;">&nbsp;[1]</span>&nbsp;&nbsp;<span style="font-family: 宋体;">阿里巴巴公司开源的一个高性能优秀的</span><a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6"><span style="font-family: 宋体;">服务框架</span></a>(SOA)<span style="font-family: 宋体;">，使得应用可通过高性能的</span>RPC<span style="font-family: 宋体;">实现服务的输出和输入功能可以和</span><a href="https://baike.baidu.com/item/Spring">Spring</a><span style="font-family: 宋体;">框架无缝集成</span><span style="font-family: 宋体;">。</span></p>
<h2><span style="background-color: #ffa07a;">1.38&nbsp;<strong>Nginx<span style="font-family: 宋体;">和</span></strong><strong>ZK</strong><strong>的区别</strong></span></h2>
<p>&nbsp;Nginx:</p>
<ol>
<li><span style="color: #ff0000;"><strong>Nginx</strong><strong><span style="font-family: 宋体;">主要是为了反向代理</span>(Http)</strong></span></li>
<li>负载均衡</li>
<li>Nginx<span style="font-family: 宋体;">主要搭建在公司网关服务器上</span></li>
</ol>
<p>Zk:<span style="font-family: 宋体;">通过</span><span style="font-family: Calibri;">RPC</span><span style="font-family: 宋体;">进行远程方法调用</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">是服务端程序</span></p>
<p><span style="font-family: 宋体;">主要作用是实现服务端的高可用</span>.<span style="font-family: 宋体;">搭建在内网中</span><span style="font-family: Calibri;">.</span></p>
<h2><span style="background-color: #ffa07a;">1.39&nbsp;<strong><span style="font-family: 宋体;">知道什么是消息队列吗</span>,<span style="font-family: 宋体;">并说出几种常用的</span></strong></span></h2>
<p>消息队列可以<span style="font-family: 宋体; color: #ff0000;">缓解服务器的访问压力</span>,<span style="font-family: 宋体;">请求在在访问服务器时</span>,<span style="font-family: 宋体;">先写入消息队列中</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">可以实现请求的</span><span style="color: #ff0000;">异步操作</span>,<span style="font-family: 宋体;">起到</span><span style="color: #ff0000;">平峰削骨</span>的作用</p>
<p><span style="font-family: 宋体;">但是缺点是消耗了用户的实际等待时间</span>.</p>
<p><span style="font-family: 宋体;">常见的消息队列产品有</span>activeMQ(apache<span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">),RabbitMQ(</span><span style="font-family: 宋体;">爱立信的</span><span style="font-family: Calibri;">)</span></p>
<h2><span style="background-color: #90ee90;">1.40&nbsp;<strong>消息队列有几种工作模式</strong></span></h2>
<p>1.<span style="font-family: 宋体;">简单模式</span>2.<span style="font-family: 宋体;">工作模式</span><span style="font-family: Calibri;">3.</span><span style="font-family: 宋体;">发布订阅模式</span><span style="font-family: Calibri;">4.</span><span style="font-family: 宋体;">路由模式</span></p>
<p>5.<span style="font-family: 宋体;">主题模式 </span>6.RPC模式</p>
<h2><span style="background-color: #90ee90;">1.41&nbsp;<strong>倒排索引</strong></span></h2>
<p><span style="font-family: 宋体;">倒排索引源于实际应用中需要根据属性的</span><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">值</span></strong></span><span style="font-family: 宋体;">来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由</span><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">属性值来确定记录的位置</span></strong></span><span style="font-family: 宋体;">，因而称为倒排索引</span>(inverted index)<span style="font-family: 宋体;">。带有倒排索引的文件我们称为倒排</span><a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span style="text-decoration: underline;"><span style="font-family: 宋体;">索引文件</span></span></a><span style="font-family: 宋体;">，简称</span><a href="https://baike.baidu.com/item/%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6"><span style="text-decoration: underline;"><span style="font-family: 宋体;">倒排文件</span></span></a>(inverted file)<span style="font-family: 宋体;">。</span></p>
<p>&nbsp;<img src="./images/Java面试题_第四阶段13.png" alt="" /></p>
<h2><span style="background-color: #90ee90;">1.42&nbsp;<strong>Solr<span style="font-family: 宋体;">介绍</span><span style="font-family: Calibri;">/ES</span></strong></span></h2>
<p>Solr<span style="font-family: 宋体;">是一个独立的</span><span style="color: #ff0000;"><a href="https://baike.baidu.com/item/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%90%9C%E7%B4%A2"><span style="text-decoration: underline; color: #ff0000;"><span style="font-family: 宋体;">企业级搜索</span></span></a><span style="font-family: 宋体;">应用服务器</span></span><span style="font-family: 宋体;">，它对外提供类似于</span>Web-service<span style="font-family: 宋体;">的</span><span style="font-family: Arial;">API</span><span style="font-family: 宋体;">接口。用户可以通过</span><span style="font-family: Arial;">http</span><span style="font-family: 宋体;">请求，向搜索引擎服务器提交一定格式的</span><span style="font-family: Arial;">XML</span><span style="font-family: 宋体;">文件，生成索引；也可以通过</span><span style="font-family: Arial;">Http Get</span><span style="font-family: 宋体;">操作提出查找请求，并得到</span><span style="font-family: Arial;">XML</span><span style="font-family: 宋体;">格式的返回结果</span>.</p>
<p><span style="font-family: 宋体;">基于</span>Lucene<span style="font-family: 宋体;">的全文搜索服务器。同时对其进行了扩展，提供了比</span><span style="font-family: Arial;">Lucene</span><span style="font-family: 宋体;">更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的</span><a href="https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span style="text-decoration: underline;"><span style="font-family: 宋体;">全文搜索引擎</span></span></a><span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">特点</span>:</p>
<ol>
<li>solr<span style="font-family: 宋体;">可以根据数据库表自动生成索引文件</span><span style="font-family: Arial;">.</span></li>
<li>Solr<span style="font-family: 宋体;">可以动态的定期自动更新索引</span><span style="font-family: Arial;">(</span><span style="font-family: 宋体;">对更新的数据进行索引的修改</span><span style="font-family: Arial;">)</span></li>
</ol>
<h2>1.43&nbsp;<strong>D</strong><strong>ocker</strong><strong>介绍</strong></h2>
<p>&nbsp;<img src="./images/Java面试题_第四阶段14.png" alt="" /></p>
<p>Docker <span style="font-family: 宋体;">是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的</span><a href="https://baike.baidu.com/item/Linux"><span style="text-decoration: underline;">Linux</span></a>机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<p><span style="font-family: 宋体;">一个完整的</span>Docker<span style="font-family: 宋体;">有以下几个部分组成：</span></p>
<p>DockerClient<span style="font-family: 宋体;">客户端 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p>Docker Daemon<span style="font-family: 宋体;">守护进程 &nbsp;&nbsp;客户端和</span><span style="font-family: Calibri;">Docker</span><span style="font-family: 宋体;">容器交互的媒介</span></p>
<p>Docker Image<span style="font-family: 宋体;">镜像 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应用程序的模板</span></p>
<p>DockerContainer<span style="font-family: 宋体;">容器 &nbsp;&nbsp;&nbsp;&nbsp;启动后的应用程序</span></p>
<h2>1.44&nbsp;<strong>D</strong><strong>o</strong><strong>cker<span style="font-family: 宋体;">调用原理</span></strong></h2>
<p>&nbsp;<img src="./images/Java面试题_第四阶段15.png" alt="" /></p>
<p><span style="font-family: 宋体;">模块描述</span>:</p>
<p>1.docker</p>
<p>Docker<span style="font-family: 宋体;">客户端程序</span></p>
<p>2.daemon</p>
<p><span style="font-family: 宋体;">一般在宿主主机的后台运行</span>,<span style="font-family: 宋体;">作为服务端接收客户端的请求</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">并且处理这些请求</span><span style="font-family: Calibri;">(</span><span style="font-family: 宋体;">创建</span><span style="font-family: Calibri;">/</span><span style="font-family: 宋体;">运行</span><span style="font-family: Calibri;">/</span><span style="font-family: 宋体;">分发容器</span><span style="font-family: Calibri;">).</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;客户端和服务器既可以运行在一个主机中,也可以通过socket/RESTful来实现通信</p>
<p>3.image:</p>
<p>Docker中的镜像文件, <span style="font-family: 宋体;">为应用程序的模板</span>,<span style="font-family: 宋体;">一般都是只读的不允许修改</span></p>
<p>Docker的镜像文件来源有两种:</p>
<p>　　1.Docker<span style="font-family: 宋体;">官网中的镜像文件</span></p>
<p>　　2.本地的镜像文件</p>
<p>&nbsp;</p>
<p>4.Container:</p>
<p>Docker<span style="font-family: 宋体;">容器</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">通过</span><span style="font-family: Calibri;">image</span><span style="font-family: 宋体;">镜像创建容器后</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">在容器中运行应用程序</span><span style="font-family: Calibri;">(</span><span style="font-family: 宋体;">类似于</span><span style="font-family: Calibri;">new</span><span style="font-family: 宋体;">一个对象</span><span style="font-family: Calibri;">)</span></p>
<p>5.Repository:</p>
<p><span style="font-family: 宋体;">管理镜像的仓库</span>,<span style="font-family: 宋体;">类似于</span><span style="font-family: Calibri;">Maven</span><span style="font-family: 宋体;">仓库管理</span><span style="font-family: Calibri;">jar</span><span style="font-family: 宋体;">包文件</span></p>
<p><span style="font-family: 宋体;">调用原理</span>:</p>
<p>1.Docker<span style="font-family: 宋体;">客户端通过</span><span style="font-family: Calibri;">Daemon</span><span style="font-family: 宋体;">请求创建</span><span style="font-family: Calibri;">Docker</span><span style="font-family: 宋体;">容器</span></p>
<p>2.Daemon<span style="font-family: 宋体;">接收请求后</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">从</span><span style="font-family: Calibri;">Repository</span><span style="font-family: 宋体;">中查找需要的</span><span style="font-family: Calibri;">Image</span><span style="font-family: 宋体;">镜像文件</span></p>
<p>3.找到对应的镜像文件后,创建Docker容器</p>
<p>4.调用容器完成具体任务(redis/nginx/tomcat/mysql<span style="font-family: 宋体;">等</span>)</p>
<h2>1.45&nbsp;<strong>Docker</strong><strong><span style="font-family: 宋体;">镜像拉取过程</span> </strong></h2>
<p>&nbsp;<img src="./images/Java面试题_第四阶段16.png" alt="" /></p>
<p>1.当客户端获取镜像文件时,会向服务器发起请求.</p>
<p>2.Docker<span style="font-family: 宋体;">引擎首先会检查本地是否含有镜像文件</span><span style="font-family: Calibri;">,</span><span style="font-family: 宋体;">如果没有则会联网下载镜像文件</span></p>
<p>3.从共有云中获取Image镜像文件后,保存到本地</p>
<p>4.当用户需要使用该应用是,通过<span style="color: #ff0000;"><strong>镜像</strong></span>文件创建<span style="color: #ff0000;"><strong>容器</strong></span>,为用户提供服务</p>
<p>Dockerfile<span style="font-family: 宋体;">难</span></p>
<h2><span style="background-color: #90ee90;">1.46&nbsp;<strong>京淘项目人员分配</strong></span></h2>
<p><span style="font-family: 宋体;">开发周期</span>:<span style="font-family: 宋体;">开发</span><span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">个月但是不停的更新迭代</span></p>
<p><span style="font-family: 宋体;">　　购物车商品展现页面</span> <span style="font-family: 宋体;">商品规格</span></p>
<p>　　评价系统</p>
<p><span style="font-family: 宋体;">　　订单物流系统</span> &nbsp;<span style="font-family: 宋体;">京东物流</span>/<span style="font-family: 宋体;">调用菜鸟裹裹 调用第三方接口获取数据进行展现</span><span style="font-family: Calibri;">(http)</span></p>
<p><span style="font-family: 宋体;">　　支付系统</span>:<span style="font-family: 宋体;">银行接口</span><span style="font-family: Calibri;">/</span><span style="font-family: 宋体;">第三方支付 </span><span style="font-family: Calibri;">htt</span>p</p>
<p><span style="font-family: 宋体;">　　推荐系统</span>:&hellip;.</p>
<p><span style="font-family: 宋体;">产品经理：</span>3<span style="font-family: 宋体;">人，确定需求以及给出产品原型图</span></p>
<p><span style="font-family: 宋体;">项目经理：</span>1<span style="font-family: 宋体;">人，项目管理。</span></p>
<p><span style="font-family: 宋体;">前端团队：</span>5<span style="font-family: 宋体;">人，根据产品经理给出的原型制作静态页面。</span></p>
<p><span style="font-family: 宋体;">后端团队：</span>20<span style="font-family: 宋体;">人，实现产品功能。</span></p>
<p><span style="font-family: 宋体;">测试团队：</span>5<span style="font-family: 宋体;">人，测试所有的功能。</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">人 </span>&nbsp;3<span style="font-family: 宋体;">人</span> <span style="font-family: 宋体;">脚本</span> shell</p>
<p><span style="font-family: 宋体;">运维团队：</span>3<span style="font-family: 宋体;">人，项目的发布以及维护。</span></p>
<h2><span style="background-color: #90ee90;">1.47&nbsp;<strong><span style="font-family: 宋体;">日活量</span>/<span style="font-family: 宋体;">并发量</span></strong></span></h2>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">日活量:200万
并发量:</span>1500-<span style="color: #000000;">2300左右
单点并发压力 18台tomcat服务器
服务器划分
Mysql                        </span>2<span style="color: #000000;">
Mycat服务器                   </span>1<span style="color: #000000;">
Solr                         </span>3<span style="color: #000000;">
Redis                        </span>3<span style="color: #000000;">
图片服务器                     </span>2<span style="color: #000000;">
Nginx                        </span>2<span style="color: #000000;">
注册中心                      </span>3<span style="color: #000000;">
RabbitMQ                     </span>2<span style="color: #000000;">
18台服务器

Jt</span>-manage                    5<span style="color: #000000;">
Jt</span>-web                       10<span style="color: #000000;">
Jt</span>-sso                       3<span style="color: #000000;">
Jt</span>-cart                      5<span style="color: #000000;">
Jt</span>-order                     5<span style="color: #000000;">
Jt</span>-search                    5<span style="color: #000000;">
33台tomcat</span></code></pre>

<h2><span style="background-color: #90ee90;">1.48&nbsp;<strong>SpringBoot<span style="font-family: 宋体;">全新开发方式特点</span></strong></span></h2>
<p class="19">l&nbsp;<span style="font-family: 宋体;">创建独立的</span>Spring<span style="font-family: 宋体;">应用程序</span></p>
<p class="19">l&nbsp;<span style="font-family: 宋体;">嵌入的</span>Tomcat<span style="font-family: 宋体;">，无需部署</span><span style="font-family: Calibri;">WAR</span><span style="font-family: 宋体;">文件</span></p>
<p class="19">l&nbsp;<span style="font-family: 宋体;">简化</span>Maven<span style="font-family: 宋体;">配置</span></p>
<p class="19">l&nbsp;<span style="font-family: 宋体;">自动配置</span>Spring</p>
<p class="19">l&nbsp;提供生产就绪型功能，如指标，健康检查和外部配置</p>
<h2><span style="background-color: #90ee90;">1.49&nbsp;<strong>什么是微服务架构？</strong></span></h2>
<p>&ldquo;微服务&rdquo;源于<span style="font-family: Calibri;">Martin Fowler</span><span style="font-family: 宋体;">的博文 </span><span style="font-family: Calibri;">Microservices</span><span style="font-family: 宋体;">。</span></p>
<p>Martin<span style="font-family: 宋体;">说：微服务是系统架构上的</span><span style="font-family: 宋体; color: #ff0000;">一种设计风格</span>，它的主旨是将一个原本独立的系统<span style="font-family: 宋体; color: #ff0000;">拆成多个小型服务</span>，这些小型服务都在<span style="font-family: 宋体; color: #ff0000;">各自独立的进程</span>中运行，服务之间通过<span style="color: #ff0000;"><span style="font-family: 宋体;">基于</span>HTTP<span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">RESTful API</span></span>进行通信协作。被拆分成的每一个<span style="font-family: 宋体; color: #ff0000;">小型服务都围绕着系统中的某一项</span>或者<span style="font-family: 宋体; color: #ff0000;">某些耦合度较高的业务</span>功能进行构建，并且每个服务都维护着自身的<span style="font-family: 宋体; color: #ff0000;">数据存储</span>、业务开发、自动化测试案例以及<span style="font-family: 宋体; color: #ff0000;">独立部署机制</span>。由于有了<span style="font-family: 宋体; color: #ff0000;">轻量级的通信协作</span>基础，所以这些微服务可以使用<span style="font-family: 宋体; color: #ff0000;">不同的语言</span>来编写。</p>
<h2><span style="background-color: #ff9900;">1.50&nbsp;<strong>核心功能</strong></span></h2>
<p class="19">l&nbsp;configuration management 配置中心</p>
<p class="19">l&nbsp;service discovery 服务发现</p>
<p class="19">l&nbsp;circuit breakers 断路器</p>
<p class="19">l&nbsp;intelligent routing 智能路由</p>
<p class="19">l&nbsp;micro-proxy 微代理</p>
<p class="19">l&nbsp;control bus 控制总线</p>
<p class="19">l&nbsp;one-time tokens 一次性令牌</p>
<p class="19">l&nbsp;global locks 全局锁</p>
<p class="19">l&nbsp;leadership election 选举算法</p>
<p class="19">l&nbsp;distributed sessions 分布式会话</p>
<p class="19">l&nbsp;cluster state 集群状态</p>
<h2><span style="background-color: #ff9900;">1.51&nbsp;<strong>核心组件架构图</strong></span></h2>
<p>&nbsp;<img src="./images/Java面试题_第四阶段17.png" alt="" /></p>
<h2>1.52&nbsp;<strong><span style="font-family: 宋体;">拓展：</span>CAP<span style="font-family: 宋体;">定理</span></strong></h2>
<p>&nbsp;<img src="./images/Java面试题_第四阶段18.png" alt="" /></p>
<p>CAP<span style="font-family: 宋体;">原则又称</span><span style="font-family: Calibri;">CAP</span><span style="font-family: 宋体;">定理，指的是在一个分布式系统中，</span><span style="font-family: Calibri;">Consistency</span><span style="font-family: 宋体;">（一致性）、 </span><span style="font-family: Calibri;">Availability</span><span style="font-family: 宋体;">（可用性）、</span><span style="font-family: Calibri;">Partition tolerance</span><span style="font-family: 宋体;">（分区容错性），三者不可得兼。它是分布式系统中最核心最重要的理论。</span></p>
<p><span style="font-family: 宋体;">分布式系统的</span>CAP<span style="font-family: 宋体;">理论：理论首先把分布式系统中的三个特性进行了如下归纳：</span></p>
<p class="19">l&nbsp;<span style="color: #ff0000;"><span style="font-family: 宋体;">一致性（</span>C</span><span style="font-family: 宋体;"><span style="color: #ff0000;">）</span>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</span></p>
<p class="19">l&nbsp;<span style="color: #ff0000;"><span style="font-family: 宋体;">可用性（</span>A</span><span style="font-family: 宋体;"><span style="color: #ff0000;">）</span>：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</span></p>
<p class="19">l&nbsp;<span style="color: #ff0000;"><span style="font-family: 宋体;">分区容错性（</span>P</span><span style="font-family: 宋体;"><span style="color: #ff0000;">）</span>：以实际效果而言，</span><span style="font-family: 宋体; color: #ff0000;">分区相当于对通信的时限要求</span><span style="font-family: 宋体;">。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在</span>C<span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">A</span><span style="font-family: 宋体;">之间做出选择。</span></p>
<p>CAP<span style="font-family: 宋体;">理论就是说在分布式系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，</span><span style="color: #ff0000;"><span style="font-family: 宋体;">要么选择</span>CP<span style="font-family: 宋体;">要么选择</span><span style="font-family: Calibri;">AP</span></span>，没有分布式系统能同时保证这三点。</p>
<h2><span style="background-color: #ff9900;">1.53&nbsp;<strong>ZooKeeper<span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">Eureka</span><span style="font-family: 宋体;">对比</span></strong></span></h2>
<p>Eureka<span style="font-family: 宋体;">本身是</span><span style="font-family: Calibri;">Netflix</span><span style="font-family: 宋体;">开源的一款提供服务注册和发现的产品，并且提供了相应的</span><span style="font-family: Calibri;">Java</span><span style="font-family: 宋体;">封装。在它的实现中，节点之间相互平等，部分注册中心的节点挂掉也不会对集群造成影响，</span><span style="font-family: 宋体;"><span style="background-color: #ffff00;">即使集群只剩一个节点存活，也可以正常提供发现服务</span>。</span><span style="font-family: 宋体;">哪怕是所有的服务注册节点都挂了，</span>Eureka Clients<span style="font-family: 宋体;">（客户端）上也会缓存服务调用的信息。这就保证了我们微服务之间的互相调用足够健壮。</span></p>
<p>Zookeeper<span style="font-family: 宋体;">主要为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。曾经是</span><span style="font-family: Calibri;">Hadoop</span><span style="font-family: 宋体;">项目中的一个子项目，用来控制集群中的</span><span style="font-family: 宋体; background-color: #ffff00;">数据</span><span style="font-family: 宋体;">，目前已升级为独立的顶级项目。很多场景下也用它作为</span>Service<span style="font-family: 宋体;">发现服务解决方案。</span></p>
<p><strong>对比</strong></p>
<p><span style="font-family: 宋体;">根据著名的</span>CAP<span style="font-family: 宋体;">定理（</span><span style="font-family: Calibri;">C-</span><span style="font-family: 宋体;">数据一致性；</span><span style="font-family: Calibri;">A-</span><span style="font-family: 宋体;">服务可用性；</span><span style="font-family: Calibri;">P-</span><span style="font-family: 宋体;">服务对网络分区故障的容错性</span><span style="font-family: Calibri;">CAP</span><span style="font-family: 宋体;">这三个特性在任何分布式系统中不能同时满足，最多同时满足两个</span><span style="font-family: Calibri;">CP</span><span style="font-family: 宋体;">或者</span><span style="font-family: Calibri;">AP</span><span style="font-family: 宋体;">）。</span></p>
<p><strong>ZooKeeper</strong></p>
<p>Zookeeper<span style="font-family: 宋体;">是基于</span><span style="font-family: Calibri;">CP</span><span style="font-family: 宋体;">来设计的，即任何时刻对</span><span style="font-family: Calibri;">Zookeeper</span><span style="font-family: 宋体;">的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务请求的可用性。从实际情况来分析，在使用</span><span style="font-family: Calibri;">Zookeeper</span><span style="font-family: 宋体;">获取服务列表时，如果</span><span style="font-family: Calibri;">zookeeper</span><span style="font-family: 宋体;">正在选主，或者</span><span style="font-family: Calibri;">Zookeeper</span><span style="font-family: 宋体;">集群中半数以上机器不可用，那么将无法获得数据。所以说，</span><span style="font-family: Calibri;">Zookeeper</span><span style="font-family: 宋体;">不能保证服务可用性。</span></p>
<p><span style="font-family: 宋体;">诚然，在大多数分布式环境中，尤其是涉及到数据存储的场景，数据一致性应该是首先被保证的，这也是</span>zookeeper<span style="font-family: 宋体;">设计成</span><span style="font-family: Calibri;">CP</span><span style="font-family: 宋体;">的原因。</span><span style="font-family: 宋体; background-color: #ffff00;">但是对于服务发现场景来说，情况就不太一样了</span><span style="font-family: 宋体;">：针对同一个服务，即使注册中心的不同节点保存的服务提供者信息不尽相同，也并不会造成灾难性的后果。因为对于服务消费者来说，能消费才是最重要的</span>&mdash;&mdash;拿到可能不正确的服务实例信息后尝试消费一下，也好过因为无法获取实例信息而不去消费。（尝试一下可以快速失败，之后可以更新配置并重试）所以，对于服务发现而言，可用性比数据一致性更加重要&mdash;&mdash;<span style="font-family: Calibri;">AP</span><span style="font-family: 宋体;">胜过</span><span style="font-family: Calibri;">CP</span><span style="font-family: 宋体;">。</span>&nbsp;</p>
<p><strong>Eureka</strong></p>
<p><span style="font-family: 宋体;">而</span>Spring Cloud Netflix<span style="font-family: 宋体;">在设计</span><span style="font-family: Calibri;">Eureka</span><span style="font-family: 宋体;">时遵守的就是</span><span style="font-family: Calibri;">AP</span><span style="font-family: 宋体;">原则。</span><span style="font-family: Calibri;">Eureka Server</span><span style="font-family: 宋体;">也可以运行多个实例来构建集群，解决单点问题，但不同于</span><span style="font-family: Calibri;">ZooKeeper</span><span style="font-family: 宋体;">的选举</span><span style="font-family: Calibri;">leader</span><span style="font-family: 宋体;">的过程，</span><span style="background-color: #ffff00;">Eureka Server<span style="font-family: 宋体;">采用的是</span><span style="font-family: Calibri;">Peer to Peer</span></span><span style="font-family: 宋体;"><span style="background-color: #ffff00;">对等通信</span>。<span style="background-color: #ffff00;">这是一种去中心化的架构</span></span><span style="font-family: 宋体;">，无</span>master/slave<span style="font-family: 宋体;">区分，每一个</span><span style="font-family: Calibri;">Peer</span><span style="font-family: 宋体;">都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的</span><span style="font-family: Calibri;">serviceUrl</span><span style="font-family: 宋体;">指向其他节点。每个节点都可被视为其他节点的副本。</span></p>
<p><span style="font-family: 宋体;">如果某台</span>Eureka Server<span style="font-family: 宋体;">宕机，</span><span style="font-family: Calibri;">Eureka Client</span><span style="font-family: 宋体;">的请求会自动切换到新的</span><span style="font-family: Calibri;">Eureka Server</span><span style="font-family: 宋体;">节点，当宕机的服务器重新恢复后，</span><span style="font-family: Calibri;">Eureka</span><span style="font-family: 宋体;">会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行</span><span style="font-family: Calibri;">replicateToPeer</span><span style="font-family: 宋体;">（节点间复制）操作，将请求复制到其他</span><span style="font-family: Calibri;">Eureka Server</span><span style="font-family: 宋体;">当前所知的所有节点中。</span></p>
<p><span style="font-family: 宋体;">一个新的</span>Eureka Server<span style="font-family: 宋体;">节点启动后，</span><span style="font-family: 宋体; background-color: #ffff00;">会首先尝试从邻近节点获取所有实例注册表信息</span><span style="font-family: 宋体;">，完成初始化。</span>Eureka Server<span style="font-family: 宋体;">通过</span><span style="font-family: Calibri;">getEurekaServiceUrls()</span><span style="font-family: 宋体;">方法获取所有的节点，并且会</span><span style="font-family: 宋体; background-color: #ffff00;">通过心跳续约的方式定期更新</span><span style="font-family: 宋体;">。默认配置下，如果</span>Eureka Server<span style="font-family: 宋体;">在一定时间内没有接收到某个服务实例的心跳，</span><span style="font-family: Calibri;">Eureka Server</span><span style="font-family: 宋体;">将会注销该实例（默认为</span><span style="font-family: Calibri;">90</span><span style="font-family: 宋体;">秒，通过</span><span style="font-family: Calibri;">eureka.instance.lease-expiration-duration-in-seconds</span><span style="font-family: 宋体;">配置）。</span><span style="background-color: #ffff00;"><span style="font-family: 宋体;">当</span>Eureka Server</span><span style="font-family: 宋体;"><span style="background-color: #ffff00;">节点在短时间内丢失过多的心跳时（比如发生了网络分区故障），那么这个节点就会进入自我保护模式</span>。</span></p>
<p>&nbsp;</p>
<p><strong>总结</strong></p>
<p><span style="color: #ff0000;">ZooKeeper<span style="font-family: 宋体;">基于</span><span style="font-family: Calibri;">CP</span></span><span style="font-family: 宋体;">，不保证高可用，如果</span>zookeeper<span style="font-family: 宋体;">正在选主，或者</span><span style="font-family: Calibri;">Zookeeper</span><span style="font-family: 宋体;">集群中半数以上机器不可用，那么将无法获得数据。</span>Eureka<span style="font-family: 宋体;">基于</span><span style="font-family: Calibri;">AP</span>，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。<span style="font-family: 宋体;"><span style="background-color: #ffff00;">作为注册中心，其实配置是不经常变动的</span>，<span style="background-color: #ffff00;">只有发版（发布新的版本）和机器出故障时会变</span>。</span><span style="font-family: 宋体;">对于不经常变动的配置来说，</span>CP<span style="font-family: 宋体;">是不合适的，而</span><span style="font-family: Calibri;">AP</span><span style="font-family: 宋体;">在遇到问题时可以</span><span style="font-family: 宋体;">用牺牲一致性来保证可用性，既返回旧数据，缓存数据</span>。</p>
<p><span style="font-family: 宋体;">所以理论上</span>Eureka<span style="font-family: 宋体;">是更适合作注册中心。而现实环境中大部分项目可能会使用</span><span style="font-family: Calibri;">ZooKeeper</span><span style="font-family: 宋体;">，那是因为集群不够大，并且基本不会遇到用做注册中心的机器一半以上都挂了的情况。所以实际上也没什么大问题。</span></p>
<h2><span style="background-color: #ff9900;">1.54&nbsp;<strong>拓展：分布式对关系型数据库的冲击</strong></span></h2>
<p><span style="font-family: 宋体;">对于</span>web<span style="font-family: 宋体;">网站来说，关系数据库的很多主要特性却往往无用武之地</span></p>
<p class="19">l&nbsp;<span style="font-family: 宋体;">数据库事务一致性需求</span></p>
<p><span style="font-family: 宋体;">很多</span>web<span style="font-family: 宋体;">实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求并不高。允许实现</span><span style="font-family: 宋体; background-color: #ffff00;">最终一致性</span>。</p>
<p class="19">l&nbsp;数据库的写实时性和读实时性需求</p>
<p><span style="font-family: 宋体;">对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多</span>web<span style="font-family: 宋体;">应用来说，并不要求这么高的实时性，比方说发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。如：</span><span style="font-family: Calibri;">MQ</span><span style="font-family: 宋体;">消息队列机制，意义，可以解决瞬时的高并发，消峰填谷作用。</span></p>
<p class="19">l&nbsp;<span style="font-family: 宋体;">对复杂的</span>SQL<span style="font-family: 宋体;">查询，特别是多表关联查询的需求 </span></p>
<p><span style="font-family: 宋体;">任何大数据量的</span>web<span style="font-family: 宋体;">系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是</span><span style="font-family: Calibri;">SNS</span><span style="font-family: 宋体;">类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，</span><span style="font-family: Calibri;">SQL</span><span style="font-family: 宋体;">的功能被极大的弱化了。</span></p>
<p>SNS<span style="font-family: 宋体;">：全称</span><span style="font-family: Calibri;">Social Networking Services</span><span style="font-family: 宋体;">，专指社交网络服务，包括了社交软件和社交网站。例如：脸谱</span><span style="font-family: Calibri;">facebook</span><span style="font-family: 宋体;">、腾讯</span><span style="font-family: Calibri;">QQ</span><span style="font-family: 宋体;">、微信等。</span></p>
<h2><span style="background-color: #ff9900;">1.55&nbsp;<strong>自我保护模式</strong></span></h2>
<p class="20">&nbsp;<img src="./images/Java面试题_第四阶段19.png" alt="" /></p>
<p><span style="font-family: 宋体;">什么是自我保护模式？默认配置下，如果</span>Eureka Server<span style="font-family: 宋体; background-color: #ffff00;">每分钟收到心跳续约的数量低于一个阈值</span><span style="font-family: 宋体;">（</span>instance<span style="font-family: 宋体;">的数量</span><span style="font-family: Calibri;">(60/</span><span style="font-family: 宋体;">每个</span><span style="font-family: Calibri;">instance</span><span style="font-family: 宋体;">的心跳间隔秒数</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">自我保护系数），并且持续</span><span style="font-family: Calibri;">15</span><span style="font-family: 宋体;">分钟，就会触发自我保护。在自我保护模式中，</span><span style="font-family: Calibri;">Eureka Server</span><span style="font-family: 宋体;">会保护服务注册表中的信息，</span><span style="font-family: 宋体; background-color: #ffff00;">不再注销任何服务实例</span><span style="font-family: 宋体;">。当它收到的心跳数重新恢复到阈值以上时，该</span>Eureka Server<span style="font-family: 宋体;">节点就会自动退出自我保护模式。它的设计哲学前面提到过，那就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。该模式可以通过</span><span style="font-family: Calibri;">eureka.server.enable-self-preservation = false</span><span style="font-family: 宋体;">来禁用，同时</span><span style="font-family: Calibri;">eureka.instance.lease-renewal-interval-in-seconds</span><span style="font-family: 宋体;">可以用来更改心跳间隔。</span></p>
<h2><span style="background-color: #ff9900;">1.56&nbsp;<strong>Ribbon</strong></span></h2>
<p>Feign<span style="font-family: 宋体;">是</span><span style="font-family: Calibri;">netflix</span><span style="font-family: 宋体;">开发的声明式、模板化的</span><span style="font-family: Calibri;">http</span><span style="font-family: 宋体;">客户端，在使用时就像调用本地</span><span style="font-family: Calibri;">(</span><span style="font-family: 宋体;">服务消费者自己</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">的方法一般，帮助我们更加优雅的调用服务提供者的</span><span style="font-family: Calibri;">API</span><span style="font-family: 宋体;">。</span><span style="font-family: Calibri;">Feign</span><span style="font-family: 宋体;">自身支持</span><span style="font-family: Calibri;">springMVC</span><span style="font-family: 宋体;">，还整合了</span><span style="font-family: Calibri;">Eureka</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">Ribbon</span><span style="font-family: 宋体;">，极大的简化了</span><span style="font-family: Calibri;">Feign</span><span style="font-family: 宋体;">的使用。就整合</span><span style="font-family: Calibri;">Euraka</span><span style="font-family: 宋体;">而言，只需和普通的服务配置</span><span style="font-family: Calibri;">Eureka server</span><span style="font-family: 宋体;">的信息即可。整合</span><span style="font-family: Calibri;">Ribbon</span><span style="font-family: 宋体;">，就意味着不再需要通过标注</span><span style="font-family: Calibri;">@LoadBalanced</span><span style="font-family: 宋体;">的实例化后的</span><span style="font-family: Calibri;">RestTemplate</span><span style="font-family: 宋体;">去调用服务提供者方法了。</span><span style="font-family: Calibri;">Feign</span><span style="font-family: 宋体;">只需通过简单的定义一个接口即可实现负载均衡。</span></p>
<p><span style="font-family: 宋体;">和</span>nginx<span style="font-family: 宋体;">不同，它是客户端侧负载均衡。</span></p>
<p class="20">&nbsp;<img src="./images/Java面试题_第四阶段20.png" alt="" /></p>
<h2><span style="background-color: #ff9900;">1.57&nbsp;<strong>负载均衡策略</strong></span></h2>
<p>常见提供的负载均衡算法有三种：</p>
<p class="19">l&nbsp;第一种也是默认为轮询</p>
<p class="19">l&nbsp;<span style="font-family: 宋体;">第二种为</span>random<span style="font-family: 宋体;">随机</span></p>
<p class="19">l&nbsp;第三种为WeightedResponseTimeRule，<span style="font-family: 宋体;">响应时间</span></p>
<h2><span style="background-color: #ff9900;">1.58&nbsp;<strong>Feigh<span style="font-family: 宋体;">概念</span></strong></span></h2>
<p>Feigh<span style="font-family: 宋体;">是一个声明式</span><span style="font-family: Helvetica;">web</span><span style="font-family: 宋体;">服务客户端。它能让开发</span><span style="font-family: Helvetica;">web</span><span style="font-family: 宋体;">服务变得容易。使用</span><span style="font-family: Helvetica;">Feign</span><span style="font-family: 宋体;">需要创建一个接口并注解它。它拥有包括</span><span style="font-family: Helvetica;">Feign</span><span style="font-family: 宋体;">注解和</span><span style="font-family: Helvetica;">JAX-RS</span><span style="font-family: 宋体;">注解的可插拔支持。它还支持可插拔的编码器和解码器。</span><span style="font-family: Helvetica;">Spring Cloud</span><span style="font-family: 宋体;">拥有</span><span style="font-family: Helvetica;">Spring MVC</span><span style="font-family: 宋体;">支持，并使用</span><span style="font-family: Helvetica;">Spring Web</span><span style="font-family: 宋体;">中默认同样的</span><span style="font-family: Helvetica;">HttpMessageConverters</span><span style="font-family: 宋体;">。在使用</span><span style="font-family: Helvetica;">Feign</span><span style="font-family: 宋体;">时，</span><span style="font-family: Helvetica;">Spring Cloud</span><span style="font-family: 宋体;">集成了</span><span style="font-family: Helvetica;">Ribbon</span><span style="font-family: 宋体;">和</span><span style="font-family: Helvetica;">Eureka</span><span style="font-family: 宋体;">来提供负载均衡的</span><span style="font-family: Helvetica;">HTTP</span><span style="font-family: 宋体;">客户端。</span></p>
<p><span style="font-family: 宋体;">总结：</span>Feign<span style="font-family: 宋体;">简化</span>HttpClient<span style="font-family: 宋体;">开发，封装了</span><span style="font-family: Calibri;">JAX-RS</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">SprinMVC</span><span style="font-family: 宋体;">的注解，学习成本很低。</span></p>
<h2><span style="background-color: #ff9900;">1.59&nbsp;<strong>微服务设计引发新的问题</strong></span></h2>
<p>微服务的设计，服务分散在多个服务器上，服务之间互相调用，要调用的服务由于跨网络跨服务器调用，响应速度明显比传统项目单机调用慢很多，甚至由于网络涌动的不稳定的现象发生导致调用超时；还有类似级联失败、雪崩效应（依赖的基础服务宕机，关联的服务导致失败甚至宕机，就像滚雪球一样层层失败。）</p>
<p>如何解决这类新的问题呢？传统的机制就是超时机制。</p>
<h2><span style="background-color: #ff9900;">1.60&nbsp;<strong>熔断机制</strong></span></h2>
<p>家里电表都有个断路器（俗称电闸），当使用的电器很多，用电巨大（例如功率过大、短路等），当电流过载时，电路就会升温，甚至烧断电路，引起火灾。有了这个断路器，我们及时拉闸，就不会造成严重后果了。</p>
<p><span style="font-family: 宋体; background-color: #ffff00;">断路器可以实现快速失败</span><span style="font-family: 宋体;">，如果它在一段时间内检测到许多失败，如超时，就会强迫其以后的多个调用快速失败，不再请求所依赖的服务，从而防止应用程序不断地尝试执行可能会失败的操作，这样应用程序可以继续执行而不用等待修正错误，或者浪费</span>CPU<span style="font-family: 宋体;">时间去等待长时间的超时。</span><span style="font-family: 宋体; background-color: #ffff00;">断路器也可以使应用程序能够诊断错误是否已经修正</span>，如果已经修正，应用程序会再次尝试调用操作。</p>
<p>断路器模式像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">ending...</span></p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>