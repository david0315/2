<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java中的容器（集合）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java中的容器（集合）</center></div><div class='banquan'>原文出处:本文由博客园博主喜欢听风提供。<br/>
原文连接:https://www.cnblogs.com/xihuantingfeng/p/11616389.html</div><br>
    <h3><span style="font-family: 楷体; font-size: 18px;">1、Java常用容器：List，Set，Map</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>List：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">继承了Collection接口（public interface List&lt;E&gt; extends Collection&lt;E&gt;&nbsp;），有序且允许出现重复值。</span></li>
</ul>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>Set：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">继承了Collection接口（public interface Set&lt;E&gt; extends Collection&lt;E&gt;&nbsp;），无序且不允许出现重复值。</span></li>
</ul>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>Map：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">是一个使用键值对存储的容器（public interface Map&lt;K,V&gt;&nbsp;）。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">2、Collection 和&nbsp;Collections 的区别</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>Collection：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">Collection是一个集合类的通用接口（源码：public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;）。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">通过查看源码可以发现，其中包含的都是一些通用的集合操作接口，他的直接继承接口有List和Set。</span></li>
</ul>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>Collections：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">Collections是一个集合工具类（源码：public class Collections）。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">其中提供一系列对集合操作的静态方法，比如排序：sort()，集合安全：synchronizedCollection()，反转：reverse()等等。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">3、ArrayList 和&nbsp;LinkedList 的区别</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>ArrayList：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">底层数据结构是一个数组，查询效率比较高，添加删除较慢（默认添加在末尾，在指定位置添加元素效率比较低，因为需要将指定位置后续的元素都往后移位）。</span></li>
</ul>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>LinkedList：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">底层数据结构是一个双向链表（prev指向前节点，next指向后节点），查询效率比较慢，添加删除比较快。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">4、ArrayList 和&nbsp;Vector 的区别</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>ArrayList：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">非线程安全，读取效率较高。</span></li>
</ul>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>Vector：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">线程安全（源码中显示该类的方法使用了synchronized），读取效率较低（推荐使用CopyOnWriteArrayList,该类适合读多写少的场景）。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">5、HashMap 和&nbsp;Hashtable 的区别</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>HashMap：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">非线程安全，允许空键值，执行效率相对较高（底层使用的数据结构是数组+链表+红黑树（jdk8）或者数组+链表（jdk7））。</span></li>
</ul>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>Hashtable：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">线程安全，不允许空键值，执行效率相对较低（推荐使用ConcurrentHashMap）。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">6、HashMap 和&nbsp;TreeMap 的使用场景</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>HashMap：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">一般情况下进行插入，删除，定位元素的话，使用HashMap（常用）。</span></li>
</ul>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>TreeMap：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">如果需要使用有序的集合，推荐用TreeMap。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">7、HashMap 实现原理</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>以put操作为例：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">首先会根据key的hashCode得到hash值（部分源码：return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)），依据hash值得到该元素在数组的位置（下标），如果该位置不存在元素，则将该元素直接放入此位置上；否则判断元素是否相等，如果是，则覆盖，否则使用拉链法解决冲突（创建一个链表，先加入的放到链头，后加入的放在链尾（JDK8，JDK7插入是插到了链头），超过8位时，使用红黑树存储）。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">放入的元素是包含了键值对的元素，而非仅仅只有值。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">8、HashSet 实现原理</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>以add操作为例：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">进入add源码（return map.put(e, PRESENT)==null），可以看到其底层是用map来实现的，只是传入的值当做了map的key，而map的value使用的是统一的PRESENT。</span></li>
</ul>
<h3><span style="font-family: 楷体; font-size: 18px;">9、迭代器：Iterator</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>Iterator：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">是一个轻量级的对象（创建代价小），主要用来对集合进行遍历移除等操作。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">示例代码如下</span></li>
</ul>
<src class="cnblogs_code" onclick="cnblogs_code_show('871b75c7-fae6-4334-b0ee-9ea5e8bd6f38')"><img id="code_img_closed_871b75c7-fae6-4334-b0ee-9ea5e8bd6f38" class="code_img_closed" src="./images/Java中的容器（集合）0.png" alt="" /><img id="code_img_opened_871b75c7-fae6-4334-b0ee-9ea5e8bd6f38" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('871b75c7-fae6-4334-b0ee-9ea5e8bd6f38',event)" src="./images/Java中的容器（集合）1.png" alt="" />
<src id="cnblogs_code_open_871b75c7-fae6-4334-b0ee-9ea5e8bd6f38" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.spring.test.service.demo;

</span><span style="color: #0000ff;">import</span> java.util.*<span style="color: #000000;">;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @Author: philosopherZB
 * @Date: 2019/10/1
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        List</span>&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;(5<span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;5;i++<span style="color: #000000;">){
            list.add(</span>"Test" +<span style="color: #000000;"> i);
            System.out.println(</span>"输入：Test" +<span style="color: #000000;"> i);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">利用iterator()返回一个Iterator对象</span>
        Iterator&lt;String&gt; it =<span style="color: #000000;"> list.iterator();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">判断是否还存在元素</span>
        <span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">第一次调用next()会返回集合中的第一个元素，之后返回下一个</span>
            String s =<span style="color: #000000;"> it.next();
            </span><span style="color: #0000ff;">if</span>("Test3"<span style="color: #000000;">.equals(s))
                </span><span style="color: #008000;">//</span><span style="color: #008000;">移除某个元素</span>
<span style="color: #000000;">                it.remove();
        }
        list.forEach(l</span>-&gt;<span style="color: #000000;">{
            System.out.println(l);
        });
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<h3><span style="font-family: 楷体; font-size: 18px;">10、ArrayList 扩容源码解析（JDK8）</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>源码解析：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">首先我们使用&nbsp;ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(5)创建一个A</span><span style="font-family: 楷体; font-size: 16px;">rrayLsit，这表明创建的ArrayList初始容量为5.</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">源码如下：</span></li>
</ul>
<src class="cnblogs_code">
<pre><code>    <span style="color: #008000;">//</span><span style="color: #008000;">默认初始容量10</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> DEFAULT_CAPACITY = 10<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">一个空的默认对象数组，当ArrayList(int initialCapacity)，ArrayList(Collection&lt;? extends E&gt; c)中的容量等于0的时候使用</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> Object[] EMPTY_ELEMENTDATA =<span style="color: #000000;"> {};
    </span><span style="color: #008000;">//</span><span style="color: #008000;">一个空的默认对象数组，用于ArrayList()构造器</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA =<span style="color: #000000;"> {};
    </span><span style="color: #008000;">//</span><span style="color: #008000;">一个对象数组，transient表示不能序列化</span>
    <span style="color: #0000ff;">transient</span><span style="color: #000000;"> Object[] elementData;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">数组大小</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> size;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">以传入的容量构造一个空的list</span>
    <span style="color: #0000ff;">public</span> ArrayList(<span style="color: #0000ff;">int</span><span style="color: #000000;"> initialCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果传入值大于0，则创建一个该容量大小的数组。</span>
        <span style="color: #0000ff;">if</span> (initialCapacity &gt; 0<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">this</span>.elementData = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object[initialCapacity];
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (initialCapacity == 0<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">否则如果传入值等于0，则创建默认空数组</span>
            <span style="color: #0000ff;">this</span>.elementData =<span style="color: #000000;"> EMPTY_ELEMENTDATA;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">如果小于0则抛出异常</span>
            <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("Illegal Capacity: "+<span style="color: #000000;">
                    initialCapacity);
        }
    }</span></code></pre>

<ul>
<li><span style="font-family: 楷体; font-size: 16px;">接着我们使用add方法添加一个字符串到该list中，list.add("Test")。进入add源码会发现，真正的扩容是发生在add操作之前的。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">源码如下：</span></li>
</ul>
<src class="cnblogs_code">
<pre><code>    <span style="color: #008000;">//</span><span style="color: #008000;">默认添加在数组末尾</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(E e) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">添加之前先确认是否需要扩容</span>
        ensureCapacityInternal(size + 1);  <span style="color: #008000;">//</span><span style="color: #008000;"> Increments modCount!!
        </span><span style="color: #008000;">//</span><span style="color: #008000;">新加入的元素是添加在了数组的末尾，随后数组size自增。</span>
        elementData[size++] =<span style="color: #000000;"> e;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }</span></code></pre>

<ul>
<li><span style="font-family: 楷体; font-size: 16px;">进入ensureCapacityInternal()方法查看对应源码如下：</span></li>
</ul>
<src class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> ensureCapacityInternal(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">先通过calculateCapacity方法计算最终容量，以确认实际容量</span>
<span style="color: #000000;">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }</span></code></pre>

<ul>
<li><span style="font-family: 楷体; font-size: 16px;">到这一步，我们需要先进入calculateCapacity()方法看看他是如何计算最后容量的，源码如下：</span></li>
</ul>
<src class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> calculateCapacity(Object[] elementData, <span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果elementData为默认空数组，则比较传入值与默认值（10），返回两者中的较大值
        </span><span style="color: #008000;">//</span><span style="color: #008000;">elementData为默认空数组指的是通过ArrayList()这个构造器创建的ArrayList对象</span>
        <span style="color: #0000ff;">if</span> (elementData ==<span style="color: #000000;"> DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">返回传入值</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> minCapacity;
    }</span></code></pre>

<ul>
<li><span style="font-family: 楷体; font-size: 16px;">现在我们确认了最终容量，那么进入ensureExplicitCapacity，查看源码如下：</span></li>
</ul>
<src class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> ensureExplicitCapacity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        modCount</span>++<span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> overflow-conscious code
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果最终确认容量大于数组容量，则进行grow()扩容</span>
        <span style="color: #0000ff;">if</span> (minCapacity - elementData.length &gt; 0<span style="color: #000000;">)
            grow(minCapacity);
    }</span></code></pre>

<ul>
<li><span style="font-family: 楷体; font-size: 16px;">可以看到，只有当最终容量大于数组容量时才会进行扩容。那么以我们上面的例子而言具体分析如下：</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">首先因为我们创建的时候就赋了初始容量5，所以elementData.length = 5。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">当我们add第一个元素的时候，minCapacity是等于size + 1 = 1的。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">此时minCapacity - elementData.length &gt; 0条件不成立，所以不会进入grow(minCapacity)方法进行扩容。</span></li>
<li><span style="font-family: 楷体; font-size: 16px;">以此类推，只有添加到第五个元素的时候，minCapacity = 6 大于 elementData.length = 5，这时就会进入grow(minCapacity)方法进行扩容。<br /></span></li>
<li><span style="font-family: 楷体; font-size: 16px;">grow()以及hugeCapacity()源码如下：</span></li>




</ul>
<src class="cnblogs_code">
<pre><code>    <span style="color: #008000;">//</span><span style="color: #008000;">可分配的最大数组大小</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8<span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">扩容</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> grow(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> overflow-conscious code
        </span><span style="color: #008000;">//</span><span style="color: #008000;">oldCapacity表示旧容量</span>
        <span style="color: #0000ff;">int</span> oldCapacity =<span style="color: #000000;"> elementData.length;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">newCapacity表示新容量，计算规则为旧容量+旧容量的0.5，即旧容量的1.5倍。如果超过int的最大值会返回一个负数。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">oldCapacity &gt;&gt; 1表示右移一位，对应除以2的1次方。</span>
        <span style="color: #0000ff;">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果新容量小于最小容量，则将最小容量赋值给新容量(有时手动扩容可能也会返回&lt;0，对应方法为ensureCapacity())</span>
        <span style="color: #0000ff;">if</span> (newCapacity - minCapacity &lt; 0<span style="color: #000000;">)
            newCapacity </span>=<span style="color: #000000;"> minCapacity;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果新容量大于MAX_ARRAY_SIZE，则执行hugeCapacity(minCapacity)返回对应值</span>
        <span style="color: #0000ff;">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0<span style="color: #000000;">)
            newCapacity </span>=<span style="color: #000000;"> hugeCapacity(minCapacity);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> minCapacity is usually close to size, so this is a win:
        </span><span style="color: #008000;">//</span><span style="color: #008000;">复制旧数组到新容量数组中，完成扩容操作</span>
        elementData =<span style="color: #000000;"> Arrays.copyOf(elementData, newCapacity);
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> hugeCapacity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果最小容量超过了int的最大值，minCapacity会是一个负数，此时抛出内存溢出错误</span>
        <span style="color: #0000ff;">if</span> (minCapacity &lt; 0) <span style="color: #008000;">//</span><span style="color: #008000;"> overflow</span>
            <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> OutOfMemoryError();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">比较最小容量是否大于MAX_ARRAY_SIZE，如果是则返回Integer.MAX_VALUE，否则返回MAX_ARRAY_SIZE</span>
        <span style="color: #0000ff;">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<span style="color: #000000;">
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
    }</span></code></pre>

<p><span style="font-family: 楷体; font-size: 16px;">&nbsp;（以上所有内容皆为个人笔记，如有错误之处还望指正。）</span></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>