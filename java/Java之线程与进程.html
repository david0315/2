<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java之线程与进程' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java之线程与进程</center></div><div class='banquan'>原文出处:本文由博客园博主MrHH提供。<br/>
原文连接:https://www.cnblogs.com/HuiH/p/11844317.html</div><br>
    <p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">一、线程与进程</span></strong></span></p>
<p><span style="font-size: 16px;">　　线程：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别形式，但多线程使用了更小的资源开销。</span></p>
<p><span style="font-size: 16px;">　　进程：一个进程包括有操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在。它必须是进程的一部分。一个进程一直运行直到所有的非守护线程都结束运行后才能结束。</span></p>
<table style="height: 356px; width: 1096px;" border="0" align="left">
<tbody>
<tr>
<td>&nbsp;</td>
<td><strong><span style="font-size: 15px; color: #0000ff;">进程</span></strong></td>
<td><strong><span style="font-size: 15px; color: #0000ff;">线程</span></strong></td>
</tr>
<tr>
<td><strong><span style="font-size: 15px; color: #0000ff;">定义</span></strong></td>
<td>
<p><span style="font-size: 15px;">进程是指处于运行中的程序，并且具有一定的独立功能。<strong>进程是系统进行资源分配和调度的一个单位。</strong></span></p>
<p><span style="font-size: 15px;">当程序</span><span style="font-size: 15px;">进入内存时，即为进程。</span></p>
</td>
<td>
<p><span style="font-size: 15px;">线程是进程的组成部分，一个进程可以拥有多个线程，而一个线程必须拥有一个父进程。</span></p>
<p><span style="font-size: 15px;">线程可以拥有自己的堆栈，自己的程序计数器和局部变量，但不能拥有系统资源。</span></p>
<p><span style="font-size: 15px;">它与父进程的其他线程共享该进城的所有资源。</span></p>
</td>
</tr>
<tr>
<td><strong><span style="font-size: 15px; color: #0000ff;">特点</span></strong></td>
<td>
<p><span style="font-size: 15px;">1）独立性：进程是系统中独立存在的实体，它可以独立拥有资源，每一个进程都有自己独立的地址空间，</span></p>
<p><span style="font-size: 15px;">没有进程本身的运行，用户进程不可以直接访问其他进程的地址空间。</span></p>
<p><span style="font-size: 15px;">2）动态性：进程和程序的区别在于进程是动态的，进程中有时间的概念，进程具有自己的生命周期和各种</span></p>
<p><span style="font-size: 15px;">不同的状态。</span></p>
<p><span style="font-size: 15px;">3）并发性：多个进程可以在单个处理器上并发执行，互不影响。</span></p>
</td>
<td>
<p><span style="font-size: 15px;">1）线程可以完成一定任务，可以和其他线程共享父进程的共享变量和部分环境，相互协作来完成任务。</span></p>
<p><span style="font-size: 15px;">2）线程是独立运行的，其不知道进程中是否还有其他线程存在。</span></p>
<p><span style="font-size: 15px;">3）线程的执行是抢占式的，也就是说，当前执行的线程随时可能被挂起，一边运行另一个线程。</span></p>
<p><span style="font-size: 15px;">4）一个线程可以创建或撤销另一个线程，一个进程中的多个线程可以并发执行。</span></p>
</td>
</tr>
</tbody>
</table>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">二、线程的生命周期</span></strong></span></p>
<p><span style="font-size: 16px;"><br />　　<img src="./images/Java之线程与进程0.png" alt="" width="419" height="326" /><br /></span></p>
<p><span style="color: #0000ff;"><strong><span style="font-size: 16px;">新建状态（New）</span></strong></span></p>
<p><span style="font-size: 16px;">　　使用new关键字和Thread类或七子类建立一个线程对象后，该线程对象就处于新建状态。此时仅由JVM为其分配内存，并初始化其成员变量的值。它保持这个状态知道程序start()这个线程。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">就绪状态（runnable）</span></strong></p>
<p><span style="font-size: 16px;">　　当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，Java虚拟机会为其创建方法调用栈和程序计数器，等待JVM里线程调度器的调度。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">运行状态（running）</span></strong></p>
<p><span style="font-size: 16px;">　　如果就绪状态的线程获取CPU资源，就可以执行run方法，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">阻塞状态（blocked）</span></strong></p>
<p><span style="font-size: 16px;">　　线程因为某种原因放弃了CPU使用权，暂时停止运行。直到线程进入可运行状态，才有机会再次获得CPU timeslice 转到运行状态。</span></p>
<p><span style="font-size: 16px;">　　如果一个线程执行了sleep（睡眠），suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</span></p>
<p><span style="font-size: 16px;">　　1）等待阻塞：运行状态中的线程执行wait方法，使线程进入到等待阻塞状态；</span></p>
<p><span style="font-size: 16px;">　　2）同步阻塞：线程在获取synchronized同步锁失败（因为同步锁被其他线程占用）；</span></p>
<p><span style="font-size: 16px;">　　3）其他阻塞：通过调用线程的sleep()或join()发出了IO请求时，线程就会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或IO请求处理完毕，线程重新转入就绪状态。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">死亡状态（dead）</span></strong></p>
<p><span style="font-size: 16px;">　　一个运行状态的线程完成任务或其他终止条件发生时，该线程就切换到终止状态。</span></p>
<p><span style="font-size: 16px;">　　正常结束：run()或call()方法执行完成，线程正常结束。</span></p>
<p><span style="font-size: 16px;">　　异常结束：线程抛出一个未捕获的Exception或Error。</span></p>
<p><span style="font-size: 16px;">　　调用stop：直接调用该线程的stop()方法结束该线程（该方法容易导致死锁，不推荐使用）。</span></p>
<p><span style="font-size: 16px;">　为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或线程死亡了，则返回false。</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">三、线程优先级</span></strong></span></p>
<p><span style="font-size: 16px;">　　每个线程都有一个优先级，方便操作系统确定线程的调度顺序。Java线程的优先级是一个整数，其取值范围是1（Thread.MIN_PRIORITY）-10（Thread.MAX_PRIORITY）。</span></p>
<p><span style="font-size: 16px;">　　默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。具有较高优先级的线程在低优先级的线程之前分配处理器资源。但线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">四、创建线程的方式</span></strong></span></p>
<p><span style="font-size: 16px;"><span style="color: #0000ff;"><strong>1）继承Thread类：</strong></span>Thread类本质上是实现了Runnable接口的一个实例。启动线程的方法就是通过Thread类的start()方法。他是一个native方法，它将启动一个新线程，并执行其中的run()方法。</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread { 
</span><span style="color: #008080;">2</span>      <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() { 
</span><span style="color: #008080;">3</span>  System.out.println("MyThread.run()"<span style="color: #000000;">); 
</span><span style="color: #008080;">4</span> <span style="color: #000000;"> } 
</span><span style="color: #008080;">5</span> <span style="color: #000000;">} 
</span><span style="color: #008080;">6</span> MyThread myThread1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyThread(); 
</span><span style="color: #008080;">7</span> myThread1.start();</span> </code></pre>

<p><span style="color: #0000ff;"><strong><span style="font-size: 16px;">2）实现Runnable接口</span></strong></span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">extends</span> OtherClass <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable { 
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() { 
</span><span style="color: #008080;"> 3</span>      System.out.println("MyThread.run()"<span style="color: #000000;">); 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">     } 
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">} 
</span><span style="color: #008080;"> 6</span> <span style="color: #008000;">//</span><span style="color: #008000;">启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：</span>
<span style="color: #008080;"> 7</span> MyThread myThread = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyThread(); 
</span><span style="color: #008080;"> 8</span> Thread thread = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(myThread); 
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">thread.start(); 
</span><span style="color: #008080;">10</span> target.run();    <span style="color: #008000;">//</span><span style="color: #008000;">当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用</span>
<span style="color: #008080;">11</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() { 
</span><span style="color: #008080;">12</span>      <span style="color: #0000ff;">if</span> (target != <span style="color: #0000ff;">null</span><span style="color: #000000;">) { 
</span><span style="color: #008080;">13</span> <span style="color: #000000;">         target.run(); 
</span><span style="color: #008080;">14</span> <span style="color: #000000;">     } 
</span><span style="color: #008080;">15</span> }</span> </code></pre>

<p><span style="color: #0000ff;"><strong><span style="font-size: 16px;">3）通过Callable和Future创建线程</span></strong></span></p>
<p><span style="font-size: 16px;">　　i. 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</span></p>
<p><span style="font-size: 16px;">　　ii. 创建Callable实现类的实例，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值。</span></p>
<p><span style="font-size: 16px;">　　iii. 使用FutureTask对象作为Thread对象的target创建并启动新线程。</span></p>
<p><span style="font-size: 16px;">　　iv. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">创建一个线程池</span>
<span style="color: #008080;"> 2</span> ExecutorService pool =<span style="color: #000000;"> Executors.newFixedThreadPool(taskSize);
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 创建多个有返回值的任务</span>
<span style="color: #008080;"> 4</span> List&lt;Future&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;Future&gt;<span style="color: #000000;">(); 
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; taskSize; i++<span style="color: #000000;">) { 
</span><span style="color: #008080;"> 6</span>     Callable c = <span style="color: #0000ff;">new</span> MyCallable(i + " "<span style="color: #000000;">); 
</span><span style="color: #008080;"> 7</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 执行任务并获取 Future 对象</span>
<span style="color: #008080;"> 8</span>     Future f =<span style="color: #000000;"> pool.submit(c); 
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">    list.add(f); 
</span><span style="color: #008080;">10</span> <span style="color: #000000;">} 
</span><span style="color: #008080;">11</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 关闭线程池</span>
<span style="color: #008080;">12</span> <span style="color: #000000;">pool.shutdown(); 
</span><span style="color: #008080;">13</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 获取所有并发任务的运行结果</span>
<span style="color: #008080;">14</span> <span style="color: #0000ff;">for</span><span style="color: #000000;"> (Future f : list) { 
</span><span style="color: #008080;">15</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 从 Future 对象上获取任务的返回值，并输出到控制台</span>
<span style="color: #008080;">16</span>     System.out.println("res：" +<span style="color: #000000;"> f.get().toString()); 
</span><span style="color: #008080;">17</span> }</span> </code></pre>

<p><strong><span style="font-size: 16px; color: #0000ff;">4）基于线程池的方式</span></strong></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;"> 1</span>  ExecutorService threadPool = Executors.newFixedThreadPool(10);    <span style="color: #008000;">//</span><span style="color: #008000;"> 创建线程池</span>
<span style="color: #008080;"> 2</span>  <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
</span><span style="color: #008080;"> 3</span>      threadPool.execute(<span style="color: #0000ff;">new</span> Runnable() { <span style="color: #008000;">//</span><span style="color: #008000;"> 提交多个线程任务，并执行</span>
<span style="color: #008080;"> 4</span>          <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;"> 5</span>          　　System.out.println(Thread.currentThread().getName() + " is running .."<span style="color: #000000;">);
</span><span style="color: #008080;"> 6</span>          　　<span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;"> 7</span>              　　Thread.sleep(3000<span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>          　　} <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">             　　e.printStackTrace();
</span><span style="color: #008080;">10</span> <span style="color: #000000;">         　　} 
</span><span style="color: #008080;">11</span> <span style="color: #000000;">         }  
</span><span style="color: #008080;">12</span> <span style="color: #000000;">     });  
</span><span style="color: #008080;">13</span> <span style="color: #000000;"> }  </span></span></code></pre>

<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">五、终止线程的方式</span></strong></span></p>
<p><span style="font-size: 16px;"><span style="color: #0000ff;"><strong>1.正常运行结束</strong></span>：程序运行结束，线程自动结束。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">2.使用退出标志退出线程</span></strong></p>
<p><span style="font-size: 16px;">　　一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出，代码示例：</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ThreadSafe <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread {
</span><span style="color: #008080;">2</span>  <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">boolean</span> exit = <span style="color: #0000ff;">false</span><span style="color: #000000;">; 
</span><span style="color: #008080;">3</span>      <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() { 
</span><span style="color: #008080;">4</span>          <span style="color: #0000ff;">while</span> (!<span style="color: #000000;">exit){
</span><span style="color: #008080;">5</span>              <span style="color: #008000;">//</span><span style="color: #008000;">do something</span>
<span style="color: #008080;">6</span> <span style="color: #000000;"> }
</span><span style="color: #008080;">7</span> <span style="color: #000000;">     } 
</span><span style="color: #008080;">8</span> }</span></code></pre>

<p><span style="font-size: 16px;">　　定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false。在定义exit时，使用了一个Java关键字volatile，这个关键字的目的是使exit同步，也就是说在同一时刻只能由一个线程来修改exit值。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">3.Interrupt方法结束线程</span></strong></p>
<p><span style="font-size: 16px;">　使用interrupt()方法来中断线程有两种情况：</span></p>
<p><span style="font-size: 16px;">　　1）线程处于阻塞状态：如使用了sleep，同步锁的wait、socket中的receiver、accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的，<strong>一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法。</strong></span></p>
<p><span style="font-size: 16px;">　　2）线程未处于阻塞状态：使用isInterrupted()方法判断线程的中断标志来退出循环。当使用interrupt方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;"> 1</span>  <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ThreadSafe <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread {
</span><span style="color: #008080;"> 2</span>      <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() { 
</span><span style="color: #008080;"> 3</span>  　　　　<span style="color: #0000ff;">while</span> (!isInterrupted()){ <span style="color: #008000;">//</span><span style="color: #008000;">非阻塞过程中通过判断中断标志来退出</span>
<span style="color: #008080;"> 4</span>      　　<span style="color: #0000ff;">try</span><span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>              Thread.sleep(5*1000);<span style="color: #008000;">//</span><span style="color: #008000;">阻塞过程捕获中断异常来退出</span>
<span style="color: #008080;"> 6</span>             }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">                e.printStackTrace();
</span><span style="color: #008080;"> 8</span>       　　　　　　<span style="color: #0000ff;">break</span>;<span style="color: #008000;">//</span><span style="color: #008000;">捕获到异常之后，执行 break 跳出循环</span>
<span style="color: #008080;"> 9</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">10</span> <span style="color: #000000;">         }
</span><span style="color: #008080;">11</span> <span style="color: #000000;">     } 
</span><span style="color: #008080;">12</span>   }</span></code></pre>

<p><span style="color: #0000ff;"><strong><span style="font-size: 16px;">4.Stop方法终止线程（线程不安全）</span></strong></span></p>
<p><span style="font-size: 16px;">　　程序中可以直接使用thread.stop()来强行终止线程，但是stop方法很危险，就像突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：</span></p>
<p><span style="font-size: 16px;">　　　　thread.stop()调用后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁被突然释放（不可控制），那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop方法来终止线程。</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">六、线程同步的方式</span></strong></span></p>
<p><span style="font-size: 16px;">　<strong>　临界区</strong>：通过对多线程的串行化来访问公共资源或一段代码，速度快，适应控制数据访问。</span></p>
<p><span style="font-size: 16px;">　　<strong>互斥量</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会同时被多个线程访问。</span></p>
<p><span style="font-size: 16px;">　　<strong>信号量</strong>：它允许多个线程统一时刻访问同一资源，但是需要限制同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中PV操作相似。</span></p>
<p><span style="font-size: 16px;">　　<strong>事件（信号）</strong>：通过通知操作的方式来保持对线程的同步，还可以方便的实现多线程的优先级比较的操作。</span></p>
<p><strong><span style="font-size: 16px; color: #ff0000;">七、进程同步与互斥的区别</span></strong></p>
<p><span style="font-size: 16px;">　　互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</span></p>
<p><span style="font-size: 16px;">　　同步：是指在互斥的基础上（大多数情况），通过其他机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</span></p>
<p><span style="font-size: 16px;">　　同步体现的是一种协作性，护持体现的是一种排他性。</span></p>
<p><strong><span style="font-size: 16px; color: #ff0000;">八、Java后台线程</span></strong></p>
<p><span style="font-size: 16px;">　<span style="color: #0000ff;"><strong>守护线程（Daemon）</strong></span>：也称服务线程，是后台线程。<span style="color: #0000ff;">为用户线程提供公共服务，在没有用户线程可服务是会自动离开。</span></span></p>
<p><span style="font-size: 16px;">　　1.优先级较低，用于为系统中的其他对象和线程提供服务。</span></p>
<p><span style="font-size: 16px;">　　2.设置：通过setDaemon(true)来设置线程为&ldquo;守护线程&rdquo;。</span></p>
<p><span style="font-size: 16px;">　　3.垃圾回收线程就是守护线程，它始终在低级别的状态运行，用于监视和管理系统中的可回收资源。</span></p>
<p><span style="font-size: 16px;">　　4.生命周期：守护线程不依赖于终端但依赖于系统，与系统&ldquo;同生共死&rdquo;。</span></p>
<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">九、如何在两个线程之间共享数据？</span></strong></span></p>
<p><span style="font-size: 16px;">　　Java里面进行多线程痛心的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性。Java内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到&ldquo;同步&rdquo;和&ldquo;互斥&rdquo;。有以下常规实现方法：</span></p>
<p><span style="font-size: 16px;">　<span style="color: #0000ff;">　1.将数据抽象成一个类，并将数据的操作作为这个类的方法，这么设计可以很容易做到同步，只要在方法上加&ldquo;synchronized&rdquo;</span></span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyData {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> j=0<span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> add(){
</span><span style="color: #008080;"> 4</span>         j++<span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span>         System.out.println("线程"+Thread.currentThread().getName()+"j 为："+<span style="color: #000000;">j);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> dec(){
</span><span style="color: #008080;"> 8</span>         j--<span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span>         System.out.println("线程"+Thread.currentThread().getName()+"j 为："+<span style="color: #000000;">j);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getData(){
</span><span style="color: #008080;">12</span>      <span style="color: #0000ff;">return</span><span style="color: #000000;"> j;
</span><span style="color: #008080;">13</span> <span style="color: #000000;">     }
</span><span style="color: #008080;">14</span> <span style="color: #000000;">}
</span><span style="color: #008080;">15</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> AddRunnable <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{
</span><span style="color: #008080;">16</span> <span style="color: #000000;">    MyData data;
</span><span style="color: #008080;">17</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> AddRunnable(MyData data){
</span><span style="color: #008080;">18</span>         <span style="color: #0000ff;">this</span>.data=<span style="color: #000000;"> data;
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">20</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">21</span> <span style="color: #000000;">        data.add();
</span><span style="color: #008080;">22</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">23</span> <span style="color: #000000;">}
</span><span style="color: #008080;">24</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> DecRunnable <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable {
</span><span style="color: #008080;">25</span> <span style="color: #000000;">    MyData data;
</span><span style="color: #008080;">26</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> DecRunnable(MyData data){
</span><span style="color: #008080;">27</span>         <span style="color: #0000ff;">this</span>.data =<span style="color: #000000;"> data;
</span><span style="color: #008080;">28</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">29</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">30</span> <span style="color: #000000;">        data.dec();
</span><span style="color: #008080;">31</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">32</span> <span style="color: #000000;">}
</span><span style="color: #008080;">33</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;">34</span>     MyData data = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyData();
</span><span style="color: #008080;">35</span>     Runnable add = <span style="color: #0000ff;">new</span><span style="color: #000000;"> AddRunnable(data);
</span><span style="color: #008080;">36</span>     Runnable dec = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DecRunnable(data);
</span><span style="color: #008080;">37</span>     <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;2;i++<span style="color: #000000;">){
</span><span style="color: #008080;">38</span>         <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(add).start();
</span><span style="color: #008080;">39</span>         <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(dec).start();
</span><span style="color: #008080;">40</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">41</span> }</span></code></pre>

<p>&nbsp;</p>
<p>　　<span style="font-size: 16px; color: #0000ff;">2.将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyData {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> j=0<span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> add(){
</span><span style="color: #008080;"> 4</span>         j++<span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span>         System.out.println("线程"+Thread.currentThread().getName()+"j 为："+<span style="color: #000000;">j);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> dec(){
</span><span style="color: #008080;"> 8</span>         j--<span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span>         System.out.println("线程"+Thread.currentThread().getName()+"j 为："+<span style="color: #000000;">j);
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getData(){
</span><span style="color: #008080;">12</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> j;
</span><span style="color: #008080;">13</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">14</span> <span style="color: #000000;">}
</span><span style="color: #008080;">15</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TestThread {
</span><span style="color: #008080;">16</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;">17</span>         <span style="color: #0000ff;">final</span> MyData data = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyData();
</span><span style="color: #008080;">18</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;2;i++<span style="color: #000000;">){
</span><span style="color: #008080;">19</span>             <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable(){
</span><span style="color: #008080;">20</span>                 <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">21</span> <span style="color: #000000;">                     data.add();
</span><span style="color: #008080;">22</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">23</span> <span style="color: #000000;">            }).start();
</span><span style="color: #008080;">24</span>             <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable(){
</span><span style="color: #008080;">25</span>                 <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">26</span> <span style="color: #000000;">                    data.dec(); 
</span><span style="color: #008080;">27</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">28</span> <span style="color: #000000;">            }).start();
</span><span style="color: #008080;">29</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">30</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">31</span> }</span></code></pre>

<p><span style="color: #ff0000;"><strong><span style="font-size: 16px;">十、多线程中的常见问题？</span></strong></span></p>
<p><span style="color: #0000ff;"><strong><span style="font-size: 16px;">1. run()方法和start()方法之间的区别？</span></strong></span></p>
<p>　　<span style="font-size: 16px;">只有调用了start方法，才会表现出多线程的特性，不同线程的run方法里面的代码交替执行。如果只是调用run方法，那么代码还是同步执行的，必须等待一个线程的run方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run方法里面的代码。</span></p>
<p><span style="font-size: 16px;">　　i. start()方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码。</span></p>
<p><span style="font-size: 16px;">　　ii. 通过调用Thread类的start方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。</span></p>
<p><span style="font-size: 16px;">　　iii. 方法run称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行run函数中的代码。run方法运行结束，此线程终止，然后CPU再调度其他线程。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">2. Runnable接口和Callable接口的区别？</span></strong></p>
<p><span style="font-size: 16px;">　　Runnable接口中的run()方法的返回值为void，它做的事情只是纯粹地去执行run()方法中的代码而已。Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</span></p>
<p><span style="font-size: 16px;">　　Callable+Future/FutureTask可以获取多线程运行的结果，可以在等待时间太长没获取需要的数据的情况下取消该线程的任务。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">3. Sleep()方法和Wait()方法的区别？</span></strong></p>
<p><span style="font-size: 16px;">　　sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器（监视对象同步），sleep方法不会放弃这个对象的监视器， wait方法会放弃这个对象的监视器，并且wait只能在同步中使用。</span></p>
<p><span style="font-size: 16px;">　　sleep方法属于Thread类，sleep方法导致了程序暂停执行指定的时间，让出CPU给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep方法过程中，线程不会释放对象锁。</span></p>
<p><span style="font-size: 16px;">　　wait方法属于Object来，当调用方法时，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对对象调用notify方法后本线程才进入对象锁定池，准备获取对象锁进入运行状态。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">4.线程让步（yield）</span></strong></p>
<p><span style="font-size: 16px;">　　yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</span></p>
<p><strong><span style="font-size: 16px; color: #0000ff;">5. join 等待其他线程终止</span></strong></p>
<p><span style="font-size: 16px;">　　join方法，等待其他线程终止，在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，当另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待CPU。</span></p>
<p><span style="font-size: 16px;">　　为什么要用join方法？</span></p>
<p><span style="font-size: 16px;">　　　　很多情况下，主线程生成并启动子线程，需要用到子线程返回结果，也就是主线程需要在子线程结束后再结束，这时就要用到join方法。</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008080;">1</span> System.out.println(Thread.currentThread().getName() + "线程运行开始!"<span style="color: #000000;">);
</span><span style="color: #008080;">2</span>      Thread6 thread1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread6();
</span><span style="color: #008080;">3</span>         thread1.setName("线程 B"<span style="color: #000000;">);
</span><span style="color: #008080;">4</span> <span style="color: #000000;">     thread1.join();
</span><span style="color: #008080;">5</span> System.out.println("这时 thread1 执行完毕之后才能执行主线程");</span></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>