<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java中的容器（集合）之ArrayList源码解析' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java中的容器（集合）之ArrayList源码解析</center></div><div class='banquan'>原文出处:本文由博客园博主喜欢听风提供。<br/>
原文连接:https://www.cnblogs.com/xihuantingfeng/p/11618015.html</div><br>
    <h3 id="autoid-0-0-0"><span style="font-family: 楷体; font-size: 18px;">1、ArrayList源码解析</span></h3>
<p><span style="font-family: 楷体; font-size: 18px;"><strong>源码解析：</strong></span></p>
<ul>
<li><span style="font-family: 楷体; font-size: 16px;">如下源码来自JDK8（如需查看ArrayList扩容源码解析请跳转至<a title="Java中的容器（集合）" href="https://www.cnblogs.com/xihuantingfeng/p/11616389.html" target="_blank">《Java中的容器（集合）》</a>第十条）:。</span></li>
</ul>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> java.util;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.function.Consumer;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.function.Predicate;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.function.UnaryOperator;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> sun.misc.SharedSecrets;

</span><span style="color: #008000;">//</span><span style="color: #008000;">其中实现了RandomAccess接口表示支持随机访问</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ArrayList&lt;E&gt; <span style="color: #0000ff;">extends</span> AbstractList&lt;E&gt;
        <span style="color: #0000ff;">implements</span> List&lt;E&gt;<span style="color: #000000;">, RandomAccess, Cloneable, java.io.Serializable
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">序列号</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span> serialVersionUID = 8683452581122892189L<span style="color: #000000;">;

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 默认初始容量
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> DEFAULT_CAPACITY = 10<span style="color: #000000;">;

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 共享的空数组实例（用于空实例）
     * 当ArrayList(int initialCapacity)，ArrayList(Collection&lt;? extends E&gt; c)中的容量等于0的时候使用
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> Object[] EMPTY_ELEMENTDATA =<span style="color: #000000;"> {};

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 共享的空数组实例（用于默认大小的空实例）
     * 将其与EMPTY_ELEMENTDATA区分开来，主要是为了知道第一次添加元素的时候需要扩容多少
     * 用于ArrayList()构造器
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA =<span style="color: #000000;"> {};

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * ArrayList保存有序元素的数组
     * ArraylList容量为数组容量
     * 任何空数组都使用 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * 当第一次添加元素的时候其容量将会扩容至 DEFAULT_CAPACITY（10）
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">transient</span> Object[] elementData; <span style="color: #008000;">//</span><span style="color: #008000;"> non-private to simplify nested class access</span>

    <span style="color: #008000;">/**</span><span style="color: #008000;">
     * ArrayList的大小（包含元素的数量）
     * </span><span style="color: #808080;">@serial</span>
     <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> size;

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 带指定容量参数的构造器，如果元素数量较大的话，可以使用此构造器，防止频繁扩容造成的性能损失
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> ArrayList(<span style="color: #0000ff;">int</span><span style="color: #000000;"> initialCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果传入值大于0，则创建一个该容量大小的数组。</span>
        <span style="color: #0000ff;">if</span> (initialCapacity &gt; 0<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">this</span>.elementData = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object[initialCapacity];
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (initialCapacity == 0<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">否则如果传入值等于0，则创建默认空数组</span>
            <span style="color: #0000ff;">this</span>.elementData =<span style="color: #000000;"> EMPTY_ELEMENTDATA;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">如果小于0则抛出异常</span>
            <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("Illegal Capacity: "+<span style="color: #000000;">
                    initialCapacity);
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 默认构造函数，其初始容量为10（注意，这里一开始其实是一个空数组，只是当add时才会进行扩容至10的操作，一定程度上减小了内存消耗。）
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> ArrayList() {
        </span><span style="color: #0000ff;">this</span>.elementData =<span style="color: #000000;"> DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 构造一个包含指定集合元素的列表，元素顺序由集合的迭代器所返回。
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> ArrayList(Collection&lt;? <span style="color: #0000ff;">extends</span> E&gt;<span style="color: #000000;"> c) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">集合转数组</span>
        elementData =<span style="color: #000000;"> c.toArray();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">指定集合含有元素</span>
        <span style="color: #0000ff;">if</span> ((size = elementData.length) != 0<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> c.toArray可能不会返回Object[] (see 6260652)
            </span><span style="color: #008000;">//</span><span style="color: #008000;">使用反射进行运行时判断elementData是否属于Object[]</span>
            <span style="color: #0000ff;">if</span> (elementData.getClass() != Object[].<span style="color: #0000ff;">class</span><span style="color: #000000;">)
                </span><span style="color: #008000;">//</span><span style="color: #008000;">拷贝数组</span>
                elementData = Arrays.copyOf(elementData, size, Object[].<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 由空数组代替</span>
            <span style="color: #0000ff;">this</span>.elementData =<span style="color: #000000;"> EMPTY_ELEMENTDATA;
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 修改ArrayList容量为list的当前大小
     * 一个应用可以使用此操作来最小化一个ArrayList的存储
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> trimToSize() {
        modCount</span>++<span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果当前数组元素个数小于数组容量</span>
        <span style="color: #0000ff;">if</span> (size &lt;<span style="color: #000000;"> elementData.length) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">没有元素返回空数组，否则返回元素个数的数组。</span>
            elementData = (size == 0<span style="color: #000000;">)
                    </span>?<span style="color: #000000;"> EMPTY_ELEMENTDATA
                    : Arrays.copyOf(elementData, size);
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 如果有必要去增加ArrayList的容量，请确保它至少可以容纳由最小容量参数指定的元素数量
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;">   minCapacity   所需的最小容量
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> ensureCapacity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">默认最小容量，空数组以及默认大小10</span>
        <span style="color: #0000ff;">int</span> minExpand = (elementData !=<span style="color: #000000;"> DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> any size if not default element table</span>
                ? 0
                <span style="color: #008000;">//</span><span style="color: #008000;"> larger than default for default empty table. It's already
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> supposed to be at default size.</span>
<span style="color: #000000;">                : DEFAULT_CAPACITY;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果传入容量大于最小容量，则进行扩容</span>
        <span style="color: #0000ff;">if</span> (minCapacity &gt;<span style="color: #000000;"> minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> calculateCapacity(Object[] elementData, <span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果elementData为默认空数组，则比较传入值与默认值（10），返回两者中的较大值
        </span><span style="color: #008000;">//</span><span style="color: #008000;">elementData为默认空数组指的是通过ArrayList()这个构造器创建的ArrayList对象</span>
        <span style="color: #0000ff;">if</span> (elementData ==<span style="color: #000000;"> DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">返回传入值</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> minCapacity;
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> ensureCapacityInternal(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">先通过calculateCapacity方法计算最终容量，以确认实际容量</span>
<span style="color: #000000;">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> ensureExplicitCapacity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        modCount</span>++<span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> overflow-conscious code
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果最终确认容量大于数组容量，则进行grow()扩容</span>
        <span style="color: #0000ff;">if</span> (minCapacity - elementData.length &gt; 0<span style="color: #000000;">)
            grow(minCapacity);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 可分配数组最大大小
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8<span style="color: #000000;">;

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 增加ArrayList的容量，以确保它至少可以容纳由最小容量参数指定的元素数量
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> minCapacity 所需的最小容量
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> grow(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> overflow-conscious code
        </span><span style="color: #008000;">//</span><span style="color: #008000;">oldCapacity表示旧容量</span>
        <span style="color: #0000ff;">int</span> oldCapacity =<span style="color: #000000;"> elementData.length;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">newCapacity表示新容量，计算规则为旧容量+旧容量的0.5，即旧容量的1.5倍。如果超过int的最大值会返回一个负数。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">oldCapacity &gt;&gt; 1表示右移一位，对应除以2的1次方。</span>
        <span style="color: #0000ff;">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果新容量小于最小容量，则将最小容量赋值给新容量(有时手动扩容可能也会返回&lt;0，对应方法为ensureCapacity())</span>
        <span style="color: #0000ff;">if</span> (newCapacity - minCapacity &lt; 0<span style="color: #000000;">)
            newCapacity </span>=<span style="color: #000000;"> minCapacity;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果新容量大于MAX_ARRAY_SIZE，则执行hugeCapacity(minCapacity)返回对应值</span>
        <span style="color: #0000ff;">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0<span style="color: #000000;">)
            newCapacity </span>=<span style="color: #000000;"> hugeCapacity(minCapacity);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> minCapacity is usually close to size, so this is a win:
        </span><span style="color: #008000;">//</span><span style="color: #008000;">复制旧数组到新容量数组中，完成扩容操作</span>
        elementData =<span style="color: #000000;"> Arrays.copyOf(elementData, newCapacity);
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> hugeCapacity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> minCapacity) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果最小容量超过了int的最大值，minCapacity会是一个负数，此时抛出内存溢出错误</span>
        <span style="color: #0000ff;">if</span> (minCapacity &lt; 0) <span style="color: #008000;">//</span><span style="color: #008000;"> overflow</span>
            <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> OutOfMemoryError();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">比较最小容量是否大于MAX_ARRAY_SIZE，如果是则返回Integer.MAX_VALUE，否则返回MAX_ARRAY_SIZE</span>
        <span style="color: #0000ff;">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<span style="color: #000000;">
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回列表元素数
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> size() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> size;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 如果列表不包含元素，返回true
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isEmpty() {
        </span><span style="color: #0000ff;">return</span> size == 0<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 如果列表包含指定元素，返回true
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> contains(Object o) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">返回此列表中指定元素第一次出现的索引，如果列表中不包含指定元素，则为-1</span>
        <span style="color: #0000ff;">return</span> indexOf(o) &gt;= 0<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回此列表中指定元素第一次出现的索引，如果列表中不包含指定元素，则为-1
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> indexOf(Object o) {
        </span><span style="color: #0000ff;">if</span> (o == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; size; i++<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span> (elementData[i]==<span style="color: #0000ff;">null</span><span style="color: #000000;">)
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; size; i++<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (o.equals(elementData[i]))
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> -1<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回此列表中指定元素最后一次出现的索引，如果列表中不包含指定元素，则为-1
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> lastIndexOf(Object o) {
        </span><span style="color: #0000ff;">if</span> (o == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = size-1; i &gt;= 0; i--<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span> (elementData[i]==<span style="color: #0000ff;">null</span><span style="color: #000000;">)
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = size-1; i &gt;= 0; i--<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (o.equals(elementData[i]))
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> -1<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回ArrayList实例的一个浅拷贝，列表中的元素不会被拷贝
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Object clone() {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            ArrayList</span>&lt;?&gt; v = (ArrayList&lt;?&gt;) <span style="color: #0000ff;">super</span><span style="color: #000000;">.clone();
            v.elementData </span>=<span style="color: #000000;"> Arrays.copyOf(elementData, size);
            v.modCount </span>= 0<span style="color: #000000;">;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> v;
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (CloneNotSupportedException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> this shouldn't happen, since we are Cloneable</span>
            <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> InternalError(e);
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     * 返回的数组将是&ldquo;安全的&rdquo;，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Object[] toArray() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Arrays.copyOf(elementData, size);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> &lt;T&gt;<span style="color: #000000;"> T[] toArray(T[] a) {
        </span><span style="color: #0000ff;">if</span> (a.length &lt;<span style="color: #000000;"> size)
            </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个新的运行时类型数组，内容为ArrayList数组的</span>
            <span style="color: #0000ff;">return</span><span style="color: #000000;"> (T[]) Arrays.copyOf(elementData, size, a.getClass());
        System.arraycopy(elementData, </span>0, a, 0<span style="color: #000000;">, size);
        </span><span style="color: #0000ff;">if</span> (a.length &gt;<span style="color: #000000;"> size)
            a[size] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 位置访问操作</span>
<span style="color: #000000;">
    @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
    E elementData(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> (E) elementData[index];
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回此列表中指定位置的元素
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> E get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查索引是否越界</span>
<span style="color: #000000;">        rangeCheck(index);

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> elementData(index);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 用指定元素替换列表中的指定位置的元素
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> E set(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index, E element) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查索引是否越界</span>
<span style="color: #000000;">        rangeCheck(index);

        E oldValue </span>=<span style="color: #000000;"> elementData(index);
        elementData[index] </span>=<span style="color: #000000;"> element;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> oldValue;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 将指定元素追加到数组末尾
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(E e) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">添加之前先确认是否需要扩容</span>
        ensureCapacityInternal(size + 1);  <span style="color: #008000;">//</span><span style="color: #008000;"> Increments modCount!!
        </span><span style="color: #008000;">//</span><span style="color: #008000;">新加入的元素是添加在了数组的末尾，随后数组size自增。</span>
        elementData[size++] =<span style="color: #000000;"> e;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 插入指定元素到此列表中的指定位置
     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size </span>+ 1);  <span style="color: #008000;">//</span><span style="color: #008000;"> Increments modCount!!
        </span><span style="color: #008000;">//</span><span style="color: #008000;">自己复制自己</span>
        System.arraycopy(elementData, index, elementData, index + 1<span style="color: #000000;">,
                size </span>-<span style="color: #000000;"> index);
        elementData[index] </span>=<span style="color: #000000;"> element;
        size</span>++<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 将列表中指定位置的元素移除，后续所有元素移到左端（从他们的索引中减去一个）
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> E remove(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        rangeCheck(index);

        modCount</span>++<span style="color: #000000;">;
        E oldValue </span>=<span style="color: #000000;"> elementData(index);

        </span><span style="color: #0000ff;">int</span> numMoved = size - index - 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (numMoved &gt; 0<span style="color: #000000;">)
            System.arraycopy(elementData, index</span>+1<span style="color: #000000;">, elementData, index,
                    numMoved);
        elementData[</span>--size] = <span style="color: #0000ff;">null</span>; <span style="color: #008000;">//</span><span style="color: #008000;">  清理工作交给GC</span>

        <span style="color: #0000ff;">return</span><span style="color: #000000;"> oldValue;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 从列表中移除第一次出现的指定元素，如果不存在，则不更改
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> remove(Object o) {
        </span><span style="color: #0000ff;">if</span> (o == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> index = 0; index &lt; size; index++<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span> (elementData[index] == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    fastRemove(index);
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> index = 0; index &lt; size; index++<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (o.equals(elementData[index])) {
                    fastRemove(index);
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> fastRemove(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        modCount</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> numMoved = size - index - 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (numMoved &gt; 0<span style="color: #000000;">)
            System.arraycopy(elementData, index</span>+1<span style="color: #000000;">, elementData, index,
                    numMoved);
        elementData[</span>--size] = <span style="color: #0000ff;">null</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> clear to let GC do its work</span>
<span style="color: #000000;">    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 移除列表中的所有元素，之后会返回一个空数组
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> clear() {
        modCount</span>++<span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> clear to let GC do its work</span>
        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; size; i++<span style="color: #000000;">)
            elementData[i] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        size </span>= 0<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 将指定集合中的元素以Iterator返回的顺序，追加到列表末尾
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> addAll(Collection&lt;? <span style="color: #0000ff;">extends</span> E&gt;<span style="color: #000000;"> c) {
        Object[] a </span>=<span style="color: #000000;"> c.toArray();
        </span><span style="color: #0000ff;">int</span> numNew =<span style="color: #000000;"> a.length;
        ensureCapacityInternal(size </span>+ numNew);  <span style="color: #008000;">//</span><span style="color: #008000;"> Increments modCount</span>
        System.arraycopy(a, 0<span style="color: #000000;">, elementData, size, numNew);
        size </span>+=<span style="color: #000000;"> numNew;
        </span><span style="color: #0000ff;">return</span> numNew != 0<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 将指定集合中的元素以Iterator返回的顺序，插入到指定位置
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> addAll(<span style="color: #0000ff;">int</span> index, Collection&lt;? <span style="color: #0000ff;">extends</span> E&gt;<span style="color: #000000;"> c) {
        rangeCheckForAdd(index);

        Object[] a </span>=<span style="color: #000000;"> c.toArray();
        </span><span style="color: #0000ff;">int</span> numNew =<span style="color: #000000;"> a.length;
        ensureCapacityInternal(size </span>+ numNew);  <span style="color: #008000;">//</span><span style="color: #008000;"> Increments modCount</span>

        <span style="color: #0000ff;">int</span> numMoved = size -<span style="color: #000000;"> index;
        </span><span style="color: #0000ff;">if</span> (numMoved &gt; 0<span style="color: #000000;">)
            System.arraycopy(elementData, index, elementData, index </span>+<span style="color: #000000;"> numNew,
                    numMoved);

        System.arraycopy(a, </span>0<span style="color: #000000;">, elementData, index, numNew);
        size </span>+=<span style="color: #000000;"> numNew;
        </span><span style="color: #0000ff;">return</span> numNew != 0<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 移除[fromIndex,toIndex)之间的元素，后续元素移到左端
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> removeRange(<span style="color: #0000ff;">int</span> fromIndex, <span style="color: #0000ff;">int</span><span style="color: #000000;"> toIndex) {
        modCount</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> numMoved = size -<span style="color: #000000;"> toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                numMoved);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> clear to let GC do its work</span>
        <span style="color: #0000ff;">int</span> newSize = size - (toIndex-<span style="color: #000000;">fromIndex);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = newSize; i &lt; size; i++<span style="color: #000000;">) {
            elementData[i] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
        size </span>=<span style="color: #000000;"> newSize;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     *检查给定索引是否在界限内。
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> rangeCheck(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        </span><span style="color: #0000ff;">if</span> (index &gt;=<span style="color: #000000;"> size)
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * add and addAll使用的rangeCheck
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> rangeCheckForAdd(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        </span><span style="color: #0000ff;">if</span> (index &gt; size || index &lt; 0<span style="color: #000000;">)
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回 an IndexOutOfBoundsException 的细节信息
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> String outOfBoundsMsg(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        </span><span style="color: #0000ff;">return</span> "Index: "+index+", Size: "+<span style="color: #000000;">size;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 从列表中移除指定集合包含的所有元素
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> removeAll(Collection&lt;?&gt;<span style="color: #000000;"> c) {
        Objects.requireNonNull(c);
        </span><span style="color: #0000ff;">return</span> batchRemove(c, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 保留此列表中指定集合的所有元素
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> retainAll(Collection&lt;?&gt;<span style="color: #000000;"> c) {
        Objects.requireNonNull(c);
        </span><span style="color: #0000ff;">return</span> batchRemove(c, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">批量移除</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">boolean</span> batchRemove(Collection&lt;?&gt; c, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> complement) {
        </span><span style="color: #0000ff;">final</span> Object[] elementData = <span style="color: #0000ff;">this</span><span style="color: #000000;">.elementData;
        </span><span style="color: #0000ff;">int</span> r = 0, w = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">boolean</span> modified = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (; r &lt; size; r++<span style="color: #000000;">)
                </span><span style="color: #0000ff;">if</span> (c.contains(elementData[r]) ==<span style="color: #000000;"> complement)
                    elementData[w</span>++] =<span style="color: #000000;"> elementData[r];
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Preserve behavioral compatibility with AbstractCollection,
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> even if c.contains() throws.</span>
            <span style="color: #0000ff;">if</span> (r !=<span style="color: #000000;"> size) {
                System.arraycopy(elementData, r,
                        elementData, w,
                        size </span>-<span style="color: #000000;"> r);
                w </span>+= size -<span style="color: #000000;"> r;
            }
            </span><span style="color: #0000ff;">if</span> (w !=<span style="color: #000000;"> size) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> clear to let GC do its work</span>
                <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = w; i &lt; size; i++<span style="color: #000000;">)
                    elementData[i] </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                modCount </span>+= size -<span style="color: #000000;"> w;
                size </span>=<span style="color: #000000;"> w;
                modified </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> modified;
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 保存ArrayList状态到一个流中（即序列化）
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> writeObject(java.io.ObjectOutputStream s)
            </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> java.io.IOException{
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Write out element count, and any hidden stuff</span>
        <span style="color: #0000ff;">int</span> expectedModCount =<span style="color: #000000;"> modCount;
        s.defaultWriteObject();

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Write out size as capacity for behavioural compatibility with clone()</span>
<span style="color: #000000;">        s.writeInt(size);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Write out all elements in the proper order.</span>
        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=0; i&lt;size; i++<span style="color: #000000;">) {
            s.writeObject(elementData[i]);
        }

        </span><span style="color: #0000ff;">if</span> (modCount !=<span style="color: #000000;"> expectedModCount) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConcurrentModificationException();
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 从一个流中读取ArrayList（即反序列化）
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> readObject(java.io.ObjectInputStream s)
            </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> java.io.IOException, ClassNotFoundException {
        elementData </span>=<span style="color: #000000;"> EMPTY_ELEMENTDATA;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Read in size, and any hidden stuff</span>
<span style="color: #000000;">        s.defaultReadObject();

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Read in capacity</span>
        s.readInt(); <span style="color: #008000;">//</span><span style="color: #008000;"> ignored</span>

        <span style="color: #0000ff;">if</span> (size &gt; 0<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> be like clone(), allocate array based upon size not capacity</span>
            <span style="color: #0000ff;">int</span> capacity =<span style="color: #000000;"> calculateCapacity(elementData, size);
            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].</span><span style="color: #0000ff;">class</span><span style="color: #000000;">, capacity);
            ensureCapacityInternal(size);

            Object[] a </span>=<span style="color: #000000;"> elementData;
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Read in all elements in the proper order.</span>
            <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=0; i&lt;size; i++<span style="color: #000000;">) {
                a[i] </span>=<span style="color: #000000;"> s.readObject();
            }
        }
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     *  从列表中的指定位置开始，返回之后所有元素的列表迭代器（按正确的顺序）
     *  指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
     *  返回的列表迭代器是fail-fast 。
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> ListIterator&lt;E&gt; listIterator(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index) {
        </span><span style="color: #0000ff;">if</span> (index &lt; 0 || index &gt;<span style="color: #000000;"> size)
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IndexOutOfBoundsException("Index: "+<span style="color: #000000;">index);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ListItr(index);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回列表中的包含所有元素的列表迭代器（按正确的顺序）。
     * 返回的列表迭代器是fail-fast 。
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> ListIterator&lt;E&gt;<span style="color: #000000;"> listIterator() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> ListItr(0<span style="color: #000000;">);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 以正确的顺序返回列表中的包含所有元素的迭代器。
     * 返回的迭代器是fail-fast 。
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> Iterator&lt;E&gt;<span style="color: #000000;"> iterator() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Itr();
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> forEach(Consumer&lt;? <span style="color: #0000ff;">super</span> E&gt;<span style="color: #000000;"> action) {
        Objects.requireNonNull(action);
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> expectedModCount =<span style="color: #000000;"> modCount;
        @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
        </span><span style="color: #0000ff;">final</span> E[] elementData = (E[]) <span style="color: #0000ff;">this</span><span style="color: #000000;">.elementData;
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> size = <span style="color: #0000ff;">this</span><span style="color: #000000;">.size;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++<span style="color: #000000;">) {
            action.accept(elementData[i]);
        }
        </span><span style="color: #0000ff;">if</span> (modCount !=<span style="color: #000000;"> expectedModCount) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConcurrentModificationException();
        }
    }


    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> removeIf(Predicate&lt;? <span style="color: #0000ff;">super</span> E&gt;<span style="color: #000000;"> filter) {
        Objects.requireNonNull(filter);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> figure out which elements are to be removed
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> any exception thrown from the filter predicate at this stage
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> will leave the collection unmodified</span>
        <span style="color: #0000ff;">int</span> removeCount = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">final</span> BitSet removeSet = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BitSet(size);
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> expectedModCount =<span style="color: #000000;"> modCount;
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> size = <span style="color: #0000ff;">this</span><span style="color: #000000;">.size;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++<span style="color: #000000;">) {
            @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
            </span><span style="color: #0000ff;">final</span> E element =<span style="color: #000000;"> (E) elementData[i];
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (filter.test(element)) {
                removeSet.set(i);
                removeCount</span>++<span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">if</span> (modCount !=<span style="color: #000000;"> expectedModCount) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConcurrentModificationException();
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> shift surviving elements left over the spaces left by removed elements</span>
        <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span> anyToRemove = removeCount &gt; 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (anyToRemove) {
            </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> newSize = size -<span style="color: #000000;"> removeCount;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++<span style="color: #000000;">) {
                i </span>=<span style="color: #000000;"> removeSet.nextClearBit(i);
                elementData[j] </span>=<span style="color: #000000;"> elementData[i];
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k=newSize; k &lt; size; k++<span style="color: #000000;">) {
                elementData[k] </span>= <span style="color: #0000ff;">null</span>;  <span style="color: #008000;">//</span><span style="color: #008000;"> Let gc do its work</span>
<span style="color: #000000;">            }
            </span><span style="color: #0000ff;">this</span>.size =<span style="color: #000000;"> newSize;
            </span><span style="color: #0000ff;">if</span> (modCount !=<span style="color: #000000;"> expectedModCount) {
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConcurrentModificationException();
            }
            modCount</span>++<span style="color: #000000;">;
        }

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> anyToRemove;
    }

    @Override
    @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> replaceAll(UnaryOperator&lt;E&gt;<span style="color: #000000;"> operator) {
        Objects.requireNonNull(operator);
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> expectedModCount =<span style="color: #000000;"> modCount;
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> size = <span style="color: #0000ff;">this</span><span style="color: #000000;">.size;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++<span style="color: #000000;">) {
            elementData[i] </span>=<span style="color: #000000;"> operator.apply((E) elementData[i]);
        }
        </span><span style="color: #0000ff;">if</span> (modCount !=<span style="color: #000000;"> expectedModCount) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConcurrentModificationException();
        }
        modCount</span>++<span style="color: #000000;">;
    }

    @Override
    @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> sort(Comparator&lt;? <span style="color: #0000ff;">super</span> E&gt;<span style="color: #000000;"> c) {
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> expectedModCount =<span style="color: #000000;"> modCount;
        Arrays.sort((E[]) elementData, </span>0<span style="color: #000000;">, size, c);
        </span><span style="color: #0000ff;">if</span> (modCount !=<span style="color: #000000;"> expectedModCount) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConcurrentModificationException();
        }
        modCount</span>++<span style="color: #000000;">;
    }
}</span></code></pre>

<p><span style="font-family: 楷体; font-size: 16px;">&nbsp;&nbsp;（以上所有内容皆为个人笔记，如有错误之处还望指正。）</span></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>