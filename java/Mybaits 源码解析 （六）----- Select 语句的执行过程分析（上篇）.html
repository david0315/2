<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Mybaits 源码解析 （六）----- Select 语句的执行过程分析（上篇）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Mybaits 源码解析 （六）----- Select 语句的执行过程分析（上篇）</center></div><div class='banquan'>原文出处:本文由博客园博主chen_hao提供。<br/>
原文连接:https://www.cnblogs.com/java-chen-hao/p/11754184.html</div><br>
    <p>上一篇我们分析了Mapper接口代理类的生成，本篇接着分析是如何调用到XML中的SQL</p>
<p>我们回顾一下MapperMethod 的execute方法</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span><span style="color: #000000;"> Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 根据 SQL 类型执行相应的数据库操作</span>
    <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (command.getType()) {
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> INSERT: {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 对用户传入的参数进行转换，下同</span>
            Object param =<span style="color: #000000;"> method.convertArgsToSqlCommandParam(args);
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行插入操作，rowCountResult 方法用于处理返回值</span>
            result =<span style="color: #000000;"> rowCountResult(sqlSession.insert(command.getName(), param));
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> UPDATE: {
            Object param </span>=<span style="color: #000000;"> method.convertArgsToSqlCommandParam(args);
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行更新操作</span>
            result =<span style="color: #000000;"> rowCountResult(sqlSession.update(command.getName(), param));
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> DELETE: {
            Object param </span>=<span style="color: #000000;"> method.convertArgsToSqlCommandParam(args);
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行删除操作</span>
            result =<span style="color: #000000;"> rowCountResult(sqlSession.delete(command.getName(), param));
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> SELECT:
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 根据目标方法的返回类型进行相应的查询操作</span>
            <span style="color: #0000ff;">if</span> (method.returnsVoid() &amp;&amp;<span style="color: #000000;"> method.hasResultHandler()) {
                executeWithResultHandler(sqlSession, args);
                result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (method.returnsMany()) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行查询操作，并返回多个结果 </span>
                result =<span style="color: #000000;"> executeForMany(sqlSession, args);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (method.returnsMap()) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行查询操作，并将结果封装在 Map 中返回</span>
                result =<span style="color: #000000;"> executeForMap(sqlSession, args);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (method.returnsCursor()) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行查询操作，并返回一个 Cursor 对象</span>
                result =<span style="color: #000000;"> executeForCursor(sqlSession, args);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                Object param </span>=<span style="color: #000000;"> method.convertArgsToSqlCommandParam(args);
                </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 执行查询操作，并返回一个结果</span>
                result =</strong><span style="color: #000000;"><strong> sqlSession.selectOne(command.getName(), param);</strong>
            }
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> FLUSH:
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行刷新操作</span>
            result =<span style="color: #000000;"> sqlSession.flushStatements();
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BindingException("Unknown execution method for: " +<span style="color: #000000;"> command.getName());
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
}</span></code></pre>

<h2 id="autoid-3-2-0">selectOne 方法分析</h2>
<p>本节选择分析 selectOne 方法，主要是因为 selectOne 在内部会调用 selectList 方法。同时分析 selectOne 方法等同于分析 selectList 方法。代码如下</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 执行查询操作，并返回一个结果</span>
result = sqlSession.selectOne(command.getName(), param);</code></pre>

<p>我们看到是通过sqlSession来执行查询的，并且传入的参数为command.getName()和param，也就是namespace.methodName（mapper.EmployeeMapper.getAll）和方法的运行参数。我们知道了，所有的数据库操作都是交给sqlSession来执行的，那我们就来看看sqlSession的方法</p>
<p><strong>DefaultSqlSession</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;T&gt;<span style="color: #000000;"> T selectOne(String statement, Object parameter) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用 selectList 获取结果</span>
   <strong> List&lt;T&gt; list = <span style="color: #0000ff;">this</span>.&lt;T&gt;<span style="color: #000000;">selectList(statement, parameter);
    </span></strong><span style="color: #0000ff;">if</span> (list.size() == 1<span style="color: #000000;">) {
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 返回结果</span>
        <span style="color: #0000ff;">return</span> list.get(0</strong><span style="color: #000000;"><strong>);</strong>
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (list.size() &gt; 1<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果查询结果大于1则抛出异常</span>
        <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> TooManyResultsException(
            </span>"Expected one result (or null) to be returned by selectOne(), but found: " +<span style="color: #000000;"> list.size());
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
}</span></code></pre>

<p>如上，selectOne 方法在内部调用 selectList 了方法，并取 selectList 返回值的第1个元素作为自己的返回值。如果 selectList 返回的列表元素大于1，则抛出异常。下面我们来看看 selectList 方法的实现。</p>
<p><strong>DefaultSqlSession</strong></p>
<src class="cnblogs_code">
<pre><code><strong><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> Executor executor;
</span></strong><span style="color: #0000ff;">public</span> &lt;E&gt; List&lt;E&gt;<span style="color: #000000;"> selectList(String statement, Object parameter) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用重载方法</span>
    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.selectList(statement, parameter, RowBounds.DEFAULT);
}

</span><span style="color: #0000ff;">public</span> &lt;E&gt; List&lt;E&gt;<span style="color: #000000;"> selectList(String statement, Object parameter, RowBounds rowBounds) {
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 通过MappedStatement的Id获取 MappedStatement</span>
        MappedStatement ms =<span style="color: #000000;"> configuration.getMappedStatement(statement);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用 Executor 实现类中的 query 方法</span>
        <span style="color: #0000ff;">return</span></strong><span style="color: #000000;"><strong> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</strong>
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
        </span><span style="color: #0000ff;">throw</span> ExceptionFactory.wrapException("Error querying database.  Cause: " +<span style="color: #000000;"> e, e);
    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
        ErrorContext.instance().reset();
    }
}</span></code></pre>

<p>我们之前创建<strong>DefaultSqlSession</strong>的时候，是创建了一个Executor的实例作为其属性的，我们看到<strong>通过MappedStatement的Id获取 MappedStatement后，就交由Executor去执行了</strong></p>
<p>我们回顾一下前面的文章，Executor的创建过程，代码如下</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">创建一个执行器，默认是SIMPLE</span>
<span style="color: #0000ff;">public</span><span style="color: #000000;"> Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    executorType </span>= executorType == <span style="color: #0000ff;">null</span> ?<span style="color: #000000;"> defaultExecutorType : executorType;
    executorType </span>= executorType == <span style="color: #0000ff;">null</span> ?<span style="color: #000000;"> ExecutorType.SIMPLE : executorType;
    Executor executor;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">根据executorType来创建相应的执行器,Configuration默认是SIMPLE</span>
    <span style="color: #0000ff;">if</span> (ExecutorType.BATCH ==<span style="color: #000000;"> executorType) {
      executor </span>= <span style="color: #0000ff;">new</span> BatchExecutor(<span style="color: #0000ff;">this</span><span style="color: #000000;">, transaction);
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (ExecutorType.REUSE ==<span style="color: #000000;"> executorType) {
      executor </span>= <span style="color: #0000ff;">new</span> ReuseExecutor(<span style="color: #0000ff;">this</span><span style="color: #000000;">, transaction);
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">创建SimpleExecutor实例，并且包含Configuration和transaction属性</span>
     <strong> executor = <span style="color: #0000ff;">new</span> SimpleExecutor(<span style="color: #0000ff;">this</span></strong><span style="color: #000000;"><strong>, transaction);</strong>
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果要求缓存，生成另一种CachingExecutor,装饰者模式,默认都是返回CachingExecutor</span>
    <span style="color: #008000;">/**</span><span style="color: #008000;">
     * 二级缓存开关配置示例
     * &lt;settings&gt;
     *   &lt;setting name="cacheEnabled" value="true"/&gt;
     * &lt;/settings&gt;
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (cacheEnabled) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">CachingExecutor使用装饰器模式，将executor的功能添加上了二级缓存的功能，二级缓存会单独文章来讲</span>
    <strong>  executor = <span style="color: #0000ff;">new</span></strong><span style="color: #000000;"><strong> CachingExecutor(executor);</strong>
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">此处调用插件,通过插件可以改变Executor行为，此处我们后面单独文章讲</span>
    executor =<span style="color: #000000;"> (Executor) interceptorChain.pluginAll(executor);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> executor;
}</span></code></pre>

<p>executor包含了Configuration和Transaction，默认的执行器为SimpleExecutor，如果开启了二级缓存(默认开启)，则CachingExecutor会包装SimpleExecutor，那么我们该看CachingExecutor的<strong>query</strong>方法了</p>
<p><strong>CachingExecutor</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 获取 BoundSql</span>
    BoundSql boundSql =<span style="color: #000000;"> ms.getBoundSql(parameterObject);
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 CacheKey</span>
    CacheKey key =<span style="color: #000000;"> createCacheKey(ms, parameterObject, rowBounds, boundSql);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用重载方法</span>
    <span style="color: #0000ff;">return</span></strong><span style="color: #000000;"><strong> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</strong>
}</span></code></pre>

<p>上面的代码用于获取 BoundSql 对象，创建 CacheKey 对象，然后再将这两个对象传给重载方法。CacheKey 以及接下来即将出现的一二级缓存将会独立成文进行分析。</p>
<h3 id="autoid-3-2-1">获取 BoundSql</h3>
<p>我们先来看看获取BoundSql</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 获取 BoundSql</span>
BoundSql boundSql = ms.getBoundSql(parameterObject);</code></pre>

<p>调用了MappedStatement的getBoundSql方法，并将运行时参数传入其中，我们大概的猜一下，这里是不是拼接SQL语句呢，并将运行时参数设置到SQL语句中？</p>
<p>我们都知道 SQL 是配置在映射文件中的，但由于映射文件中的 SQL 可能会包含占位符 #{}，以及动态 SQL 标签，比如 &lt;if&gt;、&lt;where&gt; 等。因此，我们并不能直接使用映射文件中配置的 SQL。MyBatis 会将映射文件中的 SQL 解析成一组 SQL 片段。我们需要对这一组片段进行解析，从每个片段对象中获取相应的内容。然后将这些内容组合起来即可得到一个完成的 SQL 语句，这个完整的 SQL 以及其他的一些信息最终会存储在 BoundSql 对象中。下面我们来看一下 BoundSql 类的成员变量信息，如下：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String sql;
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> List&lt;ParameterMapping&gt;<span style="color: #000000;"> parameterMappings;
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> Object parameterObject;
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Map&lt;String, Object&gt;<span style="color: #000000;"> additionalParameters;
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> MetaObject metaParameters;</code></pre>

<p>下面用一个表格列举各个成员变量的含义。</p>
<table>
<thead>
<tr class="header"><th>变量名</th><th>类型</th><th>用途</th></tr>
</thead>
<tbody>
<tr class="odd">
<td>sql</td>
<td>String</td>
<td>一个完整的 SQL 语句，可能会包含问号 ? 占位符</td>
</tr>
<tr class="even">
<td>parameterMappings</td>
<td>List</td>
<td>参数映射列表，SQL 中的每个 #{xxx} 占位符都会被解析成相应的 ParameterMapping 对象</td>
</tr>
<tr class="odd">
<td>parameterObject</td>
<td>Object</td>
<td>运行时参数，即用户传入的参数，比如 Article 对象，或是其他的参数</td>
</tr>
<tr class="even">
<td>additionalParameters</td>
<td>Map</td>
<td>附加参数集合，用于存储一些额外的信息，比如 datebaseId 等</td>
</tr>
<tr class="odd">
<td>metaParameters</td>
<td>MetaObject</td>
<td>additionalParameters 的元信息对象</td>
</tr>
</tbody>
</table>
<p>接下来我们接着MappedStatement 的 getBoundSql 方法，代码如下：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span><span style="color: #000000;"> BoundSql getBoundSql(Object parameterObject) {

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用 sqlSource 的 getBoundSql 获取 BoundSql，把method运行时参数传进去</span>
<strong>    BoundSql boundSql =</strong><span style="color: #000000;"><strong> sqlSource.getBoundSql(parameterObject);</strong></span><span style="color: #0000ff;">return</span><span style="color: #000000;"> boundSql;
}</span></code></pre>

<p>MappedStatement 的 getBoundSql 在内部调用了 SqlSource 实现类的 getBoundSql 方法，并把method运行时参数传进去，SqlSource 是一个接口，它有如下几个实现类：</p>
<ul>
<li>DynamicSqlSource</li>
<li>RawSqlSource</li>
<li>StaticSqlSource</li>
<li>ProviderSqlSource</li>
<li>VelocitySqlSource</li>
</ul>
<p>当 SQL 配置中包含&nbsp;<code>${}</code>（不是 #{}）占位符，或者包含 &lt;if&gt;、&lt;where&gt; 等标签时，会被认为是动态 SQL，此时使用 DynamicSqlSource 存储 SQL 片段。否则，使用 RawSqlSource 存储 SQL 配置信息。我们来看看DynamicSqlSource的<strong>getBoundSql</strong></p>
<p><strong>DynamicSqlSource</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span><span style="color: #000000;"> BoundSql getBoundSql(Object parameterObject) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 DynamicContext</span>
    DynamicContext context = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DynamicContext(configuration, parameterObject);

    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 解析 SQL 片段，并将解析结果存储到 DynamicContext 中，这里会将${}替换成method对应的运行时参数，也会解析&lt;if&gt;&lt;where&gt;等SqlNode</span>
</strong><span style="color: #000000;"><strong>    rootSqlNode.apply(context);</strong>
    
    SqlSourceBuilder sqlSourceParser </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> SqlSourceBuilder(configuration);
    Class</span>&lt;?&gt; parameterType = parameterObject == <span style="color: #0000ff;">null</span> ? Object.<span style="color: #0000ff;">class</span><span style="color: #000000;"> : parameterObject.getClass();
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     *<strong> 构建 StaticSqlSource，在此过程中将 sql 语句中的占位符 #{} 替换为问号 ?，</strong>
     * <strong>并为每个占位符构建相应的 ParameterMapping
     </strong></span><span style="color: #008000;">*/</span><strong><span style="color: #000000;">
    SqlSource sqlSource </span>=<span style="color: #000000;"> sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());
    
 </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用 StaticSqlSource 的 getBoundSql 获取 BoundSql</span>
    BoundSql boundSql =<span style="color: #000000;"> sqlSource.getBoundSql(parameterObject);

    </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> 将 DynamicContext 的 ContextMap 中的内容拷贝到 BoundSql 中</span>
    <span style="color: #0000ff;">for</span> (Map.Entry&lt;String, Object&gt;<span style="color: #000000;"> entry : context.getBindings().entrySet()) {
        boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> boundSql;
}</span></code></pre>

<p>该方法由数个步骤组成，这里总结一下：</p>
<ol>
<li>创建 DynamicContext</li>
<li>解析 SQL 片段，并将解析结果存储到 DynamicContext 中</li>
<li>解析 SQL 语句，并构建 StaticSqlSource</li>
<li>调用 StaticSqlSource 的 getBoundSql 获取 BoundSql</li>
<li>将 DynamicContext 的 ContextMap 中的内容拷贝到 BoundSql</li>
</ol>
<p id="autoid-3-2-2"><strong>DynamicContext</strong></p>
<p>DynamicContext 是 SQL 语句构建的上下文，每个 SQL 片段解析完成后，都会将解析结果存入 DynamicContext 中。待所有的 SQL 片段解析完毕后，一条完整的 SQL 语句就会出现在 DynamicContext 对象中。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> DynamicContext {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String PARAMETER_OBJECT_KEY = "_parameter"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String DATABASE_ID_KEY = "_databaseId"<span style="color: #000000;">;

    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;">bindings 则用于存储一些额外的信息，比如运行时参数</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> ContextMap bindings;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">sqlBuilder 变量用于存放 SQL 片段的解析结果</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> StringBuilder sqlBuilder = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuilder();

    </span></strong><span style="color: #0000ff;">public</span><span style="color: #000000;"> DynamicContext(Configuration configuration, Object parameterObject) {
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 ContextMap,并将运行时参数放入ContextMap中</span></strong>
        <span style="color: #0000ff;">if</span> (parameterObject != <span style="color: #0000ff;">null</span> &amp;&amp; !(parameterObject <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Map)) {
            MetaObject metaObject </span>=<span style="color: #000000;"> configuration.newMetaObject(parameterObject);
           <strong> bindings </strong></span><strong>= <span style="color: #0000ff;">new</span></strong><span style="color: #000000;"><strong> ContextMap(metaObject);</strong>
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            bindings </span>= <span style="color: #0000ff;">new</span> ContextMap(<span style="color: #0000ff;">null</span><span style="color: #000000;">);
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 存放运行时参数 parameterObject 以及 databaseId</span>
<span style="color: #000000;">        bindings.put(PARAMETER_OBJECT_KEY, parameterObject);
        bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());
    }

    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> bind(String name, Object value) {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.bindings.put(name, value);
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">拼接Sql片段</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> appendSql(String sql) {
        </span><strong><span style="color: #0000ff;">this</span><span style="color: #000000;">.sqlBuilder.append(sql);
        </span><span style="color: #0000ff;">this</span>.sqlBuilder.append(" "</strong><span style="color: #000000;"><strong>);</strong>
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">得到sql字符串</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> String getSql() {
        </span><strong><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span></strong><span style="color: #000000;"><strong>.sqlBuilder.toString().trim();</strong>
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">继承HashMap</span>
    <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> ContextMap <span style="color: #0000ff;">extends</span> HashMap&lt;String, Object&gt;<span style="color: #000000;"> {

        </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> MetaObject parameterMetaObject;

        </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ContextMap(MetaObject parameterMetaObject) {
            </span><span style="color: #0000ff;">this</span>.parameterMetaObject =<span style="color: #000000;"> parameterMetaObject;
        }

        @Override
        </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Object get(Object key) {
            String strKey </span>=<span style="color: #000000;"> (String) key;
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 检查是否包含 strKey，若包含则直接返回</span>
            <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">super</span><span style="color: #000000;">.containsKey(strKey)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">super</span><span style="color: #000000;">.get(strKey);
            }

            </span><span style="color: #0000ff;">if</span> (parameterMetaObject != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 从运行时参数中查找结果，这里会在${name}解析时，通过name获取运行时参数值，替换掉${name}字符串</span>
                <span style="color: #0000ff;">return</span><span style="color: #000000;"> parameterMetaObject.getValue(strKey);
            }

            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 省略部分代码</span>
}</code></pre>

<p id="autoid-3-2-2"><strong>解析 SQL 片段</strong></p>
<p>接着我们来看看解析SQL片段的逻辑</p>
<src class="cnblogs_code">
<pre><code>rootSqlNode.apply(context);</code></pre>

<p>对于一个包含了 ${} 占位符，或 &lt;if&gt;、&lt;where&gt; 等标签的 SQL，在解析的过程中，会被分解成多个片段。每个片段都有对应的类型，每种类型的片段都有不同的解析逻辑。在源码中，片段这个概念等价于 sql 节点，即 SqlNode。</p>
<p>StaticTextSqlNode 用于存储静态文本，TextSqlNode 用于存储带有 ${} 占位符的文本，IfSqlNode 则用于存储 &lt;if&gt; 节点的内容。MixedSqlNode 内部维护了一个 SqlNode 集合，用于存储各种各样的 SqlNode。接下来，我将会对 MixedSqlNode 、StaticTextSqlNode、TextSqlNode、IfSqlNode、WhereSqlNode 以及 TrimSqlNode 等进行分析</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MixedSqlNode <span style="color: #0000ff;">implements</span><span style="color: #000000;"> SqlNode {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> List&lt;SqlNode&gt;<span style="color: #000000;"> contents;

    </span><span style="color: #0000ff;">public</span> MixedSqlNode(List&lt;SqlNode&gt;<span style="color: #000000;"> contents) {
        </span><span style="color: #0000ff;">this</span>.contents =<span style="color: #000000;"> contents;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> apply(DynamicContext context) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 遍历 SqlNode 集合</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;"> (SqlNode sqlNode : contents) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用 salNode 对象本身的 apply 方法解析 sql</span>
<span style="color: #000000;">            sqlNode.apply(context);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
}</span></code></pre>

<p>MixedSqlNode 可以看做是 SqlNode 实现类对象的容器，凡是实现了 SqlNode 接口的类都可以存储到 MixedSqlNode 中，包括它自己。MixedSqlNode 解析方法 apply 逻辑比较简单，即遍历 SqlNode 集合，并调用其他 SqlNode实现类对象的 apply 方法解析 sql。</p>
<p>StaticTextSqlNode</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> <strong>StaticTextSqlNode</strong> <span style="color: #0000ff;">implements</span><span style="color: #000000;"> SqlNode {

    </span><strong><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String text;

    </span></strong><span style="color: #0000ff;">public</span><span style="color: #000000;"> StaticTextSqlNode(String text) {
        </span><span style="color: #0000ff;">this</span>.text =<span style="color: #000000;"> text;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> apply(DynamicContext context) {
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;">直接拼接当前sql片段的文本到DynamicContext的sqlBuilder中</span>
<span style="color: #000000;">        context.appendSql(text);
        </span></strong><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
}</span></code></pre>

<p>StaticTextSqlNode 用于存储静态文本，直接将其存储的 SQL 的文本值拼接到 DynamicContext 的<strong>sqlBuilder</strong>中即可。下面分析一下 TextSqlNode。</p>
<p><span class="hljs-title">TextSqlNode </span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> TextSqlNode <span style="color: #0000ff;">implements</span><span style="color: #000000;"> SqlNode {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String text;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> Pattern injectionFilter;

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> apply(DynamicContext context) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 ${} 占位符解析器</span>
        GenericTokenParser parser = createParser(<span style="color: #0000ff;">new</span><span style="color: #000000;"> BindingTokenParser(context, injectionFilter));
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 解析 ${} 占位符，通过ONGL 从用户传入的参数中获取结果，替换text中的${} 占位符
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 并将解析结果的文本拼接到DynamicContext的sqlBuilder中</span>
<span style="color: #000000;">        context.appendSql(parser.parse(text));
        </span></strong><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> GenericTokenParser createParser(TokenHandler handler) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建占位符解析器</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> GenericTokenParser("${", "}"<span style="color: #000000;">, handler);
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> BindingTokenParser <span style="color: #0000ff;">implements</span><span style="color: #000000;"> TokenHandler {

        </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> DynamicContext context;
        </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Pattern injectionFilter;

        </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> BindingTokenParser(DynamicContext context, Pattern injectionFilter) {
            </span><span style="color: #0000ff;">this</span>.context =<span style="color: #000000;"> context;
            </span><span style="color: #0000ff;">this</span>.injectionFilter =<span style="color: #000000;"> injectionFilter;
        }

        @Override
        </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String handleToken(String content) {
            Object parameter </span>= context.getBindings().get("_parameter"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (parameter == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                context.getBindings().put(</span>"value", <span style="color: #0000ff;">null</span><span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (SimpleTypeRegistry.isSimpleType(parameter.getClass())) {
                context.getBindings().put(</span>"value"<span style="color: #000000;">, parameter);
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 通过 ONGL 从用户传入的参数中获取结果</span>
            Object value =<span style="color: #000000;"> OgnlCache.getValue(content, context.getBindings());
            String srtValue </span>= (value == <span style="color: #0000ff;">null</span> ? ""<span style="color: #000000;"> : String.valueOf(value));
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 通过正则表达式检测 srtValue 有效性</span>
<span style="color: #000000;">            checkInjection(srtValue);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> srtValue;
        }
    }
}</span></code></pre>

<p>GenericTokenParser 是一个通用的标记解析器，用于解析形如 ${name}，#{id} 等标记。此时是解析&nbsp;${name}的形式，从运行时参数的Map中获取到key为name的值，直接用运行时参数替换掉&nbsp;${name}字符串，将替换后的text字符串拼接到DynamicContext的sqlBuilder中</p>
<p>举个例子吧，比喻我们有如下SQL</p>
<src class="cnblogs_code">
<pre><code>SELECT * FROM user WHERE name = '${name}' and id= ${id}</code></pre>

<p>假如我们传的参数 Map中name值为 chenhao,id为1，那么该 SQL 最终会被解析成如下的结果：</p>
<src class="cnblogs_code">
<pre><code>SELECT * FROM user WHERE name = 'chenhao' and id= 1</code></pre>

<p>很明显这种直接拼接值很容易造成SQL注入，假如我们传入的参数为name值为 chenhao'; DROP TABLE user;#&nbsp; ，解析得到的结果为</p>
<src class="cnblogs_code">
<pre><code>SELECT * FROM user WHERE name = 'chenhao'; DROP TABLE user;#'</code></pre>

<p>由于传入的参数没有经过转义，最终导致了一条 SQL 被恶意参数拼接成了两条 SQL。这就是为什么我们不应该在 SQL 语句中是用 ${} 占位符，风险太大。接着我们来看看IfSqlNode</p>
<p>IfSqlNode</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> IfSqlNode <span style="color: #0000ff;">implements</span><span style="color: #000000;"> SqlNode {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> ExpressionEvaluator evaluator;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String test;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> SqlNode contents;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> IfSqlNode(SqlNode contents, String test) {
        </span><span style="color: #0000ff;">this</span>.test =<span style="color: #000000;"> test;
        </span><span style="color: #0000ff;">this</span>.contents =<span style="color: #000000;"> contents;
        </span><span style="color: #0000ff;">this</span>.evaluator = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ExpressionEvaluator();
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> apply(DynamicContext context) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 通过 ONGL 评估 test 表达式的结果</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (evaluator.evaluateBoolean(test, context.getBindings())) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 若 test 表达式中的条件成立，则调用其子节点节点的 apply 方法进行解析
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果是静态SQL节点，则会直接拼接到DynamicContext中</span>
<span style="color: #000000;">            contents.apply(context);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
}</span></code></pre>

<p>IfSqlNode 对应的是 &lt;if test='xxx'&gt; 节点，首先是通过 ONGL 检测 test 表达式是否为 true，如果为 true，则调用其子节点的 apply 方法继续进行解析。如果子节点是静态SQL节点，则子节点的文本值会直接拼接到DynamicContext中</p>
<p><span class="hljs-title" style="color: #000000;">好了，其他的SqlNode我就不一一分析了，大家有兴趣的可以去看看</span></p>
<p id="autoid-3-2-2"><strong>解析 #{} 占位符</strong></p>
<p>经过前面的解析，我们已经能从 DynamicContext 获取到完整的 SQL 语句了。但这并不意味着解析过程就结束了，因为当前的 SQL 语句中还有一种占位符没有处理，即 #{}。与 ${} 占位符的处理方式不同，MyBatis 并不会直接将 #{} 占位符替换为相应的参数值，而是将其替换成<strong>？</strong>。其解析是在如下代码中实现的</p>
<src class="cnblogs_code">
<pre><code>SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</code></pre>

<p>我们看到将前面解析过的sql字符串和运行时参数的Map作为参数，我们来看看parse方法</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt;<span style="color: #000000;"> additionalParameters) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 #{} 占位符处理器</span>
    ParameterMappingTokenHandler handler = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 #{} 占位符解析器</span>
    GenericTokenParser parser = <span style="color: #0000ff;">new</span> GenericTokenParser("#{", "}"<span style="color: #000000;">, handler);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 解析 #{} 占位符，并返回解析结果字符串</span>
  <strong>  String sql =<span style="color: #000000;"> parser.parse(originalSql);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 封装解析结果到 StaticSqlSource 中，并返回,因为所有的动态参数都已经解析了，可以封装成一个静态的SqlSource</span>
    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span></strong><span style="color: #000000;"><strong> StaticSqlSource(configuration, sql, handler.getParameterMappings());</strong>
}

</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String handleToken(String content) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取 content 的对应的 ParameterMapping</span>
<strong><span style="color: #000000;">    parameterMappings.add(buildParameterMapping(content));
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回 ?</span>
    <span style="color: #0000ff;">return</span> "?"</strong><span style="color: #000000;"><strong>;</strong>
}</span></code></pre>

<p>我们看到将Sql中的&nbsp;#{} 占位符替换成<strong>"?"，并且将对应的参数转化成ParameterMapping 对象</strong>，通过buildParameterMapping 完成,最后创建一个<strong>StaticSqlSource，</strong>将sql字符串和<strong>ParameterMappings为参数传入，返回这个<strong>StaticSqlSource</strong></strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span><span style="color: #000000;"> ParameterMapping buildParameterMapping(String content) {
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     * 将#{xxx} 占位符中的内容解析成 Map。
     *   #{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}
     *      上面占位符中的内容最终会被解析成如下的结果：
     *  {
     *      "property": "age",
     *      "typeHandler": "MyTypeHandler", 
     *      "jdbcType": "NUMERIC", 
     *      "javaType": "int"
     *  }
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    Map</span>&lt;String, String&gt; propertiesMap =<span style="color: #000000;"> parseParameterMapping(content);
    String property </span>= propertiesMap.get("property"<span style="color: #000000;">);
    Class</span>&lt;?&gt;<span style="color: #000000;"> propertyType;
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> metaParameters 为 DynamicContext 成员变量 bindings 的元信息对象</span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (metaParameters.hasGetter(property)) {
        propertyType </span>=<span style="color: #000000;"> metaParameters.getGetterType(property);
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     * parameterType 是运行时参数的类型。如果用户传入的是单个参数，比如 Employe 对象，此时 
     * parameterType 为 Employe.class。如果用户传入的多个参数，比如 [id = 1, author = "chenhao"]，
     * MyBatis 会使用 ParamMap 封装这些参数，此时 parameterType 为 ParamMap.class。
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (typeHandlerRegistry.hasTypeHandler(parameterType)) {
        propertyType </span>=<span style="color: #000000;"> parameterType;
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (JdbcType.CURSOR.name().equals(propertiesMap.get("jdbcType"<span style="color: #000000;">))) {
        propertyType </span>= java.sql.ResultSet.<span style="color: #0000ff;">class</span><span style="color: #000000;">;
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (property == <span style="color: #0000ff;">null</span> || Map.<span style="color: #0000ff;">class</span><span style="color: #000000;">.isAssignableFrom(parameterType)) {
        propertyType </span>= Object.<span style="color: #0000ff;">class</span><span style="color: #000000;">;
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">
         * 代码逻辑走到此分支中，表明 parameterType 是一个自定义的类，
         * 比如 Employe，此时为该类创建一个元信息对象
         </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        MetaClass metaClass </span>=<span style="color: #000000;"> MetaClass.forClass(parameterType, configuration.getReflectorFactory());
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 检测参数对象有没有与 property 想对应的 getter 方法</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (metaClass.hasGetter(property)) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取成员变量的类型</span>
            propertyType =<span style="color: #000000;"> metaClass.getGetterType(property);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            propertyType </span>= Object.<span style="color: #0000ff;">class</span><span style="color: #000000;">;
        }
    }
    
    ParameterMapping.Builder builder </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ParameterMapping.Builder(configuration, property, propertyType);
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 propertyType 赋值给 javaType</span>
    Class&lt;?&gt; javaType =<span style="color: #000000;"> propertyType;
    String typeHandlerAlias </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 遍历 propertiesMap</span>
    <span style="color: #0000ff;">for</span> (Map.Entry&lt;String, String&gt;<span style="color: #000000;"> entry : propertiesMap.entrySet()) {
        String name </span>=<span style="color: #000000;"> entry.getKey();
        String value </span>=<span style="color: #000000;"> entry.getValue();
        </span><span style="color: #0000ff;">if</span> ("javaType"<span style="color: #000000;">.equals(name)) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果用户明确配置了 javaType，则以用户的配置为准</span>
            javaType =<span style="color: #000000;"> resolveClass(value);
            builder.javaType(javaType);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("jdbcType"<span style="color: #000000;">.equals(name)) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 解析 jdbcType</span>
<span style="color: #000000;">            builder.jdbcType(resolveJdbcType(value));
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("mode"<span style="color: #000000;">.equals(name)) {...} 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("numericScale"<span style="color: #000000;">.equals(name)) {...} 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("resultMap"<span style="color: #000000;">.equals(name)) {...} 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("typeHandler"<span style="color: #000000;">.equals(name)) {
            typeHandlerAlias </span>=<span style="color: #000000;"> value;    
        } 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("jdbcTypeName"<span style="color: #000000;">.equals(name)) {...} 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("property"<span style="color: #000000;">.equals(name)) {...} 
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ("expression"<span style="color: #000000;">.equals(name)) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BuilderException("Expression based parameters are not supported yet"<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BuilderException("An invalid property '" + name + "' was found in mapping #{" +<span style="color: #000000;"> content
                </span>+ "}.  Valid properties are " +<span style="color: #000000;"> parameterProperties);
        }
    }
    </span><span style="color: #0000ff;">if</span> (typeHandlerAlias != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 构建 ParameterMapping 对象</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> builder.build();
}</span></code></pre>

<p>SQL 中的 #{name, ...} 占位符被替换成了问号 ?。#{name, ...} 也被解析成了一个 ParameterMapping 对象。我们再来看一下 StaticSqlSource 的创建过程。如下：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> StaticSqlSource <span style="color: #0000ff;">implements</span><span style="color: #000000;"> SqlSource {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String sql;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> List&lt;ParameterMapping&gt;<span style="color: #000000;"> parameterMappings;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> Configuration configuration;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> StaticSqlSource(Configuration configuration, String sql) {
        </span><span style="color: #0000ff;">this</span>(configuration, sql, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">public</span> StaticSqlSource(Configuration configuration, String sql, List&lt;ParameterMapping&gt;<span style="color: #000000;"> parameterMappings) {
        </span><span style="color: #0000ff;">this</span>.sql =<span style="color: #000000;"> sql;
        </span><span style="color: #0000ff;">this</span>.parameterMappings =<span style="color: #000000;"> parameterMappings;
        </span><span style="color: #0000ff;">this</span>.configuration =<span style="color: #000000;"> configuration;
    }

    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> BoundSql getBoundSql(Object parameterObject) {
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 BoundSql 对象</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span></strong><span style="color: #000000;"><strong> BoundSql(configuration, sql, parameterMappings, parameterObject);</strong>
    }
}</span></code></pre>

<p>最后我们通过创建的StaticSqlSource就可以获取BoundSql对象了，并传入运行时参数</p>
<src class="cnblogs_code">
<pre><code>BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</code></pre>

<p>也就是调用上面创建的StaticSqlSource 中的getBoundSql方法，这是简单的&nbsp;<strong>return new</strong><strong> BoundSql(configuration, sql, parameterMappings, parameterObject); </strong>，接着看看BoundSql</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> BoundSql {
    </span><strong><span style="color: #0000ff;">private</span><span style="color: #000000;"> String sql;
    </span><span style="color: #0000ff;">private</span> List&lt;ParameterMapping&gt;<span style="color: #000000;"> parameterMappings;
   </span></strong><strong><span style="color: #0000ff;">private</span><span style="color: #000000;"> Object parameterObject;
    </span></strong><span style="color: #0000ff;">private</span> Map&lt;String, Object&gt;<span style="color: #000000;"> additionalParameters;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> MetaObject metaParameters;

    </span><span style="color: #0000ff;">public</span> BoundSql(Configuration configuration, String sql, List&lt;ParameterMapping&gt;<span style="color: #000000;"> parameterMappings, Object parameterObject) {
        </span><span style="color: #0000ff;">this</span>.sql =<span style="color: #000000;"> sql;
        </span><span style="color: #0000ff;">this</span>.parameterMappings =<span style="color: #000000;"> parameterMappings;
        </span><span style="color: #0000ff;">this</span>.parameterObject =<span style="color: #000000;"> parameterObject;
        </span><span style="color: #0000ff;">this</span>.additionalParameters = <span style="color: #0000ff;">new</span><span style="color: #000000;"> HashMap();
        </span><span style="color: #0000ff;">this</span>.metaParameters = configuration.newMetaObject(<span style="color: #0000ff;">this</span><span style="color: #000000;">.additionalParameters);
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getSql() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.sql;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">略</span>
}</code></pre>

<p>我们看到只是做简单的赋值。BoundSql中包含了sql，#{}解析成的parameterMappings，还有运行时参数parameterObject。好了，SQL解析我们就介绍这么多。我们先回顾一下我们代码是从哪里开始的</p>
<p><strong>CachingExecutor</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">public</span> &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
</span><span style="color: #008080;">2</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 获取 BoundSql</span>
<span style="color: #008080;">3</span>     <strong>BoundSql boundSql =<span style="color: #000000;"> ms.getBoundSql(parameterObject);
</span></strong><span style="color: #008080;">4</span>    <span style="color: #008000;">//</span><span style="color: #008000;"> 创建 CacheKey</span>
<span style="color: #008080;">5</span>     CacheKey key =<span style="color: #000000;"> createCacheKey(ms, parameterObject, rowBounds, boundSql);
</span><span style="color: #008080;">6</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 调用重载方法</span>
<span style="color: #008080;">7</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"><strong> query</strong>(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
</span><span style="color: #008080;">8</span> }</code></pre>

<p>如上，我们刚才都是分析的第三行代码，获取到了<strong>BoundSql，</strong>CacheKey 和二级缓存有关，我们留在下一篇文章单独来讲，接着我们看第七行重载方法&nbsp;<strong>query</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 从 MappedStatement 中获取缓存</span>
    Cache cache =<span style="color: #000000;"> ms.getCache();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 若映射文件中未配置缓存或参照缓存，此时 cache = null</span>
    <span style="color: #0000ff;">if</span> (cache != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        flushCacheIfRequired(ms);
        </span><span style="color: #0000ff;">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            ensureNoOutParams(ms, boundSql);
            List</span>&lt;E&gt; list = (List&lt;E&gt;<span style="color: #000000;">) tcm.getObject(cache, key);
            </span><span style="color: #0000ff;">if</span> (list == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 若缓存未命中，则调用被装饰类的 query 方法，也就是SimpleExecutor的query方法</span>
                list = delegate.&lt;E&gt;<span style="color: #000000;">query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                tcm.putObject(cache, key, list); </span><span style="color: #008000;">//</span><span style="color: #008000;"> issue #578 and #116</span></strong>
<span style="color: #000000;">            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> list;
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用被装饰类的 query 方法,这里的delegate我们知道应该是SimpleExecutor</span>
    <span style="color: #0000ff;">return</span> delegate.&lt;E&gt;<span style="color: #000000;">query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}</span></code></pre>

<p>上面的代码涉及到了二级缓存，若二级缓存为空，或未命中，则调用被装饰类的 query 方法。被装饰类为SimpleExecutor，而SimpleExecutor继承BaseExecutor，那我们来看看&nbsp;BaseExecutor 的query方法</p>
<p><strong>BaseExecutor</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (closed) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> ExecutorException("Executor was closed."<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">if</span> (queryStack == 0 &amp;&amp;<span style="color: #000000;"> ms.isFlushCacheRequired()) {
        clearLocalCache();
    }
    List</span>&lt;E&gt;<span style="color: #000000;"> list;
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        queryStack</span>++<span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 从一级缓存中获取缓存项，一级缓存我们也下一篇文章单独讲</span>
        list = resultHandler == <span style="color: #0000ff;">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (list != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 一级缓存未命中，则从数据库中查询</span>
            list =</strong><span style="color: #000000;"><strong> queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</strong>
        }
    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
        queryStack</span>--<span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">if</span> (queryStack == 0<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (DeferredLoad deferredLoad : deferredLoads) {
            deferredLoad.load();
        }
        deferredLoads.clear();
        </span><span style="color: #0000ff;">if</span> (configuration.getLocalCacheScope() ==<span style="color: #000000;"> LocalCacheScope.STATEMENT) {
            clearLocalCache();
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> list;
}</span></code></pre>

<p>从一级缓存中查找查询结果。若缓存未命中，再向数据库进行查询。至此我们明白了一级二级缓存的大概思路，先从二级缓存中查找，若未命中二级缓存，再从一级缓存中查找，若未命中一级缓存，再从数据库查询数据，那我们来看看是怎么从数据库查询的</p>
<p><strong>BaseExecutor</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> &lt;E&gt; List&lt;E&gt;<span style="color: #000000;"> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds,
    ResultHandler resultHandler, CacheKey key, BoundSql boundSql) </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
    List</span>&lt;E&gt;<span style="color: #000000;"> list;
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 向缓存中存储一个占位符</span>
<span style="color: #000000;">    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 调用 doQuery 进行查询</span>
        list =</strong><span style="color: #000000;"><strong> doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</strong>
    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 移除占位符</span>
<span style="color: #000000;">        localCache.removeObject(key);
    }
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 缓存查询结果</span>
<span style="color: #000000;">    localCache.putObject(key, list);
    </span></strong><span style="color: #0000ff;">if</span> (ms.getStatementType() ==<span style="color: #000000;"> StatementType.CALLABLE) {
        localOutputParameterCache.putObject(key, parameter);
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> list;
}</span></code></pre>

<p>调用了<strong>doQuery</strong>方法进行查询，最后将查询结果放入一级缓存，我们来看看doQuery,在SimpleExecutor中</p>
<p><strong>SimpleExecutor</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
    Statement stmt </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        Configuration configuration </span>=<span style="color: #000000;"> ms.getConfiguration();
        </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 StatementHandler</span>
        StatementHandler handler =<span style="color: #000000;"> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 Statement</span>
        stmt =<span style="color: #000000;"> prepareStatement(handler, ms.getStatementLog());
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行查询操作</span>
        <span style="color: #0000ff;">return</span> handler.&lt;E&gt;</strong><span style="color: #000000;"><strong>query(stmt, resultHandler);</strong>
    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 关闭 Statement</span>
<span style="color: #000000;">        closeStatement(stmt);
    }
}</span></code></pre>

<p>我们先来看看第一步创建<strong>StatementHandler&nbsp;</strong></p>
<h3>创建StatementHandler&nbsp;</h3>
<p>StatementHandler有什么作用呢？通过这个对象获取Statement对象，然后填充运行时参数，最后调用query完成查询。我们来看看其创建过程</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span><span style="color: #000000;"> StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement,
    Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 创建具有路由功能的 StatementHandler</span>
    StatementHandler statementHandler = <span style="color: #0000ff;">new</span><span style="color: #000000;"> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    </span></strong><span style="color: #008000;">//</span><span style="color: #008000;"> 应用插件到 StatementHandler 上</span>
    statementHandler =<span style="color: #000000;"> (StatementHandler) interceptorChain.pluginAll(statementHandler);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> statementHandler;
}</span></code></pre>

<p>我们看看RoutingStatementHandler的构造方法</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> RoutingStatementHandler <span style="color: #0000ff;">implements</span><span style="color: #000000;"> StatementHandler {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> StatementHandler delegate;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds,
        ResultHandler resultHandler, BoundSql boundSql) {

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 根据 StatementType 创建不同的 StatementHandler </span>
        <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (ms.getStatementType()) {
            </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> STATEMENT:
                delegate </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><strong><span style="color: #0000ff;">case</span><span style="color: #000000;"> PREPARED:
                delegate </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span></strong><span style="color: #0000ff;">case</span><span style="color: #000000;"> CALLABLE:
                delegate </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> ExecutorException("Unknown statement type: " +<span style="color: #000000;"> ms.getStatementType());
        }
    }
    
}</span></code></pre>

<p>RoutingStatementHandler 的构造方法会根据 MappedStatement 中的 statementType 变量创建不同的 StatementHandler 实现类。那statementType 是什么呢？我们还要回顾一下MappedStatement 的创建过程</p>
<p><img src="./images/Mybaits 源码解析 （六）----- Select 语句的执行过程分析（上篇）0.png" alt="" /></p>
<p>&nbsp;</p>
<p>我们看到statementType&nbsp;的默认类型为<strong>PREPARED，这里将会创建</strong><strong>PreparedStatementHandler。</strong></p>
<p>接着我们看下面一行代码prepareStatement,</p>
<h3>创建 Statement</h3>
<p>创建&nbsp;Statement 在&nbsp;stmt = prepareStatement(handler, ms.getStatementLog()); 这句代码，那我们跟进去看看</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> Statement prepareStatement(StatementHandler handler, Log statementLog) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
    Statement stmt;
    </span><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 获取数据库连接</span>
    Connection connection =<span style="color: #000000;"> getConnection(statementLog);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建 Statement，</span>
    stmt =<span style="color: #000000;"> handler.prepare(connection, transaction.getTimeout());
  </span></strong><strong><span style="color: #008000;">//</span><span style="color: #008000;"> 为 Statement 设置参数</span>
<span style="color: #000000;">    handler.parameterize(stmt);
    </span></strong><span style="color: #0000ff;">return</span><span style="color: #000000;"> stmt;
}</span></code></pre>

<p>在上面的代码中我们终于看到了和jdbc相关的内容了，创建完<strong>Statement，最后就可以</strong><strong>执行查询操作了。</strong>由于篇幅的原因，我们留在下一篇文章再来详细讲解</p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>