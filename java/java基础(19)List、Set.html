<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(19)List、Set' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(19)List、Set</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11650493.html</div><br>
    <h1><!--[if !supportLists]-->1.&nbsp;<!--[endif]--><strong>List<span style="font-family: 宋体;">接口</span></strong></h1>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">我们掌握了</span>Collection<span style="font-family: 宋体;">接口的使用后，再来看看</span><span style="font-family: Calibri;">Collection</span><span style="font-family: 宋体;">接口中的子类，他们都具备那些特性呢？</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">接下来，我们一起学习</span>Collection<span style="font-family: 宋体;">中的常用几个子类（</span><span style="font-family: Calibri;">List</span><span style="font-family: 宋体;">集合、</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">集合）。</span></p>
<p>&nbsp;</p>
<h2><!--[if !supportLists]-->1.1&nbsp;<!--[endif]--><strong>List<span style="font-family: 华文楷体;">接口介绍</span></strong></h2>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">查阅</span>API<span style="font-family: 宋体;">，看</span><span style="font-family: Calibri;">List</span><span style="font-family: 宋体;">的介绍。有序的 </span><span style="font-family: Calibri;">collection</span><span style="font-family: 宋体;">（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。与 </span><span style="font-family: Calibri;">set </span><span style="font-family: 宋体;">不同，列表通常允许重复的元素。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">看完</span>API<span style="font-family: 宋体;">，我们总结一下：</span></p>
<p>&nbsp;</p>
<p>List<span style="font-family: 宋体;">接口：</span></p>
<p>&nbsp;</p>
<blockquote>
<p class="16"><span style="font-family: 宋体;">它是一个元素存取有序的集合。例如，存元素的顺序是</span>11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</p>
<p>&nbsp;</p>
<p class="16">它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</p>
<p>&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">集合中可以有重复的元素，通过元素的</span>equals方法，来比较是否为重复的元素。</p>
</blockquote>
<p>&nbsp;</p>
<p class="16">List接口的常用子类有：</p>
<p>&nbsp;</p>
<p class="16">　　ArrayList集合</p>
<p>&nbsp;</p>
<p class="16">　　LinkedList集合</p>
<h2><!--[if !supportLists]-->1.2&nbsp;<!--[endif]--><strong>List<span style="font-family: 华文楷体;">接口中常用的方法</span></strong></h2>
<p><strong><span style="font-family: 华文楷体;"><img src="./images/java基础(19)List、Set0.png" alt="" /></span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p class="16">增加元素方法</p>
<blockquote>
<p class="16">add(Object e)：向集合末尾处，添加指定的元素</p>
<p class="16">add(int index, Object e)：向集合指定索引处，添加指定的元素，原有元素依次后移</p>
</blockquote>
<p class="16">删除元素删除</p>
<blockquote>
<p class="16">remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素</p>
<p class="16">remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素</p>
</blockquote>
<p class="16">替换元素方法</p>
<blockquote>
<p class="16">set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素</p>
</blockquote>
<p class="16">查询元素方法</p>
<blockquote>
<p>get(int index)<span style="font-family: 宋体;">：获取指定索引处的元素，并返回该元素</span></p>
</blockquote>
<p>&nbsp;</p>
<p class="16">方法演示：</p>
<src class="cnblogs_code">
<pre><code>List&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
</span><span style="color: #008000;">//</span><span style="color: #008000;">1,添加元素。</span>
list.add("小红"<span style="color: #000000;">);
list.add(</span>"小梅"<span style="color: #000000;">);
list.add(</span>"小强"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">2,插入元素。插入元素前的集合["小红","小梅","小强"]</span>
list.add(1, "老王"); <span style="color: #008000;">//</span><span style="color: #008000;">插入元素后的集合["小红","老王","小梅","小强"]
</span><span style="color: #008000;">//</span><span style="color: #008000;">3,删除元素。</span>
list.remove(2);<span style="color: #008000;">//</span><span style="color: #008000;"> 删除元素后的集合["小红","老王","小强"]
</span><span style="color: #008000;">//</span><span style="color: #008000;">4,修改元素。</span>
list.set(1, "隔壁老王");<span style="color: #008000;">//</span><span style="color: #008000;"> 修改元素后的集合["小红","隔壁老王","小强"]</span>
<span style="color: #000000;">
Iterator</span>&lt;String&gt; it =<span style="color: #000000;"> list.iterator();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (it.hasNext()) {
    String str </span>=<span style="color: #000000;"> it.next();
    System.out.println(str);
}</span></code></pre>

<p><span style="font-family: 宋体;">由于</span>List<span style="font-family: 宋体;">集合拥有索引，因此</span><span style="font-family: Calibri;">List</span><span style="font-family: 宋体;">集合迭代方式除了使用迭代器之外，还可以使用索引进行迭代。</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; list.size(); i++<span style="color: #000000;">) {
    String str </span>=<span style="color: #000000;"> list.get(i);
    System.out.println(str);            
}</span></code></pre>

<p>&nbsp;</p>
<h3><!--[if !supportLists]-->1.2.1&nbsp;<!--[endif]--><strong>Iterator<span style="font-family: 黑体;">的并发修改异常</span></strong></h3>
<p><span style="font-family: 宋体;">在</span>list<span style="font-family: 宋体;">集合迭代元素中，对元素进行判断，一旦条件满足就添加一个新元素。代码如下</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> IteratorDemo {
</span><span style="color: #008000;">//</span><span style="color: #008000;">在list集合迭代元素中，对元素进行判断，一旦条件满足就添加一个新元素</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建List集合</span>
        List&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">给集合中添加元素</span>
        list.add("abc1"<span style="color: #000000;">);
        list.add(</span>"abc2"<span style="color: #000000;">);
        list.add(</span>"abc3"<span style="color: #000000;">);
        list.add(</span>"abc4"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">迭代集合，当有元素为"abc2"时，集合加入新元素"itcast"</span>
        Iterator&lt;String&gt; it =<span style="color: #000000;"> list.iterator();
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
            String str </span>=<span style="color: #000000;"> it.next();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">判断取出的元素是否是"abc2"，是就添加一个新元素</span>
            <span style="color: #0000ff;">if</span>("abc2"<span style="color: #000000;">.equals(str)){
                list.add(</span>"itcast");<span style="color: #008000;">//</span><span style="color: #008000;"> 该操作会导致程序出错</span>
<span style="color: #000000;">            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">打印容器中的元素</span>
<span style="color: #000000;">        System.out.println(list);
    }
}</span></code></pre>

<p>运行上述代码发生了错误&nbsp;java.util.ConcurrentModificationException这是什么原因呢？</p>
<p>在迭代过程中，使用了集合的方法对元素进行操作。导致迭代器并不知道集合中的变化，容易引发数据的不确定性。</p>
<p>并发修改异常解决办法：在迭代时，不要使用集合的方法操作元素。</p>
<p><span style="font-family: 宋体;">那么想要在迭代时对元素操作咋办？通过</span>ListIterator<span style="font-family: 宋体;">迭代器操作元素是可以的，</span><span style="font-family: Calibri;">ListIterator</span><span style="font-family: 宋体;">的出现，解决了使用</span><span style="font-family: Calibri;">Iterator</span><span style="font-family: 宋体;">迭代过程中可能会发生的错误情况。</span></p>
<h2>1.3&nbsp;<strong>List<span style="font-family: 华文楷体;">集合存储数据的结构</span></strong></h2>
<p>List<span style="font-family: 宋体;">接口下有很多个集合，它们存储元素所采用的结构方式是不同的，这样就导致了这些集合有它们各自的特点，供给我们在不同的环境下进行使用。数据存储的常用结构有：堆栈、队列、数组、链表。我们分别来了解一下：</span></p>
<p class="16">堆栈，采用该结构的集合，对元素的存取有如下的特点：</p>
<blockquote>
<p class="16">先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
<p class="16">栈的入口、出口的都是栈的顶端位置</p>
<p class="16">压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</p>
<p class="16">弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</p>
</blockquote>
<p><img src="./images/java基础(19)List、Set1.png" alt="" /></p>
<p class="16">队列，采用该结构的集合，对元素的存取有如下的特点：</p>
<blockquote>
<p class="16">先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，安检。排成一列，每个人依次检查，只有前面的人全部检查完毕后，才能排到当前的人进行检查。</p>
<p class="16">队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</p>
</blockquote>
<p><img src="./images/java基础(19)List、Set2.png" alt="" /></p>
<p class="16">数组，采用该结构的集合，对元素的存取有如下的特点：</p>
<blockquote>
<p class="16">查找元素快：通过索引，可以快速访问指定位置的元素</p>
<p class="16">增删元素慢：</p>
<p class="16"><strong>　　指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</p>
<p class="16"><strong>　　指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p>
</blockquote>
<p><img src="./images/java基础(19)List、Set3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;链表，采用该结构的集合，对元素的存取有如下的特点：</p>
<blockquote>
<p class="16">多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<p class="16">查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
<p class="16">增删元素快：</p>
<p class="16">　　增加元素：操作如左图，只需要修改连接下个元素的地址即可。</p>
<p class="16">　　删除元素：操作如右图，只需要修改连接下个元素的地址即可。</p>
</blockquote>
<p><img src="./images/java基础(19)List、Set4.png" alt="" /></p>
<h2><!--[if !supportLists]-->1.4&nbsp;<!--[endif]--><strong>ArrayList<span style="font-family: 华文楷体;">集合</span></strong></h2>
<p>ArrayList<span style="font-family: 宋体;">集合</span>数据存储的结构是数组结构。元素<span style="font-family: 宋体;">增删</span><span style="font-family: 宋体;">慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以</span>ArrayList<span style="font-family: 宋体;">是最常用的集合。</span></p>
<p><span style="font-family: 宋体;">许多程序员开发时非常随意地使用</span>ArrayList<span style="font-family: 宋体;">完成任何需求，并不严谨，这种用法是不提倡的。</span></p>
<h2><!--[if !supportLists]-->1.5&nbsp;<!--[endif]--><strong>LinkedList<span style="font-family: 华文楷体;">集合</span></strong></h2>
<p>&nbsp;</p>
<p>LinkedList<span style="font-family: 宋体;">集合</span><span style="font-family: 宋体;">数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而</span>LinkedList<span style="font-family: 宋体;">提供了大量首尾操作的方法。如下图</span></p>
<p><img src="./images/java基础(19)List、Set5.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>LinkedList<span style="font-family: 宋体;">是</span>List<span style="font-family: 宋体;">的子类，</span><span style="font-family: Calibri;">List</span><span style="font-family: 宋体;">中的方法</span><span style="font-family: Calibri;">LinkedList</span><span style="font-family: 宋体;">都是可以使用，这里就不做详细介绍，我们只需要了解</span><span style="font-family: Calibri;">LinkedList</span><span style="font-family: 宋体;">的特有方法即可。</span><span style="font-family: 宋体;">在开发时，</span>LinkedList<span style="font-family: 宋体;">集合也可以作为</span><span style="font-family: 宋体;">堆栈，队列的结构使用。</span></p>
<p><span style="font-family: 宋体;">方法演示：</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code>LinkedList&lt;String&gt; link = <span style="color: #0000ff;">new</span> LinkedList&lt;String&gt;<span style="color: #000000;">();
</span><span style="color: #008000;">//</span><span style="color: #008000;">添加元素</span>
link.addFirst("abc1"<span style="color: #000000;">);
link.addFirst(</span>"abc2"<span style="color: #000000;">);
link.addFirst(</span>"abc3"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">获取元素</span>
<span style="color: #000000;">System.out.println(link.getFirst());
System.out.println(link.getLast());
</span><span style="color: #008000;">//</span><span style="color: #008000;">删除元素</span>
<span style="color: #000000;">System.out.println(link.removeFirst());
System.out.println(link.removeLast());
        
</span><span style="color: #0000ff;">while</span>(!link.isEmpty()){ <span style="color: #008000;">//</span><span style="color: #008000;">判断集合是否为空</span>
    System.out.println(link.pop()); <span style="color: #008000;">//</span><span style="color: #008000;">弹出集合中的栈顶元素</span>
}</code></pre>

<h2><!--[if !supportLists]-->1.6&nbsp;<!--[endif]--><strong>Vector<span style="font-family: 华文楷体;">集合</span></strong></h2>
<p>Vector<span style="font-family: 宋体;">集合</span><span style="font-family: 宋体;">数据存储的结构是数组结构，为</span>JDK<span style="font-family: 宋体;">中最早提供的集合。</span><span style="font-family: Calibri;">Vector</span><span style="font-family: 宋体;">中提供了一个独特的取出方式，就是枚举</span><span style="font-family: Calibri;">Enumeration</span><span style="font-family: 宋体;">，它其实就是早期的迭代器。此接口</span><span style="font-family: Calibri;">Enumeration</span><span style="font-family: 宋体;">的功能与 </span><span style="font-family: Calibri;">Iterator </span><span style="font-family: 宋体;">接口的功能是类似的。</span>Vector<span style="font-family: 宋体;">集合已被</span>ArrayList<span style="font-family: 宋体;">替代</span><span style="font-family: 宋体;">。</span><span style="font-family: 宋体;">枚举</span>Enumeration<span style="font-family: 宋体;">已被迭代器</span><span style="font-family: Calibri;">Iterator</span><span style="font-family: 宋体;">替代。</span></p>
<p class="16">Vector常见的方法：</p>
<p><img src="./images/java基础(19)List、Set6.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Enumeration枚举常见的方法：</p>
<p><img src="./images/java基础(19)List、Set7.png" alt="" /></p>
<p class="16">Vector集合对ArrayList集合使用的对比</p>
<p><img src="./images/java基础(19)List、Set8.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>2. Set接口</h1>
<p><span style="font-family: 宋体;">学习</span>Collection<span style="font-family: 宋体;">接口时，记得</span><span style="font-family: Calibri;">Collection</span><span style="font-family: 宋体;">中可以存放重复元素，也可以不存放重复元素，那么我们知道</span><span style="font-family: Calibri;">List</span><span style="font-family: 宋体;">中是可以存放重复元素的。那么不重复元素给哪里存放呢？那就是</span><span style="font-family: Calibri;">Set</span><span style="font-family: 宋体;">接口，它里面的集合，所存储的元素就是不重复的。</span></p>
<h2><!--[if !supportLists]-->2.1&nbsp;<!--[endif]--><strong>Set<span style="font-family: 华文楷体;">接口介绍</span></strong></h2>
<p><span style="font-family: 宋体;">查阅</span>Set<span style="font-family: 宋体;">集合的</span><span style="font-family: Calibri;">API</span><span style="font-family: 宋体;">介绍，通过元素的</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法，来判断是否为重复元素。</span></p>
<h2><!--[if !supportLists]-->2.2&nbsp;<!--[endif]--><strong>HashSet<span style="font-family: 华文楷体;">集合介绍</span></strong></h2>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">查阅</span>HashSet<span style="font-family: 宋体;">集合的</span><span style="font-family: Calibri;">API</span><span style="font-family: 宋体;">介绍：</span><span style="font-family: 宋体;">此类实现</span>Set<span style="font-family: 宋体;">接口，由哈希表支持（实际上是一个 </span>HashMap集合<span style="font-family: 宋体;">）。</span>HashSet<span style="font-family: 宋体;">集合不能保证的迭代顺序与元素存储顺序相同</span>。</p>
<p>HashSet<span style="font-family: 宋体;">集合，采用哈希表结构存储数据，保证元素唯一性的方式依赖于：</span><span style="font-family: Calibri;">hashCode()</span><span style="font-family: 宋体;">与</span><span style="font-family: Calibri;">equals()</span><span style="font-family: 宋体;">方法。</span></p>
<h2><!--[if !supportLists]-->2.3&nbsp;<!--[endif]--><strong>HashSet<span style="font-family: 华文楷体;">集合存储数据的结构（哈希表）</span></strong></h2>
<p>什么是哈希表呢？</p>
<blockquote>
<p>哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。</p>
<p><span style="font-family: 宋体;">当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是</span>Object<span style="font-family: 宋体;">类中的</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">方法。由于任何对象都是</span><span style="font-family: Calibri;">Object</span><span style="font-family: 宋体;">类的子类，所以任何对象有拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">方法，算出对象在表中的存放位置，这里需要注意，如果两个对象</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法，比较这两个对象是不是同一个对象，如果</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法返回的是</span><span style="font-family: Calibri;">true</span><span style="font-family: 宋体;">，那么就不会把第二个对象存放在哈希表中，如果返回的是</span><span style="font-family: Calibri;">false</span><span style="font-family: 宋体;">，就会把这个值存放在哈希表中。</span></p>
<p><span style="font-family: 宋体;">总结：保证</span>HashSet<span style="font-family: 宋体;">集合元素的唯一，其实就是根据对象的</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法建立属于当前对象的比较方式。</span></p>
</blockquote>
<p class="16"><img src="./images/java基础(19)List、Set9.png" alt="" /></p>
<h2><!--[if !supportLists]-->2.4&nbsp;<strong>HashSet<span style="font-family: 华文楷体;">存储</span><span style="font-family: 'Times New Roman';">JavaAPI</span><span style="font-family: 华文楷体;">中的类型元素</span></strong></h2>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">给</span>HashSet<span style="font-family: 宋体;">中存储</span><span style="font-family: Calibri;">JavaAPI</span><span style="font-family: 宋体;">中提供的类型元素时，不需要重写元素的</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法，因为这两个方法，在</span><span style="font-family: Calibri;">JavaAPI</span><span style="font-family: 宋体;">的每个类中已经重写完毕，如</span><span style="font-family: Calibri;">String</span><span style="font-family: 宋体;">类、</span><span style="font-family: Calibri;">Integer</span><span style="font-family: 宋体;">类等。</span></p>
<p>&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">创建</span>HashSet集合，存储String对象。</p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> HashSetDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建HashSet对象</span>
        HashSet&lt;String&gt; hs = <span style="color: #0000ff;">new</span> HashSet&lt;String&gt;<span style="color: #000000;">();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">给集合中添加自定义对象</span>
        hs.add("zhangsan"<span style="color: #000000;">);
        hs.add(</span>"lisi"<span style="color: #000000;">);
        hs.add(</span>"wangwu"<span style="color: #000000;">);
        hs.add(</span>"zhangsan"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">取出集合中的每个元素</span>
        Iterator&lt;String&gt; it =<span style="color: #000000;"> hs.iterator();
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
            String s </span>=<span style="color: #000000;"> it.next();
            System.out.println(s);
        }
    }
}</span></code></pre>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<blockquote>
<p>wangwu</p>
<p>lisi</p>
<p>zhangsan</p>
</blockquote>
<h2><!--[if !supportLists]-->2.5&nbsp;<!--[endif]--><strong>HashSet<span style="font-family: 华文楷体;">存储自定义类型元素</span></strong></h2>
<p><span style="font-family: 宋体;">给</span>HashSet<span style="font-family: 宋体;">中存放自定义类型元素时，需要重写对象中的</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法，建立自己的比较方式，才能保证</span><span style="font-family: Calibri;">HashSet</span><span style="font-family: 宋体;">集合中的对象唯一</span></p>
<p class="16"><span style="font-family: 宋体;">创建自定义对象</span>Student</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Student {
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;
    </span><span style="color: #0000ff;">public</span> Student(String name, <span style="color: #0000ff;">int</span><span style="color: #000000;"> age) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">();
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setName(String name) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getAge() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> age;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setAge(<span style="color: #0000ff;">int</span><span style="color: #000000;"> age) {
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }
    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
        </span><span style="color: #0000ff;">return</span> "Student [name=" + name + ", age=" + age + "]"<span style="color: #000000;">;
    }
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> hashCode() {
        </span><span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span> prime = 31<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> result = 1<span style="color: #000000;">;
        result </span>= prime * result +<span style="color: #000000;"> age;
        result </span>= prime * result + ((name == <span style="color: #0000ff;">null</span>) ? 0<span style="color: #000000;"> : name.hashCode());
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
    }
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> equals(Object obj) {
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span> ==<span style="color: #000000;"> obj)
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span>(!(obj <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Student)){
            System.out.println(</span>"类型错误"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        Student other </span>=<span style="color: #000000;"> (Student) obj;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.age ==  other.age &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">.name.equals(other.name);
    }
}</span></code></pre>

<p class="16"><span style="font-family: 宋体;">创建</span>HashSet集合，存储Student对象。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> HashSetDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建HashSet对象</span>
        HashSet hs = <span style="color: #0000ff;">new</span><span style="color: #000000;"> HashSet();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">给集合中添加自定义对象</span>
        hs.add(<span style="color: #0000ff;">new</span> Student("zhangsan",21<span style="color: #000000;">));
        hs.add(</span><span style="color: #0000ff;">new</span> Student("lisi",22<span style="color: #000000;">));
        hs.add(</span><span style="color: #0000ff;">new</span> Student("wangwu",23<span style="color: #000000;">));
        hs.add(</span><span style="color: #0000ff;">new</span> Student("zhangsan",21<span style="color: #000000;">));
        </span><span style="color: #008000;">//</span><span style="color: #008000;">取出集合中的每个元素</span>
        Iterator it =<span style="color: #000000;"> hs.iterator();
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
            Student s </span>=<span style="color: #000000;"> (Student)it.next();
            System.out.println(s);
        }
    }
}</span></code></pre>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<blockquote>
<p>Student [name=lisi, age=22]</p>
<p>Student [name=zhangsan, age=21]</p>
<p>Student [name=wangwu, age=23]</p>
</blockquote>
<h2><!--[if !supportLists]-->2.6&nbsp;<!--[endif]--><strong>LinkedHashSet<span style="font-family: 华文楷体;">介绍</span></strong></h2>
<p><span style="font-family: 宋体;">我们知道</span>HashSet<span style="font-family: 宋体;">保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</span></p>
<p><span style="font-family: 宋体;">在</span>HashSet<span style="font-family: 宋体;">下面有一个子类</span><span style="font-family: Calibri;">LinkedHashSet</span><span style="font-family: 宋体;">，它是链表和哈希表组合的一个数据存储结构。</span></p>
<p>演示代码如下：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> LinkedHashSetDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Set</span>&lt;String&gt; set = <span style="color: #0000ff;">new</span> LinkedHashSet&lt;String&gt;<span style="color: #000000;">();
        set.add(</span>"bbb"<span style="color: #000000;">);
        set.add(</span>"aaa"<span style="color: #000000;">);
        set.add(</span>"abc"<span style="color: #000000;">);
        set.add(</span>"bbc"<span style="color: #000000;">);
Iterator it </span>=<span style="color: #000000;"> set.iterator();
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">输出结果如下，</span>LinkedHashSet<span style="font-family: 宋体;">集合保证元素的存入和取出的顺序：</span></p>
<blockquote>
<p>bbb</p>
<p>aaa</p>
<p>abc</p>
<p>bbc</p>
</blockquote>
<h1><!--[if !supportLists]-->3.&nbsp;<!--[endif]--><strong><span style="font-family: 宋体;">判断</span></strong>集合<strong><span style="font-family: 宋体;">元素唯一的原理</span></strong></h1>
<h2><!--[if !supportLists]-->3.1&nbsp;<!--[endif]--><strong>ArrayList<span style="font-family: 华文楷体;">的</span><span style="font-family: 'Times New Roman';">contains</span><span style="font-family: 华文楷体;">方法判断元素是否重复原理</span></strong></h2>
<p><img src="./images/java基础(19)List、Set10.png" alt="" /></p>
<p>ArrayList<span style="font-family: 宋体;">的</span><span style="font-family: Calibri;">contains</span><span style="font-family: 宋体;">方法会使用调用方法时，传入的元素的</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法依次与集合中的旧元素所比较，从而根据返回的布尔值判断是否有重复元素。此时，当</span><span style="font-family: Calibri;">ArrayList</span><span style="font-family: 宋体;">存放自定义类型时，由于自定义类型在未重写</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法前，判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素，需要重写元素的</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法。</span></p>
<h2><!--[if !supportLists]-->3.2&nbsp;<!--[endif]--><strong>HashSet<span style="font-family: 华文楷体;">的</span><span style="font-family: 'Times New Roman';">add/contains</span><span style="font-family: 华文楷体;">等方法判断元素是否重复原理</span></strong></h2>
<p><img src="./images/java基础(19)List、Set11.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Set<span style="font-family: 宋体;">集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。</span></p>
<p>HashSet<span style="font-family: 宋体;">集合由于是无序的，其判断唯一的依据是元素类型的</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">与</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法的返回结果。规则如下：</span></p>
<p><span style="font-family: 宋体;">先判断新元素与集合内已经有的旧元素的</span>HashCode<span style="font-family: 宋体;">值</span></p>
<blockquote>
<p class="16">如果不同，说明是不同元素，添加到集合。</p>
<p class="16"><span style="font-family: 宋体;">如果相同，再判断</span>equals比较结果。返回true则相同元素；返回false则不同元素，添加到集合。</p>
</blockquote>
<p><span style="font-family: 宋体;">所以，使用</span>HashSet<span style="font-family: 宋体;">存储自定义类型，如果没有重写该类的</span><span style="font-family: Calibri;">hashCode</span><span style="font-family: 宋体;">与</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法，则判断重复时，使用的是地址值，如果想通过内容比较元素是否相同，需要重写该元素类的</span><span style="font-family: Calibri;">hashcode</span><span style="font-family: 宋体;">与</span><span style="font-family: Calibri;">equals</span><span style="font-family: 宋体;">方法。</span></p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>