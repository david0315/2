<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java线程池ThreadPoolExecutor类使用详解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java线程池ThreadPoolExecutor类使用详解</center></div><div class='banquan'>原文出处:本文由博客园博主峰的季节提供。<br/>
原文连接:https://www.cnblogs.com/chdf/p/11585375.html</div><br>
    <h3><a href="#label1"><span style="font-family: courier new, courier;">一、Executors创建线程池</span></a></h3>
<h3><a href="#label2"><span style="font-family: courier new, courier;">二、ThreadPoolExecutor类</span></a></h3>
<h3><a href="#label3"><span style="font-family: courier new, courier;">三、ThreadPoolExecutor类扩展</span></a></h3>
<p><span style="font-family: courier new, courier;">&nbsp;</span></p>
<h3><span style="font-family: courier new, courier;"><a name="label1"></a>一、Executors创建线程池</span></h3>
<p><span style="font-family: courier new, courier;">　　Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可，如Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor()、Executors.newCachedThreadPool()等方法。<span style="color: #ff0000;">这些方法虽然便捷，但是也有其局限性，如：OOM，线程耗尽。</span></span></p>
<p><span style="font-family: courier new, courier;">　　<span style="color: #ff0000;">小程序使用这些便捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用ThreadPoolExecutor进行创建。</span>上述便捷方法的创建也是通过ThreadPoolExecutor实现的。</span></p>
<h3><span style="font-family: courier new, courier;"><a name="label2"></a>二、ThreadPoolExecutor类</span></h3>
<h4><span style="font-family: courier new, courier;">1、线程池工作顺序</span></h4>
<p><span style="font-family: courier new, courier;">　　<span style="font-family: times new roman, times;"><span style="font-family: courier new, courier;">线程池的工作顺序为：corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略。</span></span></span></p>
<p><span style="font-family: courier new, courier;"><span style="font-family: times new roman, times;"><span style="font-family: courier new, courier;">　　即：核心线程 -&gt; 任务队列 -&gt; 除核心线程外的其他线程 -&gt; 拒绝策略<br /></span></span></span></p>
<h4><span style="font-family: courier new, courier;">2、ThreadPoolExecutor构造函数</span></h4>
<p><span style="font-family: courier new, courier;">　　Executors中创建线程池的便捷方法，实际上是调用了ThreadPoolExecutor的构造方法，定时任务线程池便捷方法Executors.newScheduledThreadPool()内部使用的是ScheduledThreadPoolExecutor。</span></p>
<p><span style="font-family: courier new, courier;">　　ThreadPoolExecutor构造函数参数列表如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="font-family: courier new, courier;"><span style="color: #008080;">1</span> <span style="color: #0000ff;">public</span> ThreadPoolExecutor(<span style="color: #0000ff;">int</span> corePoolSize,                     <span style="color: #008000;">//</span><span style="color: #008000;">线程池核心线程数量</span>
<span style="color: #008080;">2</span>                           <span style="color: #0000ff;">int</span> maximumPoolSize,                  <span style="color: #008000;">//</span><span style="color: #008000;">线程池最大线程数量</span>
<span style="color: #008080;">3</span>                           <span style="color: #0000ff;">long</span> keepAliveTime,                   <span style="color: #008000;">//</span><span style="color: #008000;">超过corePooleSize的空闲线程的存活时长</span>
<span style="color: #008080;">4</span>                           TimeUnit unit,                        <span style="color: #008000;">//</span><span style="color: #008000;">空闲线程存活时长单位</span>
<span style="color: #008080;">5</span>                           BlockingQueue&lt;Runnable&gt; workQueue,    <span style="color: #008000;">//</span><span style="color: #008000;">任务的排队队列</span>
<span style="color: #008080;">6</span>                           ThreadFactory threadFactory,          <span style="color: #008000;">//</span><span style="color: #008000;">新线程的线程工厂</span>
<span style="color: #008080;">7</span>                           RejectedExecutionHandler handler)     <span style="color: #008000;">//</span><span style="color: #008000;">拒绝策略</span></span></code></pre>

<p><span style="font-family: courier new, courier;">　　比较容易出问题的参数有corePoolSize、maximumPoolSize、workQueue以及handler：</span></p>
<ul>
<li><span style="font-family: courier new, courier;">corePoolSize和maximumPoolSize设置不当会影响效率，甚至耗尽线程</span></li>
<li><span style="font-family: courier new, courier;">workQueue设置不当容易导致OOM</span></li>
<li><span style="font-family: courier new, courier;">handler设置不当会导致提交任务时抛出异常</span></li>
</ul>
<h4>3、<span style="font-family: courier new, courier;">workQueue任务队列</span></h4>
<p><span style="font-family: courier new, courier;">　　任务队列一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列。</span></p>
<ul>
<li><span style="font-family: courier new, courier;"><strong>直接任务队列</strong>：设置为SynchronousQueue队列。<span style="font-family: courier new, courier;">SynchronousQueue</span>是一个特殊的BlockingQueue，它没有容量，每执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒；反之，每一个删除操作也要等待对应的插入操作。</span></li>
</ul>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SynchronousQueueTest {
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> ExecutorService pool;
</span><span style="color: #008080;"> 4</span>     
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 6</span>         
<span style="color: #008080;"> 7</span>         <span style="color: #008000;">//</span><span style="color: #008000;">核心线程数设为1,最大线程数设为2,任务队列为SynchronousQueue,拒绝策略为AbortPolicy,直接抛出异常</span>
<span style="color: #008080;"> 8</span>         pool = <span style="color: #0000ff;">new</span> ThreadPoolExecutor(1, 2, 0, TimeUnit.SECONDS, <span style="color: #0000ff;">new</span> SynchronousQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(), <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadPoolExecutor.AbortPolicy());
</span><span style="color: #008080;"> 9</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i &lt; 3;i++<span style="color: #000000;">){
</span><span style="color: #008080;">10</span>             pool.execute(<span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadTask());
</span><span style="color: #008080;">11</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">13</span> <span style="color: #000000;">}
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> <span style="color: #0000ff;">class</span> ThreadTask <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{
</span><span style="color: #008080;">16</span>     
<span style="color: #008080;">17</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">19</span> <span style="color: #000000;">        System.out.println(Thread.currentThread().getName());
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">21</span> }</code></pre>

<p>　　执行结果如下：</p>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">pool-1-thread-2
pool-1-thread-1
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.aisino.threadPool.ThreadTask@2f0e140b rejected from java.util.concurrent.ThreadPoolExecutor@7440e464[Running, pool size = 2, active threads = 1, queued tasks = 0, completed tasks = 0]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	at com.aisino.threadPool.SynchronousQueueTest.main(SynchronousQueueTest.java:18)
</code></pre>

<p>&nbsp;　　<span style="font-family: courier new, courier;">由执行结果可知，当任务队列为SynchronousQueue，创建的线程数大于maximumPoolSize时，直接执行拒绝策略抛出异常。</span></p>
<p><span style="font-family: courier new, courier;">　　使用<span style="font-family: courier new, courier;">SynchronousQueue</span>队列时，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数小于maximumPoolSize，则尝试创建新的线程，如果达到maximumPoolSize设置的最大值，则根据设置的handler执行对应的拒绝策略。因此使用<span style="font-family: courier new, courier;">SynchronousQueue</span>队列时，任务不会被缓存起来，而是马上执行，在这种情况下，需要对程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易执行拒绝策略。</span></p>
<ul>
<li><span style="font-family: courier new, courier;"><strong>有界任务队列</strong>：可使用ArrayBlockingQueue实现，如下所示：</span></li>
</ul>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">ExecutorService pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
</code></pre>

<p>　　<span style="font-family: courier new, courier;">使用有界任务队列<span style="font-family: courier new, courier;">ArrayBlockingQueue</span>时，如果有新的任务需要执行，线程池会创建新的线程，直到创建的线程数量达到corePoolSize,之后新的任务会被加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize,则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界任务队列初始量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize及以下；反之，当任务队列已满时，则会以maximumPoolSize为最大线程数上限。</span></p>
<ul>
<li><span style="font-family: courier new, courier;"><strong>无界的任务队列</strong>：可使用LinkedBlockingQueue实现，如下所示：</span></li>
</ul>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">ExecutorService pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
</code></pre>

<p>&nbsp;　　<span style="font-family: courier new, courier;">使用无界任务队列LinkedBlockingQueue时，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是corePoolSize。在这种情况下maximumPoolSize参数是无效的，哪怕任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，线程数也不会再增加了。若后续有新的任务加入，则直接进入队列等待。使用这种任务队列模式时，要注意任务提交与处理之间的协调控制，不然会出现队列中的任务由于无法及时处理导致的一直增长，直到最后出现资源耗尽的问题。</span></p>
<ul>
<li><span style="font-family: courier new, courier;"><strong>优先任务队列</strong>：通过PriorityBlockingQueue实现，如下所示：</span></li>
</ul>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> PriorityBlockingQueueTest {
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> ExecutorService pool;
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 5</span>         
<span style="color: #008080;"> 6</span>         <span style="color: #008000;">//</span><span style="color: #008000;">使用优先任务队列</span>
<span style="color: #008080;"> 7</span>         pool = <span style="color: #0000ff;">new</span> ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, <span style="color: #0000ff;">new</span> PriorityBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(), <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadPoolExecutor.AbortPolicy());
</span><span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i &lt; 20;i++<span style="color: #000000;">){
</span><span style="color: #008080;"> 9</span>             pool.execute(<span style="color: #0000ff;">new</span><span style="color: #000000;"> PriorityThreadTask(i));
</span><span style="color: #008080;">10</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">12</span>     
<span style="color: #008080;">13</span> <span style="color: #000000;">}
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> <span style="color: #0000ff;">class</span> PriorityThreadTask <span style="color: #0000ff;">implements</span> Runnable, Comparable&lt;PriorityThreadTask&gt;<span style="color: #000000;">{
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> priority;
</span><span style="color: #008080;">18</span>     
<span style="color: #008080;">19</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getPriority(){
</span><span style="color: #008080;">20</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> priority;
</span><span style="color: #008080;">21</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">22</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setPriority(<span style="color: #0000ff;">int</span><span style="color: #000000;"> priority){
</span><span style="color: #008080;">23</span>         <span style="color: #0000ff;">this</span>.priority =<span style="color: #000000;"> priority;
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">25</span>     
<span style="color: #008080;">26</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> PriorityThreadTask(){}
</span><span style="color: #008080;">27</span>     
<span style="color: #008080;">28</span>     <span style="color: #0000ff;">public</span> PriorityThreadTask(<span style="color: #0000ff;">int</span><span style="color: #000000;"> priority){
</span><span style="color: #008080;">29</span>         <span style="color: #0000ff;">this</span>.priority =<span style="color: #000000;"> priority;
</span><span style="color: #008080;">30</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">31</span> 
<span style="color: #008080;">32</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">33</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">34</span>         
<span style="color: #008080;">35</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;">{
</span><span style="color: #008080;">36</span>             <span style="color: #008000;">//</span><span style="color: #008000;">让线程阻塞,使后续任务进入缓存队列</span>
<span style="color: #008080;">37</span>             Thread.sleep(1000<span style="color: #000000;">);
</span><span style="color: #008080;">38</span>             
<span style="color: #008080;">39</span>             System.out.println("priority:" + <span style="color: #0000ff;">this</span>.priority + ", ThreadName:" +<span style="color: #000000;"> Thread.currentThread().getName());
</span><span style="color: #008080;">40</span>         }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){
</span><span style="color: #008080;">41</span> <span style="color: #000000;">            e.printStackTrace();
</span><span style="color: #008080;">42</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">43</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">44</span> 
<span style="color: #008080;">45</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当前对象和其他对象作比较,当前优先级大就返回-1,当前优先级小就返回1,值越小优先级越高</span>
<span style="color: #008080;">46</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">47</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> compareTo(PriorityThreadTask o) {
</span><span style="color: #008080;">48</span>         <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.priority &gt; o.priority ? -1 : 1<span style="color: #000000;">;
</span><span style="color: #008080;">49</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">50</span> }</code></pre>

<p>　　<span style="font-family: courier new, courier;">执行结果如下：</span></p>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">priority:0, ThreadName:pool-1-thread-1
priority:19, ThreadName:pool-1-thread-1
priority:18, ThreadName:pool-1-thread-1
priority:17, ThreadName:pool-1-thread-1
priority:16, ThreadName:pool-1-thread-1
priority:15, ThreadName:pool-1-thread-1
priority:14, ThreadName:pool-1-thread-1
priority:13, ThreadName:pool-1-thread-1
priority:12, ThreadName:pool-1-thread-1
priority:11, ThreadName:pool-1-thread-1
priority:10, ThreadName:pool-1-thread-1
priority:9, ThreadName:pool-1-thread-1
priority:8, ThreadName:pool-1-thread-1
priority:7, ThreadName:pool-1-thread-1
priority:6, ThreadName:pool-1-thread-1
priority:5, ThreadName:pool-1-thread-1
priority:4, ThreadName:pool-1-thread-1
priority:3, ThreadName:pool-1-thread-1
priority:2, ThreadName:pool-1-thread-1
priority:1, ThreadName:pool-1-thread-1
</code></pre>

<p>&nbsp;　　<span style="font-family: courier new, courier;">由执行结果可看出，除了第一个任务直接创建线程执行外，其他的任务都被放入了优先任务队列PriorityBlockingQueue中，按优先级进行了重新排列执行，且线程池的线程数一直为corePoolSize,在本例中corePoolSize为1，即线程数一直为1。</span></p>
<p><span style="font-family: courier new, courier;">　　PriorityBlockingQueue其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数量也不会超过corePoolSize。其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</span></p>
<h4><span style="font-family: courier new, courier;">4、handler拒绝策略</span></h4>
<p><span style="font-family: courier new, courier;">　　在创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列。在创建有界任务队列模式下，当任务队列已满且线程池创建的线程数达到最大线程数时，需要指定ThreadPoolExecutor的RejectedExecutionHandler参数来处理线程池"超载"的情况。ThreadPoolExecutor自带的拒绝策略如下：</span></p>
<ul>
<li><span style="font-family: courier new, courier;">AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</span></li>
<li><span style="font-family: courier new, courier;">DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。使用此策略时，业务场景中需允许任务的丢失</span></li>
<li><span style="font-family: courier new, courier;">DiscardOldestPolicy策略：该策略会丢弃任务队列中最老的一个任务，即任务队列中最先被添加进去的、马上要被执行的任务，并尝试再次提交任务(重复此过程)</span></li>
<li><span style="font-family: courier new, courier;">CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行</span></li>
</ul>
<p>　　<span style="font-family: courier new, courier;">以上内置的拒绝策略均实现了RejectedExecutionHandler接口，也可自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略。示例代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;"> * 自定义拒绝策略
</span><span style="color: #008080;"> 3</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CustomRejectedExecutionHandlerTest {
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> ExecutorService pool;
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>         <span style="color: #008000;">//</span><span style="color: #008000;">自定义拒绝策略</span>
<span style="color: #008080;">11</span>         pool = <span style="color: #0000ff;">new</span> ThreadPoolExecutor(1, 2, 1000<span style="color: #000000;">, TimeUnit.MILLISECONDS,
</span><span style="color: #008080;">12</span>                 <span style="color: #0000ff;">new</span> ArrayBlockingQueue&lt;&gt;(5<span style="color: #000000;">),
</span><span style="color: #008080;">13</span> <span style="color: #000000;">                Executors.defaultThreadFactory(),
</span><span style="color: #008080;">14</span>                 <span style="color: #0000ff;">new</span><span style="color: #000000;"> RejectedExecutionHandler() {
</span><span style="color: #008080;">15</span> <span style="color: #000000;">                    @Override
</span><span style="color: #008080;">16</span>                     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
</span><span style="color: #008080;">17</span>                         System.out.println(r.toString() + " 执行了拒绝策略"<span style="color: #000000;">);
</span><span style="color: #008080;">18</span> <span style="color: #000000;">                    }
</span><span style="color: #008080;">19</span> <span style="color: #000000;">                });
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; 10; i++<span style="color: #000000;">) {
</span><span style="color: #008080;">22</span>             pool.execute(<span style="color: #0000ff;">new</span><span style="color: #000000;"> CustomRejectedExecutionHandlerThreadTask());
</span><span style="color: #008080;">23</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">25</span> <span style="color: #000000;">}
</span><span style="color: #008080;">26</span> 
<span style="color: #008080;">27</span> <span style="color: #0000ff;">class</span> CustomRejectedExecutionHandlerThreadTask <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable {
</span><span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">30</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">31</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
</span><span style="color: #008080;">32</span>             <span style="color: #008000;">//</span><span style="color: #008000;">让线程阻塞,使后续任务机进入缓存队列</span>
<span style="color: #008080;">33</span>             Thread.sleep(1000<span style="color: #000000;">);
</span><span style="color: #008080;">34</span>             System.out.println("线程名称:" +<span style="color: #000000;"> Thread.currentThread().getName());
</span><span style="color: #008080;">35</span>         } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
</span><span style="color: #008080;">36</span> <span style="color: #000000;">            e.printStackTrace();
</span><span style="color: #008080;">37</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">38</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">39</span> }</code></pre>

<p>　　执行结果如下：</p>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">com.aisino.threadPool.CustomRejectedExecutionHandlerThreadTask@3cd1a2f1 执行了拒绝策略
com.aisino.threadPool.CustomRejectedExecutionHandlerThreadTask@2f0e140b 执行了拒绝策略
com.aisino.threadPool.CustomRejectedExecutionHandlerThreadTask@7440e464 执行了拒绝策略
线程名称:pool-1-thread-2
线程名称:pool-1-thread-1
线程名称:pool-1-thread-2
线程名称:pool-1-thread-1
线程名称:pool-1-thread-2
线程名称:pool-1-thread-1
线程名称:pool-1-thread-2
</code></pre>

<p>&nbsp;　　<span style="font-family: courier new, courier;">由执行结果可看出，由于任务添加了休眠阻塞，执行任务需要花费一定时间，导致有一定数量的任务被丢弃，从而执行自定义的拒绝策略。</span></p>
<h4><span style="font-family: courier new, courier;">5、ThreadFactory自定义线程创建</span></h4>
<p><span style="font-family: courier new, courier;">　　线程池中的线程是通过ThreadPoolExecutor中的线程工厂ThreadFactory创建的。可自定义ThreadFactory对线程池中的线程进行一些特殊的设置(命名、设置优先级等)。示例代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CustomThreadFactoryTest {
</span><span style="color: #008080;"> 2</span>     
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> ExecutorService pool;
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 6</span>         <span style="color: #008000;">//</span><span style="color: #008000;">自定义线程工厂</span>
<span style="color: #008080;"> 7</span>         pool = <span style="color: #0000ff;">new</span> ThreadPoolExecutor(2, 4, 1000, TimeUnit.MILLISECONDS, <span style="color: #0000ff;">new</span> ArrayBlockingQueue&lt;&gt;(5), <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadFactory() {
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">            @Override
</span><span style="color: #008080;"> 9</span>             <span style="color: #0000ff;">public</span><span style="color: #000000;"> Thread newThread(Runnable r) {
</span><span style="color: #008080;">10</span>                 System.out.println("创建线程:" +<span style="color: #000000;"> r.hashCode());
</span><span style="color: #008080;">11</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">线程名称</span>
<span style="color: #008080;">12</span>                 Thread th = <span style="color: #0000ff;">new</span> Thread(r, "threadPool-" +<span style="color: #000000;"> r.hashCode());
</span><span style="color: #008080;">13</span>                 <span style="color: #0000ff;">return</span><span style="color: #000000;"> th;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">15</span>         }, <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadPoolExecutor.CallerRunsPolicy());
</span><span style="color: #008080;">16</span>         
<span style="color: #008080;">17</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i &lt; 10;i++<span style="color: #000000;">){
</span><span style="color: #008080;">18</span>             pool.execute(<span style="color: #0000ff;">new</span><span style="color: #000000;"> CustomThreadFactoryThreadTask());
</span><span style="color: #008080;">19</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">21</span> <span style="color: #000000;">}
</span><span style="color: #008080;">22</span> 
<span style="color: #008080;">23</span> <span style="color: #0000ff;">class</span> CustomThreadFactoryThreadTask <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{
</span><span style="color: #008080;">24</span>     
<span style="color: #008080;">25</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">26</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
</span><span style="color: #008080;">27</span>         <span style="color: #008000;">//</span><span style="color: #008000;">输出执行线程的名称</span>
<span style="color: #008080;">28</span>         System.out.println("线程名称:" +<span style="color: #000000;"> Thread.currentThread().getName());
</span><span style="color: #008080;">29</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">30</span> }</code></pre>

<p>　　执行结果如下：</p>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">创建线程:1259475182
创建线程:1300109446
创建线程:1020371697
线程名称:threadPool-1259475182
线程名称:threadPool-1300109446
线程名称:threadPool-1259475182
创建线程:789451787
线程名称:threadPool-1020371697
线程名称:threadPool-1259475182
线程名称:threadPool-1300109446
线程名称:threadPool-1259475182
线程名称:threadPool-1020371697
线程名称:threadPool-789451787
线程名称:threadPool-1300109446
</code></pre>

<p>&nbsp;　　<span style="font-family: courier new, courier;">由执行结果可看出，每个线程的创建都进行了记录输出与命名。</span></p>
<h4><span style="font-family: courier new, courier;">6、正确构造线程池</span></h4>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">int poolSize = Runtime.getRuntime().availableProcessors() * 2;
BlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;&gt;(512);
RejectedExecutionHandler policy = new ThreadPoolExecutor.DiscardPolicy();
executorService = new ThreadPoolExecutor(poolSize, poolSize, 0, TimeUnit.SECONDS, queue, policy);
</code></pre>

<p>&nbsp;</p>
<h3><span style="font-family: courier new, courier;"><a name="label3"></a>三、ThreadPoolExecutor类扩展</span></h3>
<p><span style="font-family: courier new, courier;">　　ThreadPoolExecutor类扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口。</span></p>
<ul>
<li><span style="font-family: courier new, courier;"><strong>beforeExecute</strong>:线程池中任务运行前执行</span></li>
<li><span style="font-family: courier new, courier;"><strong>afterExecute</strong>:线程池中任务运行完毕后执行</span></li>
<li><span style="font-family: courier new, courier;"><strong>terminated</strong>:线程池退出后执行</span></li>
</ul>
<p>　　<span style="font-family: courier new, courier;">通过这三个接口可以监控每个任务的开始时间和结束时间，或者其他功能。示例代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadPoolExecutorExtensionTest {
</span><span style="color: #008080;"> 2</span>     
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> ExecutorService pool;
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 6</span>         
<span style="color: #008080;"> 7</span>         <span style="color: #008000;">//</span><span style="color: #008000;">自定义线程,为线程重命名</span>
<span style="color: #008080;"> 8</span>         pool = <span style="color: #0000ff;">new</span> ThreadPoolExecutor(1, 4, 1000, TimeUnit.MILLISECONDS, <span style="color: #0000ff;">new</span> ArrayBlockingQueue&lt;&gt;(5), <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadFactory() {
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">            @Override
</span><span style="color: #008080;">10</span>             <span style="color: #0000ff;">public</span><span style="color: #000000;"> Thread newThread(Runnable r) {
</span><span style="color: #008080;">11</span>                 System.out.println("创建线程:" +<span style="color: #000000;"> r.hashCode());
</span><span style="color: #008080;">12</span>                 Thread th = <span style="color: #0000ff;">new</span> Thread(r, "ThreadPool-" +<span style="color: #000000;"> r.hashCode());
</span><span style="color: #008080;">13</span>                 <span style="color: #0000ff;">return</span><span style="color: #000000;"> th;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">15</span>         }, <span style="color: #0000ff;">new</span><span style="color: #000000;"> ThreadPoolExecutor.CallerRunsPolicy()){
</span><span style="color: #008080;">16</span>             
<span style="color: #008080;">17</span>             <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> beforeExecute(Thread t,Runnable r) {
</span><span style="color: #008080;">18</span>                 System.out.println("准备执行的任务名称："+<span style="color: #000000;"> ((ThreadPoolExecutorExtensionThreadTask)r).getTaskName());
</span><span style="color: #008080;">19</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span>             <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> afterExecute(Runnable r,Throwable t) {
</span><span style="color: #008080;">22</span>                 System.out.println("执行完毕的任务名称："+<span style="color: #000000;">((ThreadPoolExecutorExtensionThreadTask)r).getTaskName());
</span><span style="color: #008080;">23</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">24</span> 
<span style="color: #008080;">25</span>             <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> terminated() {
</span><span style="color: #008080;">26</span>                 System.out.println("线程池退出"<span style="color: #000000;">);
</span><span style="color: #008080;">27</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">28</span> <span style="color: #000000;">        };
</span><span style="color: #008080;">29</span>         
<span style="color: #008080;">30</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i &lt; 10;i++<span style="color: #000000;">){
</span><span style="color: #008080;">31</span>             pool.execute(<span style="color: #0000ff;">new</span> ThreadPoolExecutorExtensionThreadTask("Task-" +<span style="color: #000000;"> i));
</span><span style="color: #008080;">32</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">33</span> <span style="color: #000000;">        pool.shutdown();
</span><span style="color: #008080;">34</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">35</span> <span style="color: #000000;">}
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span> <span style="color: #0000ff;">class</span> ThreadPoolExecutorExtensionThreadTask <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{
</span><span style="color: #008080;">38</span>     
<span style="color: #008080;">39</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> String taskName;
</span><span style="color: #008080;">40</span>     
<span style="color: #008080;">41</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> String getTaskName(){
</span><span style="color: #008080;">42</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> taskName;
</span><span style="color: #008080;">43</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">44</span>     
<span style="color: #008080;">45</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setTaskName(String taskName){
</span><span style="color: #008080;">46</span>         <span style="color: #0000ff;">this</span>.taskName =<span style="color: #000000;"> taskName;
</span><span style="color: #008080;">47</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">48</span>     
<span style="color: #008080;">49</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> ThreadPoolExecutorExtensionThreadTask(){}
</span><span style="color: #008080;">50</span>     
<span style="color: #008080;">51</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> ThreadPoolExecutorExtensionThreadTask(String taskName){
</span><span style="color: #008080;">52</span>         <span style="color: #0000ff;">this</span>.taskName =<span style="color: #000000;"> taskName;
</span><span style="color: #008080;">53</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">54</span> 
<span style="color: #008080;">55</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">56</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;">57</span>         <span style="color: #008000;">//</span><span style="color: #008000;">输出任务名称以及对应的执行线程名称</span>
<span style="color: #008080;">58</span>         System.out.println("任务名称:" + <span style="color: #0000ff;">this</span>.taskName + ", 执行线程名称:" +<span style="color: #000000;"> Thread.currentThread().getName());
</span><span style="color: #008080;">59</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">60</span> }</code></pre>

<p>　　执行结果如下：</p>
<src class="cnblogs_Highlighter">
<pre class="brush:java;gutter:true;">创建线程:1259475182
创建线程:1300109446
创建线程:1020371697
准备执行的任务名称：Task-0
创建线程:789451787
任务名称:Task-0, 执行线程名称:ThreadPool-1259475182
准备执行的任务名称：Task-6
任务名称:Task-9, 执行线程名称:main
执行完毕的任务名称：Task-0
准备执行的任务名称：Task-7
准备执行的任务名称：Task-8
任务名称:Task-6, 执行线程名称:ThreadPool-1300109446
任务名称:Task-8, 执行线程名称:ThreadPool-789451787
执行完毕的任务名称：Task-8
准备执行的任务名称：Task-1
任务名称:Task-7, 执行线程名称:ThreadPool-1020371697
执行完毕的任务名称：Task-7
任务名称:Task-1, 执行线程名称:ThreadPool-1259475182
执行完毕的任务名称：Task-1
准备执行的任务名称：Task-2
任务名称:Task-2, 执行线程名称:ThreadPool-789451787
执行完毕的任务名称：Task-2
执行完毕的任务名称：Task-6
准备执行的任务名称：Task-5
任务名称:Task-5, 执行线程名称:ThreadPool-789451787
执行完毕的任务名称：Task-5
准备执行的任务名称：Task-4
准备执行的任务名称：Task-3
任务名称:Task-4, 执行线程名称:ThreadPool-1259475182
执行完毕的任务名称：Task-4
任务名称:Task-3, 执行线程名称:ThreadPool-1020371697
执行完毕的任务名称：Task-3
线程池退出
</code></pre>

<p>&nbsp;　　由执行结果可看出，<span style="font-family: courier new, courier;">通过对beforeExecute()、afterExecute()和terminated()的实现，可以对线程池中线程的状态进行监控，在线程执行前后输出了相关的打印信息。另外，使用shutdown()方法可以比较安全的关闭线程池，当线程池调用该方法后，线程池将不再接受后续添加的任务。但是，线程池不会立刻退出，而是等到添加到线程池中的任务都处理完成，才会退出。</span></p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>