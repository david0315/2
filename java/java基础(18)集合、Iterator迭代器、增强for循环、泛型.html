<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(18)集合、Iterator迭代器、增强for循环、泛型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(18)集合、Iterator迭代器、增强for循环、泛型</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11648863.html</div><br>
    <h1>1. 集合</h1>
<h2>1.1 集合介绍</h2>
<p> 集合，集合是java中提供的一种容器，可以用来存储多个数据。<br />     在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？</p>
<blockquote>
<p>数组的长度是固定的。集合的长度是可变的。<br />集合中存储的元素必须是引用类型数据</p>


</blockquote>
<h2>1.2 ArrayList集合存储元素</h2>
<p>练习一：ArrayList集合存储5个int类型元素</p>
<src class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
          ArrayList</span>&lt;Integer&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;Integer&gt;<span style="color: #000000;">();
          list.add(</span>111<span style="color: #000000;">);
          list.add(</span>111<span style="color: #000000;">);
          list.add(</span>111<span style="color: #000000;">);
          list.add(</span>111<span style="color: #000000;">);
          list.add(</span>111<span style="color: #000000;">);
          </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0; i&lt;list.size(); i++<span style="color: #000000;">){
                System.out.println(list.get(i));
         }              
}</span></code></pre>

<p>练习二：ArrayList集合存储5个Person类型元素</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
    ArrayList</span>&lt;Person&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;Person&gt;<span style="color: #000000;">();
    list.add(</span><span style="color: #0000ff;">new</span> Person("小强"<span style="color: #000000;">));
    list.add(</span><span style="color: #0000ff;">new</span> Person("老王"<span style="color: #000000;">));
    list.add(</span><span style="color: #0000ff;">new</span> Person("小虎"<span style="color: #000000;">));
    list.add(</span><span style="color: #0000ff;">new</span> Person("小明"<span style="color: #000000;">));
    list.add(</span><span style="color: #0000ff;">new</span> Person("小红"<span style="color: #000000;">));
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0; i&lt;list.size(); i++<span style="color: #000000;">){
        Person p </span>=<span style="color: #000000;"> list.get(i);
        System.out.println(p);
    }
}</span></code></pre>

<h2>1.3 集合的继承实现关系</h2>
<p> 查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。Collection接口为最顶层集合接口了。<br />     源代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span> List <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Collection {
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ArrayList <span style="color: #0000ff;">extends</span> AbstractList <span style="color: #0000ff;">implements</span><span style="color: #000000;"> List{
}</span></code></pre>

<p>这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。</p>
<blockquote>
<p>Collecton接口常用的子接口有：List接口、Set接口<br />List接口常用的子类有：ArrayList类、LinkedList类<br />Set接口常用的子类有：HashSet类、LinkedHashSet类</p>


</blockquote>
<p><img src="./images/java基础(18)集合、Iterator迭代器、增强for循环、泛型0.png" alt="" /></p>
<h2>1.4 Collection接口概述</h2>
<p>既然Collection接口是集合中的顶层接口，那么它定义的所有功能子类都可以使用。查阅API中描述的Collection接口。Collection层次结构中的根接口。Collection表示一组对象，这些对象也称为Collection的元素。一些Collection允许有重复的元素，而另外一些则不允许，一些Collection是有序的，而另外一些则是无序的。</p>
<p>继续查阅API，发现Collection接口中很多集合的操作方法，那么这些方法都具体能做什么呢？</p>
<h2>1.5&nbsp;Collection接口的基本方法</h2>
<p><img src="./images/java基础(18)集合、Iterator迭代器、增强for循环、泛型1.png" alt="" width="967" height="696" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;这里我们不关心具体创建的Collection中的那个子类对象，这里重点演示的是Collection接口中的方法。</p>
<p>创建集合的格式：</p>
<src class="cnblogs_code">
<pre><code>方式1：Collection&lt;元素类型&gt; 变量名 = <span style="color: #0000ff;">new</span> ArrayList&lt;元素类型&gt;<span style="color: #000000;">();
方式2：Collection  变量名 </span>= <span style="color: #0000ff;">new</span> ArrayList();</code></pre>

<p>方式1创建的集合，只能存储&lt;&gt;中指定的元素类型，该方式为常用方式。</p>
<p>方式2创建的集合，集合的元素类型默认为Object类型，即任何类型的元素都可以存储。</p>
<p>Collection接口方法</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组
 *  返回是一个存储对象的数组, 数组存储的数据类型是Object
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> function_2() {
        Collection</span>&lt;String&gt; coll = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
        coll.add(</span>"abc"<span style="color: #000000;">);
        coll.add(</span>"itcast"<span style="color: #000000;">);
        coll.add(</span>"itheima"<span style="color: #000000;">);
        coll.add(</span>"money"<span style="color: #000000;">);
        coll.add(</span>"123"<span style="color: #000000;">);
        
        Object[] objs </span>=<span style="color: #000000;"> coll.toArray();
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0 ; i &lt; objs.length ; i++<span style="color: #000000;">){
              System.out.println(objs[i]);
        }
}
      </span><span style="color: #008000;">/*</span><span style="color: #008000;">
       * 学习Java中三种长度表现形式
       *   数组.length 属性  返回值 int
       *   字符串.length() 方法,返回值int
       *   集合.size()方法, 返回值int
       </span><span style="color: #008000;">*/</span>
      
<span style="color: #008000;">/*</span><span style="color: #008000;">
 * Collection接口方法
 * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true
 * 方法参数是Object类型
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> function_1() {
        Collection</span>&lt;String&gt; coll = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
        coll.add(</span>"abc"<span style="color: #000000;">);
        coll.add(</span>"itcast"<span style="color: #000000;">);
        coll.add(</span>"itheima"<span style="color: #000000;">);
        coll.add(</span>"money"<span style="color: #000000;">);
        coll.add(</span>"123"<span style="color: #000000;">);
        
        </span><span style="color: #0000ff;">boolean</span> b = coll.contains("itcast"<span style="color: #000000;">);
        System.out.println(b);
}


</span><span style="color: #008000;">/*</span><span style="color: #008000;">
 * Collection接口的方法
 * void clear() 清空集合中的所有元素
 * 集合容器本身依然存在
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> function(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">接口多态的方式调用</span>
        Collection&lt;String&gt; coll = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
        coll.add(</span>"abc"<span style="color: #000000;">);
        coll.add(</span>"bcd"<span style="color: #000000;">);
        System.out.println(coll);
        
        coll.clear();
        
        System.out.println(coll);
        
      }
}

</span><span style="color: #008000;">/*</span><span style="color: #008000;">
 * Collection接口方法
 * boolean remove(Object o)移除集合中指定的元素
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> function_3(){
      Collection</span>&lt;String&gt; coll = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
      coll.add(</span>"abc"<span style="color: #000000;">);
      coll.add(</span>"money"<span style="color: #000000;">);
      coll.add(</span>"itcast"<span style="color: #000000;">);
      coll.add(</span>"itheima"<span style="color: #000000;">);
      coll.add(</span>"money"<span style="color: #000000;">);
      coll.add(</span>"123"<span style="color: #000000;">);  
      System.out.println(coll);
      
      </span><span style="color: #0000ff;">boolean</span> b = coll.remove("money"<span style="color: #000000;">);
      System.out.println(b);
      System.out.println(coll);
}</span></code></pre>

<h1>2. Iterator迭代器</h1>
<h2>2.1&nbsp;Iterator迭代器概述</h2>
<p>java中提供了很多个集合，它们在储存元素时，采用的储存方式不同。我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p>
<p><span style="color: #ff0000;">Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</span></p>
<p>集合中把这种元素的方式描述在Iterator接口中。Iterator接口的常用方法如下：</p>
<p><img src="./images/java基础(18)集合、Iterator迭代器、增强for循环、泛型2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>&nbsp;2.2&nbsp;Iterator迭代方式的代码体现</h2>
<p>在Collection接口描述了一个车厢方法iterator方法，所有Collection子类都实现了这个方法，并且有自己的迭代形式。</p>
<p><img src="./images/java基础(18)集合、Iterator迭代器、增强for循环、泛型3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;">1.创建集合对象</span>
          Collection&lt;String&gt; coll = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
          coll.add(</span>"abc1"<span style="color: #000000;">);
          coll.add(</span>"abc2"<span style="color: #000000;">);
          coll.add(</span>"abc3"<span style="color: #000000;">);
          coll.add(</span>"abc4"<span style="color: #000000;">);
        
          </span><span style="color: #008000;">//</span><span style="color: #008000;">2.获取容器的迭代器对象。通过iterator方法。</span>
          Iterator it =<span style="color: #000000;"> coll.iterator();
          
          </span><span style="color: #008000;">//</span><span style="color: #008000;">3.使用具体的迭代器对象获取集合中的元素</span>
          <span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
                   String s </span>=<span style="color: #000000;"> it.next();
                   System.out.println(s);
          }
          </span><span style="color: #008000;">/*<br /></span><span style="color: #008000;">           迭代器for循环形式的使用
           for(Iterator it = coll.iterator(); it.hasNext() ){
                  System.out.println(it.next());  
          }
          </span><span style="color: #008000;">*/</span><span style="color: #000000;">
 }    </span></code></pre>

<p>注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法,将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
<h2>2.3 集合元素的向下转型</h2>
<p>学习到这里，基本知道了Collection接口的简单使用。可是集合中可以存储任何对象，那么存放进去的数据都还是原来的类型吗？当然不是了，全部提升成了Object。</p>
<p>在使用集合时，我们需要注意以下几点：</p>
<blockquote>
<p>集合中存储其实都是对象的地址。</p>
<p>集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。因为出现了基本类型包装类，它提供了自动装箱操作(基本类型---&gt;对象)，这样，集合中的元素就是基本数值的包装类对象。</p>
<p>存储时提升了Object.取出时要使用元素的特有内容，必须向下转型。</p>
</blockquote>
<src class="cnblogs_code">
<pre><code>Collection coll = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
coll.add(</span>"abc"<span style="color: #000000;">);
coll.add(</span>"aabbcc"<span style="color: #000000;">);
coll.add(</span>"shitcast"<span style="color: #000000;">);
Iterator it </span>=<span style="color: #000000;"> coll.iterator();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (it.hasNext()) {
　　</span><span style="color: #008000;">//</span><span style="color: #008000;">由于元素被存放进集合后全部被提升为Object类型
　　</span><span style="color: #008000;">//</span><span style="color: #008000;">当需要使用子类对象特有方法时，需要向下转型</span>
　　String str =<span style="color: #000000;"> (String) it.next();
　　System.out.println(str.length());
}</span></code></pre>

<p>注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。</p>
<p><span style="color: #ff0000;">提示：Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。</span>代码演示如下：</p>
<src class="cnblogs_code">
<pre><code>Collection&lt;String&gt; coll = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
coll.add(</span>"abc"<span style="color: #000000;">);
coll.add(</span>"aabbcc"<span style="color: #000000;">);
coll.add(</span>"shitcast"<span style="color: #000000;">);
Iterator</span>&lt;String&gt; it =<span style="color: #000000;"> coll.iterator();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (it.hasNext()) {
     String str </span>=<span style="color: #000000;">  it.next(); 
     </span><span style="color: #008000;">//</span><span style="color: #008000;">当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span>
<span style="color: #000000;">     System.out.println(str.length());
}</span></code></pre>

<h1>3.&nbsp;增强for循环</h1>
<p>JDK1.5新特性,增强for循环<br />JDK1.5版本后,出现新的接口 java.lang.Iterable<br />Collection开是继承Iterable<br />Iterable作用,实现增强for循环<br /><br />格式:</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">for</span><span style="color: #000000;">( 数据类型 变量名 : 数组或者集合 ){
　　System.out.println(变量);
}</span></code></pre>

<p>增强for循环用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对元素进行增删操作。</p>
<p>遍历数组：</p>
<src class="cnblogs_code">
<pre><code>String[] str = {"abc","itcast","cn"<span style="color: #000000;">};
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(String s : str){//遍历s表示被遍历到的数组元素
     System.out.println(s.length());
}</span></code></pre>

<p>遍历集合：</p>
<src class="cnblogs_code">
<pre><code>ArrayList&lt;Person&gt; array = <span style="color: #0000ff;">new</span> ArrayList&lt;Person&gt;<span style="color: #000000;">();
array.add(</span><span style="color: #0000ff;">new</span> Person("a",20<span style="color: #000000;">));
array.add(</span><span style="color: #0000ff;">new</span> Person("b",10<span style="color: #000000;">));
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(Person p : array){
    System.out.println(p);</span><span style="color: #008000;">//</span><span style="color: #008000;"> System.out.println(p.toString());</span>
}</code></pre>

<p>好处: 代码少了,方便对容器遍历<br />弊端: 没有索引,不能操作容器里面的元素</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span>[] arr = {3,1,9,0<span style="color: #000000;">};
</span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i : arr){
    System.out.println(i</span>+1<span style="color: #000000;">);
}
System.out.println(arr[</span>0]);</code></pre>

<p>增强for循环和老式的for循环有什么区别？</p>
<p>注意：增强for循环必须有被遍历的目标。目标只能是Collection或者是数组。</p>
<p>建议：遍历数组时，如果仅为遍历，可以使用增强for；如果要都数组的元素进行操作，使用老式for循环可以通过索引操作</p>
<h1>4. 泛型</h1>
<h2>4.1 泛型的引入</h2>
<p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升为Object类型。当什么在取出每一个对象，并且进行对应的操作，这时必须采用类型转换。比如下面程序：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> GenericDemo {
      </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        　　List list </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
        　　list.add(</span>"abc"<span style="color: #000000;">);
        　　list.add(</span>"itcast"<span style="color: #000000;">);
        　　list.add(</span>5);<span style="color: #008000;">//</span><span style="color: #008000;">由于集合没有做任何限定，任何类型都可以给其中存放
            </span><span style="color: #008000;">//</span><span style="color: #008000;">相当于:Object obj=new Integer(5);</span>
<span style="color: #000000;">        
        　　Iterator it </span>=<span style="color: #000000;"> list.iterator();
        　　</span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
         　　　　 </span><span style="color: #008000;">//</span><span style="color: #008000;">需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span>
          　　　　String str = (String) it.next();<span style="color: #008000;">//</span><span style="color: #008000;">String str=(String)obj;
                 </span><span style="color: #008000;">//</span><span style="color: #008000;">编译时期仅检查语法错误,String是Object的儿子可以向下转型
                 </span><span style="color: #008000;">//</span><span style="color: #008000;">运行时期String str=(String)(new Integer(5))
                 </span><span style="color: #008000;">//</span><span style="color: #008000;">String与Integer没有父子关系所以转换失败
                 </span><span style="color: #008000;">//</span><span style="color: #008000;">程序在运行时发生了问题java.lang.ClassCastException</span>
<span style="color: #000000;">          　　　　System.out.println(str.length());
        }
      }
}</span></code></pre>

<pre><code>程序在运行时发生了问题java.lang.ClassCastException<br />为什么会发生类型转换异常呢？我们来分析下：<br />由于集合中什么类型的元素都可以存储。导致取出时，如果出现强转就会引发运行时ClassCastExceotion。<br />怎么来解决这个问题呢？使用集合时，必须明确集合中元素的类型。这种方式称为：泛型。</code></pre>
<h2>4.2 泛型的定义与使用</h2>
<p>我们在集合中会大量使用到泛型，这里来完整的学习泛型知识。</p>
<p>泛型，原来灵活的将数据类型应用到不同的类，方法、接口当中。将数据类型作为参数进行传递。</p>
<h3>4.2.1 含有泛型的类</h3>
<p><span style="color: #ff0000;">定义格式：修饰符 class 类名&lt;代表泛型的变量&gt; { }</span><br />      例如，API中的ArrayList集合：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> ArrayList&lt;E&gt;<span style="color: #000000;">{ 
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(E e){ }
    </span><span style="color: #0000ff;">public</span> E get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index){ }
}</span></code></pre>

<p><span style="color: #ff0000;">使用格式：创建对象时，确定泛型的类型</span><br />      例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();<br />      此时，变量E的值就是String类型</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> ArrayList&lt;String&gt;<span style="color: #000000;">{ 
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(String e){ }
    </span><span style="color: #0000ff;">public</span> String get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index){ }
}</span></code></pre>

<p>例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();<br />      此时，变量E的值就是Integer类型</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> ArrayList&lt;Integer&gt;<span style="color: #000000;">{ 
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(Integer e){ }
    </span><span style="color: #0000ff;">public</span> Integer get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index){ }
}</span></code></pre>

<h3>4.2.2 含有泛型的方法</h3>
<p><span style="color: #ff0000;">定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ }</span><br />例如，API中的ArrayList集合中的方法：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;T&gt;<span style="color: #000000;"> T[] toArray(T[] a){ } 
</span><span style="color: #008000;">//</span><span style="color: #008000;">该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组</span></code></pre>

<p>使用格式：调用方法时，确定泛型的类型<br />例如:</p>
<src class="cnblogs_code">
<pre><code>ArrayList&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
String[] arr </span>= <span style="color: #0000ff;">new</span> String[100<span style="color: #000000;">];
String[] result </span>= list.toArray(arr);</code></pre>

<p>此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;String&gt; String[] toArray(String[] a){ } </code></pre>

<p>例如:</p>
<src class="cnblogs_code">
<pre><code>ArrayList&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
Integer[] arr </span>= <span style="color: #0000ff;">new</span> Integer[100<span style="color: #000000;">];
Integer [] result </span>= list.toArray(arr);</code></pre>

<p>此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> &lt;Integer&gt; Integer[] toArray(Integer[] a){ }</code></pre>

<h3>4.2.3 含有泛型的接口</h3>
<p><span style="color: #ff0000;">定义格式：修饰符 interface 接口名&lt;代表泛型的变量&gt;{}</span></p>
<p>例如，API中的Iterator迭代器接口</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> List &lt;E&gt;<span style="color: #000000;">{
     public </span><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">E</span><span style="color: #000000;"> next();
}</span></code></pre>

<p>使用格式：</p>
<p>1、定义类时确定泛型的类型</p>
<p>例如：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public final</span> <span style="color: #0000ff;">class</span> Scanner implements Iterator&lt;String&gt;<span style="color: #000000;">{
     </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">String</span><span style="color: #000000;"> next(){}
}</span></code></pre>

<p>此时，变量E的值就是String类型。</p>
<p>2.始终不确定泛型的类型，直到创建对象时，确定泛型的类型</p>
<p>例如</p>
<src class="cnblogs_code">
<pre><code>ArrayList&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
Iterator</span>&lt;String&gt; it = list.iterator();</code></pre>

<p>&nbsp;</p>
<p>此时，变量E的值就是String类型。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> Iterator&lt;String&gt;<span style="color: #000000;">{
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span><span style="color: #000000;"> String next();      
}</span></code></pre>

<h2>4.3 使用泛型的好处</h2>
<p>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。<br />避免了类型强转的麻烦。<br />    演示下列代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> GenericDemo {
      </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
            List</span>&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
            list.add(</span>"abc"<span style="color: #000000;">);
            list.add(</span>"itcast"<span style="color: #000000;">);
            </span><span style="color: #008000;">//</span><span style="color: #008000;">list.add(5);</span><span style="color: #008000;">//</span><span style="color: #008000;">当集合明确类型后，存放类型不一致就会编译报错
             </span><span style="color: #008000;">//</span><span style="color: #008000;">集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span>
<span style="color: #000000;">       
            Iterator</span>&lt;String&gt; it =<span style="color: #000000;"> list.iterator();
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
                   String str </span>=<span style="color: #000000;"> it.next();
                   System.out.println(str.length()); </span><span style="color: #008000;">//</span><span style="color: #008000;">当使用Iterator&lt;String&gt;      
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span>
<span style="color: #000000;">            }
      }
}</span></code></pre>

<h2>4.4 泛型通配符</h2>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
      ArrayList</span>&lt;String&gt; array = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
      
      HashSet</span>&lt;Integer&gt; set = <span style="color: #0000ff;">new</span> HashSet&lt;Integer&gt;<span style="color: #000000;">();
      
      array.add(</span>"123"<span style="color: #000000;">);
      array.add(</span>"456"<span style="color: #000000;">);
      
      set.add(</span>789<span style="color: #000000;">);
      set.add(</span>890<span style="color: #000000;">);
      
      iterator(array);
      iterator(set);
}
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     *  定义方法,可以同时迭代2个集合
     *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet
     *  参数: 或者共同实现的接口
     *  泛型的通配,匹配所有的数据类型  ?
     </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> iterator(Collection&lt;?&gt;<span style="color: #000000;"> coll){
       Iterator</span>&lt;?&gt; it =<span style="color: #000000;"> coll.iterator();
       </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
             </span><span style="color: #008000;">//</span><span style="color: #008000;">it.next()获取的对象,什么类型</span>
<span style="color: #000000;">             System.out.println(it.next());
       }
}</span></code></pre>

<h2>4.5 泛型的限定</h2>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 *  将的酒店员工,厨师,服务员,经理,分别存储到3个集合中
 *  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法
</span><span style="color: #008000;"> */</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Iterator;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> GenericTest {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
     　　 </span><span style="color: #008000;">//</span><span style="color: #008000;">创建3个集合对象</span>
    　　  ArrayList&lt;ChuShi&gt; cs = <span style="color: #0000ff;">new</span> ArrayList&lt;ChuShi&gt;<span style="color: #000000;">();
   　　   ArrayList</span>&lt;FuWuYuan&gt; fwy = <span style="color: #0000ff;">new</span> ArrayList&lt;FuWuYuan&gt;<span style="color: #000000;">();
   　　   ArrayList</span>&lt;JingLi&gt; jl = <span style="color: #0000ff;">new</span> ArrayList&lt;JingLi&gt;<span style="color: #000000;">();
      
   　　   </span><span style="color: #008000;">//</span><span style="color: #008000;">每个集合存储自己的元素</span>
   　　   cs.add(<span style="color: #0000ff;">new</span> ChuShi("张三", "后厨001"<span style="color: #000000;">));
   　　   cs.add(</span><span style="color: #0000ff;">new</span> ChuShi("李四", "后厨002"<span style="color: #000000;">));
      
   　　   fwy.add(</span><span style="color: #0000ff;">new</span> FuWuYuan("翠花", "服务部001"<span style="color: #000000;">));
  　　    fwy.add(</span><span style="color: #0000ff;">new</span> FuWuYuan("酸菜", "服务部002"<span style="color: #000000;">));
      
    　　  jl.add(</span><span style="color: #0000ff;">new</span> JingLi("小名", "董事会001", 123456789.32<span style="color: #000000;">));
    　　  jl.add(</span><span style="color: #0000ff;">new</span> JingLi("小强", "董事会002", 123456789.33<span style="color: #000000;">));
      
</span><span style="color: #008000;">//</span><span style="color: #008000;">        ArrayList&lt;String&gt; arrayString = new ArrayList&lt;String&gt;();</span>
<span style="color: #000000;">      　　iterator(jl);
     　　 iterator(fwy);
     　　 iterator(cs);
    
    }
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work
     * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法
     * 强制转换:  it.next()=Object o ==&gt; Employee
     * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象
     * 泛型的限定  本案例,父类固定Employee,但是子类可以无限?
     *   ? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象
     *   ? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> iterator(ArrayList&lt;? <span style="color: #0000ff;">extends</span> Employee&gt;<span style="color: #000000;"> array){
      
       　　Iterator</span>&lt;? <span style="color: #0000ff;">extends</span> Employee&gt; it =<span style="color: #000000;"> array.iterator();
      　　 </span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext()){
        　  　 </span><span style="color: #008000;">//</span><span style="color: #008000;">获取出的next() 数据类型,是什么Employee</span>
        　　   Employee e =<span style="color: #000000;"> it.next();
               e.work();
           }
      }
}</span></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>