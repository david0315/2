<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java基础程序与面向对象' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java基础程序与面向对象</center></div><div class='banquan'>原文出处:本文由博客园博主唐古拉山之子提供。<br/>
原文连接:https://www.cnblogs.com/Tanggula-pioneer/p/11731895.html</div><br>
    <p style="margin-left: 60px;"><span style="color: #ff00ff;">首先，我们需要了解和知道一些Java的基本概念：</span></p>
<p style="margin-left: 60px;">　　程序编译过程：.java文件会通过编译器--被编译成一个. class字节码文件---再由虚拟机运行.class文件解释运行Java程序。</p>
<p style="margin-left: 60px;">　　编码规范：可以考虑遵循阿里巴巴的开发手册。</p>
<src style="margin-left: 60px;">　　类：作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。Java程序的基本单位
<src style="margin-left: 60px;">　　包：确保类名的唯一性。
<src style="margin-left: 30px;">&nbsp;　<span style="color: #ff00ff;">　其次了解编程的基础：</span>
<src style="margin-left: 60px;">
<src style="margin-left: 60px;">控制程序流程：
<src style="margin-left: 60px;">
<src style="margin-left: 60px;">&nbsp;　　选择结构语句：
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;　　 if语句：if(boolean表达式){&nbsp;语句1：真语句 }else{&nbsp;语句2：假语句 }
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 　　switch语句：switch（某个值）
<src style="margin-left: 60px;">　　　　　　　　　　case&nbsp;值：语句体； break；
<src style="margin-left: 60px;">　　　　　　　　　　case&nbsp;值： 语句体；break；
<src style="margin-left: 60px;">　　　　　　　　　　default&nbsp;值 ： 语句体；break；
<src style="margin-left: 60px;">　　　　　　<span style="color: #ff6600;">Case值可以为：char、byte、short、int、String、枚举常量等</span>
<src>&nbsp;
<src style="margin-left: 60px;">　　循环语句结构：
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 　　&nbsp; for(语句一；语句二；语句四){语句三}
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 　　&nbsp; while(boolean表达式){循环体}
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 　　do(boolean表达式)while(循环体)
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;　增强foreach循环：
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;　　格式：for(元素数据类型变量x :&nbsp;数组或者collection集合）{
<src style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; 　　使用变量即可，该变量就是元素;　
<src style="margin-left: 60px;">　　　　　　　}　　
<src style="margin-left: 60px;">&nbsp; &nbsp;　　 //&nbsp; &nbsp; 区别：for循环结束即注销/while循环结束可调用值作统计。
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 　　break&nbsp;中断循环&nbsp; &nbsp; &nbsp;
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;　　continue 跳过本次循环
<src style="margin-left: 60px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 　　return&nbsp; &nbsp; 返回值 结束方法，后面内容不编译//返回负数，值不存在


<src style="margin-left: 60px;">
<src>&nbsp;
<src style="margin-left: 60px;">
<src style="margin-left: 90px;">运算符：算术运算符：+ ，-， *， /， %，++(自增+1)， --(自减-1)&nbsp;
<src style="margin-left: 90px;">　　　　　　　　　　　&nbsp; -------字符+整型，先用ASCII码表算出字符在表中对应的整型，再相加，输出整型值。
<src style="margin-left: 90px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 赋值运算符：&nbsp; = 、+= 、-= 、*= 、/= 、%= &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
<src style="margin-left: 90px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 关系运算符：：&gt;、&lt;、&gt;=、&lt;=、==、!=
<src style="margin-left: 90px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 逻辑运算符：! 、&amp;、|、^、&amp;&amp;、||&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<src style="margin-left: 90px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　　　　单&amp;时，左边无论真假，右边都进行运算&nbsp; &nbsp;双&amp;&amp;有短路效果，当左边FALSE时，中断，右边不判断。
<src style="margin-left: 90px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 　　　　&amp;逻辑与：有false则false&nbsp; &nbsp;//&nbsp; &nbsp;| 逻辑或：有true则true&nbsp; //&nbsp; &nbsp; ^ 逻辑异或：相同为false，不同为true。
<src style="margin-left: 90px;">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;位运算符：&amp;("and")、|("or")、^("xor")、~("not")、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;&nbsp; &nbsp; &nbsp; &nbsp;---------------位运算，先把数据转换为二进制。&nbsp;


<src>&nbsp;<span style="color: #ff00ff;">　　了解Java的数据类型</span>
<src style="margin-left: 60px;">数据类型：4类8种【java语言强类型语言，定义分配了大小存取空间】
<src style="margin-left: 60px;">
<src><span>&nbsp;　　基本型&nbsp; &nbsp;整型【byte、short、int[默认值]、long】 1字节 2字节&nbsp; 4字节&nbsp; 8字节&nbsp; &nbsp; 且byte类型的取值范围在 -128~127</span>
<src><span>　　　　　　　　Java中整型的范围与运行Java代码的机器无关，且解决了程序移植问题。-------在C和C++中int和Long类型的大小与目标平台相关。</span>
<src><span>　　　　　　　　十六进制前缀加0x或者0X、二进制前加0b或者0B。</span>　　&nbsp;
<src>&nbsp;
<src><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 　&nbsp; 浮点型【double[默认值]、float】&nbsp; &nbsp; &nbsp; &nbsp; 8字节&nbsp; 4字节&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;------单精度浮点数加F/f</span>
<src><span>　　　　　　　　浮点数值不适合用于无法接受舍入误差的金融计算中，即System.out.printf(2.0-1.1)结果为0.8999999.</span>
<src><span>　　　　　　　　　　原因是：浮点数值采用二进制系统表示。而二进制系统无法准确的表示分数的1/10,就好比十进制无法精确的表示1/3---推荐使用BigDecimal类</span>
<src>　　　　
<src><span style="color: #ff6600;">　　　　　当整型和浮点型不能满足需求时，java.math包中提供了BigInteger 提供任意精度的整数运算-----BigDecimal 提供任意精度的浮点数运算。</span>
<src><span style="color: #ff6600;">　　　　　　　　这两个类可以处理任意长度数字序列的数值。使用静态方法ValueOf()方法能将普通数值转换为大数值，且不能用运算符处理大数据，有具体方法。　　　</span>　　
<src>&nbsp;
<src><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 　&nbsp; 字符型【char】&nbsp; 2字节&nbsp; &nbsp; --------表示Unicode编码的字符单元的字符类型&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>
<src><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 　&nbsp; 布尔型【boolean】&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1字节&nbsp; &nbsp; 两个值 FALSE 和&nbsp; TRUE&nbsp;</span>
<src><span><span>　　　　</span></span>
<src>
<src><span>变量的类型转换：&nbsp;&nbsp;自动转换：{byte，short，char-int-long-float-double&nbsp;从小到大转换}&nbsp;</span>
<src><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 　　{byte,short,char相互不转换，参与运算符首先转换为int类型}&nbsp; &nbsp; &nbsp; &nbsp; --</span>--- boolean不参加转换
<src><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　　　　　强制转换：{【二者不兼容】【目标类型范围小于源类型】}&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; --------大转小--损失精度</span>
<src><span>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;　　　　　　&nbsp;&nbsp;格式：目标类型&nbsp;变量名=(目标类型)&nbsp;值&nbsp; &nbsp;-----后期Object类型转换用得多</span>

<src>&nbsp;
<src>
<src>　　　　变量类型默认值： 引用类型的变量是默认值为 null&nbsp;， 数组引用类型的变量的默认值为 null，局部变量没有默认值，需手动初始化。

<src><span>引用型&nbsp; ：类【class】、接口【interface】、数组、枚举【enum】、注解【annotation】</span>
<src>　　
<src><span>　　String类型：不可变字符串，Unicode字符序列，Java没有内置的字符串类型，而是在标准的Java类库中提供了一个预定义类--String，用双引号扩起来。</span>
<src><span>　　　　　　字符串存在于方法区的常量池中，所有字符串共享</span>
<src><span>　　　　　　而当使用+运算符时，每创建一个新的字符串对象。</span>
<src><span>　　　　　　==只能比较字符串所在的位置是否相同，而equals比较两个字符串常量的值是否相等。</span>
<src>&nbsp;　　　　StringBuffer类：为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类，效率低，但采用多线程的方式执行添加和删除字符操作。
<src><span>　　　　StringBuilder类：作用相同，效率高。</span>
<src><span>　　　　<span style="color: #ff6600;">Java中引入字符常量池概念</span>：<span style="color: #ff6600;">即创建一个字符串时，首先会检查池中是否有值相同的字符串对象，如果有就直接返回引用，不会创建字符串对象；</span></span>
<src><span><span style="color: #ff6600;">　　　　　　　　如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串常量池的，而是直接在堆中创建新对象，也不会把对象放入池中</span>。</span>
<src>&nbsp;
<src><span>　　数组：一种数据结构，用来存储同一类型值的集合。初始化值为0或者null。</span>
<src><span>　　　　　　多维数组：就是一维数组的组合。 arr[行][列]。&nbsp;&nbsp; 数据类型[][]&nbsp;数组名 =&nbsp;new&nbsp;数据类型[][]{{元素...}{元素...}}；</span>
<src>
<src>　　　　　　数组遍历：【依次访问数组中的每个元素】
<src>&nbsp; &nbsp;　　　　　 数组排序：冒泡排序 //逆序、最值、排序、查索引值

<src>&nbsp;
<src>　　类(class):由类构造(construct)对象的过程称为创建类的实例(instance)。
<src>　　　　　　　　　　对象中的的数据称为实例域--属性，
<src>　　　　　　　　　　操作数据的过程称为方法---行为。
<src>　　　　　　　　　　对象的状态--对象保存着的当前特征信息--当施加那些方式时，对象如何响应？
<src>　　　　类之间的关系：
<src>　　　　　　　　依赖：("uses-a")：一个类的方法操控另一个类的对象。
<src>　　　　　　　　聚合：("has-a")：类A的对象包含类B的对象。
<src>　　　　　　　　继承：("is-a")：儿子与爸爸的关系--财产继承。
<src>&nbsp;　　　　构造器：【方法名和类名相同】
<src>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;　　【方法名前面没有返回值类型的声明】
<src>&nbsp;&nbsp;　　　　　　　&nbsp; 【在方法中不能使用return语句返回一个值】
<src>&nbsp;&nbsp;　　　　　　　&nbsp; 【this(....)调用本类的构造方法/super(.....)调用父类的构造方法 //必须出现在第一条语句上】
<src>&nbsp; &nbsp;　　　　　　　 【构造方法的重载，通常用public来修饰】
<src>　　　　
<src>　　　　方法：<span style="color: #99cc00;">修饰符 返回值类型 方法名(参数类型 参数名1....){&nbsp; 方法体语句；return 返回值；}</span>
<src>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 　　　　　　方法的重写：子类中出现和父类方法中一模一样的方法声明，也叫方法覆盖。//当子类需要父类的功能也要有自己的特有功能，可以考虑重写，权限不能低。
<src>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;　　　　　　方法的重载：一个程序中定义多个名称相同的方法，但是参数的类型和个数/顺序必须不同。与返回值无关。
<src>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;　　　　　　方法的递归：一个方法的内部调用自身的过程，且必须有结束条件。
<src>&nbsp;


<src>&nbsp;　　<img src="./images/Java基础程序与面向对象0.png" alt="" width="599" height="355" />
<src>　　　　　　
<src style="margin-left: 30px;">This关键字：代表本类中的对象引用，在方法中访问对象的其他成员。
<src style="margin-left: 30px;">　　在使用this调用类的构造方法应注意
<src style="margin-left: 30px;">　　　　【只能在构造方法中使用this调用其他构造方法，不能在成员方法中使用。】
<src style="margin-left: 30px;">　　　　【在构造方法中。使用this调用构造方法语句必须位于第一行，只能出现一次】
<src style="margin-left: 30px;">　　　　【不能在一个类的两个构造方法中使用this互相调用】
<src style="margin-left: 30px;">&nbsp;
<src style="margin-left: 30px;">super关键字：代表父类的对象引用，用于访问父类的成员。
<src style="margin-left: 30px;">　　【使用关键字super调用父类的成员变量和成员方法】super.成员变量/super.成员方法(参数)
<src style="margin-left: 30px;">　　【使用关键字调用父类的构造方法】super(参数)；
<src style="margin-left: 30px;">&nbsp;
<src style="margin-left: 30px;">Static关键字【状态修饰符】
<src style="margin-left: 30px;">　　Static关键字修饰类的成员。//类名.静态名
<src style="margin-left: 30px;">　　　　静态变量：静态变量被所有实例共享，都可以通过&ldquo;类名.变量名&rdquo;来访问。
<src style="margin-left: 30px;">　　　　静态方法：可以通过&ldquo;类名.方法名&rdquo;来访问。【静态方法只能访问static修饰的成员变量和方法】
<src style="margin-left: 30px;">　　　　静态代码块：只执行一次，通常使用静态代码块对类的成员变量初始化。
<src style="margin-left: 30px;">&nbsp;
<src style="margin-left: 30px;">Final关键字【状态修饰符】
<src style="margin-left: 30px;">　　修饰类、变量、方法。
<src style="margin-left: 30px;">　　　　【修饰的类不能被继承，不能派生子类】
<src style="margin-left: 30px;">　　　　【修饰的方法不能被子类重写，】
<src style="margin-left: 30px;">　　　　【修饰的变量是常量(自定义常量/字面值常量)】
<src style="margin-left: 30px;">&nbsp;

<src style="margin-left: 30px;">&nbsp;　　继承：【格式：子类extends父类】
<src style="margin-left: 30px;">&nbsp;　　　【单继承：一个类只能有一个直接父类】
<src style="margin-left: 30px;">&nbsp;　　　【多个类可以继承一个父类】
<src style="margin-left: 30px;">&nbsp;　　　【多层继承，继承爷爷类】
<src style="margin-left: 30px;">&nbsp;　　　【让类与类产生关系，是多态的前提】
<src style="margin-left: 30px;">&nbsp;　　　【弊端：类之间的耦合性增强】
<src style="margin-left: 30px;">继承的注意事项 :&nbsp;&nbsp;【子类中所有的构造方法都会默认先访问父类中无参的构造方法】
<src style="margin-left: 30px;">&nbsp; &nbsp;　　　　　　　 【父类没有无参构造方法？a.子类通过super去明确调用带参构造，b.通过this调用本身其他构造，但有一个一定会访问父类构造】&nbsp;&nbsp;
<src style="margin-left: 30px;">&nbsp;&nbsp; 　　　　　　　 【子类构造方法的首句默认为super();】
<src style="margin-left: 30px;">&nbsp;&nbsp; 　　　　　 　　【子类不能继承父类的构造方法，可以通过super关键字访问父类构造方法】
<src style="margin-left: 30px;">&nbsp;&nbsp; 　　　　 　　　【子类权限不能大于父类，成员变量名相同，采用就近原则】&nbsp;
<src style="margin-left: 30px;">&nbsp; &nbsp;　　　 　　　　【子类只能继承父类所有非私有的的成员(成员变量和成员方法)】
<src style="margin-left: 30px;">&nbsp; &nbsp;　　 　　　　　【重写父类方法：具有相同的方法名、参数列表以及返回值类型。】&nbsp;
<src style="margin-left: 30px;">
<src style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;　 　　　　【子类调用父子类同名的方法或变量，默认先调用子类的方法或变量】
<src>&nbsp;
<src>多态:&nbsp;同一个对象在不同时刻体现出来的不同状态。
<src>
<src style="margin-left: 30px;">　　　　前提：【要有继承或实现关系】
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;　　　　&nbsp;【要有方法重写】
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 　　　　【要有父类或父类接口引用指向子类对象 //父类&nbsp;标识符&nbsp;=&nbsp;new&nbsp;子类()】
<src style="margin-left: 30px;">　　具体类多态【class Fu{ }&nbsp; &nbsp;class Zi extends Fu{ }&nbsp; &nbsp; Fu f = new Zi()】
<src style="margin-left: 30px;">　　抽象类多态【abstract class Fu{ }&nbsp; &nbsp;class Zi extends Fu{ }&nbsp; &nbsp; Fu f = new Zi()】
<src style="margin-left: 30px;">　　接口类多态【interface Fu{ }&nbsp; &nbsp;class Zi&nbsp;implementsFu{ }&nbsp; &nbsp; &nbsp;Fu f = new Zi()】
<src style="margin-left: 30px;">　　　　多态中成员访问特点【成员变量&nbsp; &nbsp;编译看左边 ，&nbsp;运行看左边】
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;　　　　&nbsp; 【构造方法&nbsp; 子类的构造方法都会默认访问父类的构造方法，对父类数据进行初始化】
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 　　　　&nbsp;&nbsp;【成员方法 &nbsp; 编译看左边 ，&nbsp;运行看右边//方法存在覆盖重写】
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 　　　　&nbsp;&nbsp;【静态方法 &nbsp; 编译看左边 ，&nbsp;运行看左边//静态随类加载，不做改变】
<src style="margin-left: 30px;">　　对象中转型问题[多态中]
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;　　　　【向下转型】把父类的引用强制转换为子类的引用。子类&nbsp; z = (子类) f ;//该f&nbsp;是能转换为子类的
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;　　　　【向上转型】F类&nbsp; f = new&nbsp;子类();
<src style="margin-left: 30px;">　　同一个方法中，这种由于参数型不同的而导致执行效果各异。
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;　　　　允许使用一个父类类型的变量来引用一个子类类型的对象。



<src style="margin-left: 30px;">&nbsp;
<src style="margin-left: 30px;">抽象:用abstract关键字修饰，把不具有具体的功能成为抽象的功能。
<src style="margin-left: 30px;">　　抽象方法：【格式：public abstract&nbsp;void&nbsp;方法名()】定义方法时没有方法体，不包含方法体的方法为抽象方法，】
<src style="margin-left: 30px;">　　抽象类：【格式：&nbsp;abstract&nbsp;class&nbsp;类名()】包含抽象方法的类必须声明抽象类，但抽象类可以不包含抽象方法。】
<src style="margin-left: 30px;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;　　【抽象类不可以被实例化，抽象方法没有方法体则不能被调用】
<src style="margin-left: 30px;">抽象类的子类：&nbsp; &nbsp; &nbsp;&nbsp;
<src style="margin-left: 30px;">　　　　【重写所有的抽象方法，这个时候子类是个具体的类】
<src style="margin-left: 30px;">　　　　【如果不想重写所有的抽象方法，该子类必须为抽象类】
<src style="margin-left: 30px;">　　　　【通过多态的方式实现实例化】
<src style="margin-left: 30px;">&nbsp;
<src style="margin-left: 30px;">以上内容若有错误，大家多多指正。
<src style="margin-left: 30px;">&nbsp;



</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>