<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java学习笔记（3）--- 内部类,基本数据类型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java学习笔记（3）--- 内部类,基本数据类型</center></div><div class='banquan'>原文出处:本文由博客园博主Parachute黑喵提供。<br/>
原文连接:https://www.cnblogs.com/cptCarlvon/p/11935946.html</div><br>
    <h3>1.内部类（nested classes）：</h3>
<p><span style="font-family: 黑体; font-size: 15px;">&nbsp;</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">a.定义：</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">内部类其实就是一个类中还包含着另外一个类，如同一个<span style="color: #0000ff;">人（外部类</span>）是由大脑、肢体、器官等身体结果组成，而<span style="color: #0000ff;">内部类</span>相当于其中的某个<span style="color: #0000ff;">器官</span>之一，例如心脏：它也有<span style="color: #0000ff;">自己的属性和行为</span>（血液、跳动）。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">假如我们有个外部类叫做 out ,一个内部类叫做 in. 我们这么去调用：</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;"><strong>Out.In in = new Out().new In();</strong></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">内部类其实严重破坏了良好的代码结构，但为什么还要使用内部类呢？</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">因为内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这也是内部类的唯一优点。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">如同心脏可以直接访问身体的血液，而不是通过医生来抽血。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">程序编译过后会产生两个 .class 文件，分别是 Out.class 和 Out$In.class。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 15px; font-family: 黑体;">b.静态内部类：</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">可以看到，如果用 static 将内部内静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">其次，因为内部类被静态化，因此 Out.In 可以当做一个整体看，可以直接 new 出内部类的对象（通过类名访问 static，生不生成外部类对象都没关系）</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">c.私有内部类：</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">如果一个内部类只希望被外部类中的方法操作，那么可以使用 private 声明内部类。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">上面的代码中，我们必须在 Out 类里面生成 In 类的对象进行操作，而无法再使用&nbsp;<span class="marked">Out.In in = new Out().new In()&nbsp;生成内部类的对象。</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;">也就是说，此时的内部类只有外部类可控制。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">如同是，我的心脏只能由我的身体控制，其他人无法直接访问它。</span></p>
<h3><span style="font-family: 黑体; font-size: 15px;">&nbsp;</span></h3>
<p>&nbsp;</p>
<h3>&nbsp;2.基本数据类型：</h3>
<p><span style="font-family: 黑体; font-size: 15px;">a.byte:</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">byte 数据类型是8位、有符号的，以二进制补码表示的整数；</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；s</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">b.short:</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">short 数据类型是 16 位、有符号的以二进制补码表示的整数.</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">c.int:</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">int 数据类型是32位、有符号的以二进制补码表示的整数；</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">一般地整型变量默认为 int 类型；</span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000; font-family: 黑体; font-size: 15px;">sub:在java的世界里，如果比int类型小的类型(比如short和byte)做运算，java在编译的时候就会将它们统一强转成int类型。当是比int类型大的类型做运算，就会自动转换成它们中最大类型那个。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">&nbsp;</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">d.long:</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">long 数据类型是 64 位、有符号的以二进制补码表示的整数；</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">这种类型主要使用在需要比较大整数的系统上.</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">默认值为 0L</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">注意就是最好后面加上&ldquo;L&rdquo;，因为这样不容易报错，也可以用小写但是容易看错所以不推荐。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">e.float：</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">float 在储存大型浮点数组的时候可节省内存空间；</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">默认值是&nbsp;<span class="marked">0.0f；</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">浮点数不能用来表示精确的值,原则上不能进行浮点数之间的对比，因为会造成精度丢失所以对比结果不准确。</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">可用其他方法绕开：<a href="https://www.jianshu.com/p/4679618fd28c">https://www.jianshu.com/p/4679618fd28c</a></span></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">f.double:</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">浮点数的默认类型为double类型；</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">默认值是&nbsp;<span class="marked">0.0d；</span></span></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">跟float一样，对比和表示精确的值时候都会造成不准确。</span></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">g.boolean:</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">只能进行true/false</span></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">h.char:</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">char类型是一个单一的 16 位 Unicode 字符；</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">char 数据类型可以储存任何字符；</span></span></p>
<p>&nbsp;</p>
<p>i.常量</p>
<p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量：</p>
<p>&nbsp;</p>
<p><strong>final double PI = 3.1415927;</strong></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">j.引用变量：</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。它的值是指向内存空间的引用，就是地址，所指向的内存中保存着变量所表示的一个值或一组值。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px; color: #0000ff;">数据类型转换：</span></p>
<p><span style="font-family: 黑体; font-size: 15px; color: #0000ff;">整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。</span></p>
<p><span style="font-family: 黑体; font-size: 15px; color: #0000ff;">自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</span></p>
<p><span style="font-family: 黑体; font-size: 15px; color: #0000ff;">&nbsp;也可以强制转换，条件是转换的数据类型必须是兼容的。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;引用：</p>
<p><a href="https://www.runoob.com/w3cnote/java-inner-class-summary.html">https://www.runoob.com/w3cnote/java-inner-class-summary.html</a></p>
<p><a href="https://www.jianshu.com/p/4679618fd28c">https://www.jianshu.com/p/4679618fd28c</a></p>
<p><a href="https://www.cnblogs.com/cptCarlvon/p/11935946.html">https://www.cnblogs.com/cptCarlvon/p/11935946.html</a></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>