<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修oop面向对象【接口、多态】' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>oop面向对象【接口、多态】</center></div><div class='banquan'>原文出处:本文由博客园博主佩奇er提供。<br/>
原文连接:https://www.cnblogs.com/hxun/p/11725592.html</div><br>
    <p>&nbsp;<strong><span style="font-family: 宋体;">今日内容</span></strong></p>
<p><span style="font-family: 宋体;">1.接口</span></p>
<p><span style="font-family: 宋体;">2.三大特征</span>&mdash;&mdash;<span style="font-family: 宋体;">多态</span></p>
<p><span style="font-family: 宋体;">3.引用类型转换</span></p>
<p><strong><span style="font-family: 宋体;">教学目标</span></strong></p>
<p><span style="font-family: 宋体;">1.写出定义接口的格式</span></p>
<p><span style="font-family: 宋体;">2.写出实现接口的格式</span></p>
<p><span style="font-family: 宋体;">3.说出接口中成员的特点</span></p>
<p><span style="font-family: 宋体;">4.能够说出使用多态的前提条件</span></p>
<p><span style="font-family: 宋体;">5.理解多态的向上转型</span></p>
<p><span style="font-family: 宋体;">6.理解多态的向下转型</span></p>
<p><span style="font-family: 宋体;">7.能够完成笔记本电脑案例（方法参数为接口）</span></p>
<h2><strong><span style="font-family: 宋体;">第一章</span> <span style="font-family: 宋体;">接口</span></strong></h2>
<p><strong>1.1 </strong><strong>&nbsp;<span style="font-family: 宋体;">概述</span></strong></p>
<p><span style="font-family: 宋体;">接口，是</span>Java<span style="font-family: 宋体;">语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么</span></p>
<p><span style="font-family: 宋体;">接口的内部主要就是</span><strong><span style="font-family: 宋体;">封装了方法</span></strong><span style="font-family: 宋体;">，包含抽象方法（</span>JDK 7<span style="font-family: 宋体;">及以前），默认方法和静态方法（</span>JDK 8<span style="font-family: 宋体;">），私有方法</span><span style="font-family: 宋体;">（</span>JDK 9<span style="font-family: 宋体;">）。</span></p>
<p><span style="font-family: 宋体;">接口的定义，它与定义类方式相似，但是使用</span> &nbsp;interface &nbsp;<span style="font-family: 宋体;">关键字。它也会被编译成</span>.class<span style="font-family: 宋体;">文件，但一定要明确它并</span></p>
<p><span style="font-family: 宋体;">不是类，而是另外一种引用数据类型。</span></p>
<p><span style="font-family: 宋体;">引用数据类型：数组，类，接口。</span></p>
<p><span style="font-family: 宋体;">接口的使用，它不能创建对象，但是可以被实现（</span> implements &nbsp;<span style="font-family: 宋体;">，类似于被继承）。一个实现接口的类（可以看做</span></p>
<p><span style="font-family: 宋体;">是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象</span></p>
<p><span style="font-family: 宋体;">类。</span></p>
<p><strong>1.2 </strong><strong>&nbsp;<span style="font-family: 宋体;">定义格式</span></strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> 接口名称 {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  抽象方法
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  默认方法
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  静态方法
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  私有方法</span>
}</code></pre>

<p><strong><span style="font-family: 宋体;">含有抽象方法</span></strong></p>
<p><span style="font-family: 宋体;">抽象方法：使用</span> <span style="color: #ff0000;">abstract</span> &nbsp;<span style="font-family: 宋体;">关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</span></p>
<p><span style="font-family: 宋体;">代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> InterFaceName {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method();
}</span></code></pre>

<p><strong><span style="font-family: 宋体;">含有默认方法和静态方法</span></strong></p>
<p><span style="font-family: 宋体;">默认方法：使用</span> &nbsp;<span style="color: #ff0000;">default</span> &nbsp;<span style="font-family: 宋体;">修饰，不可省略，供子类调用或者子类重写。</span></p>
<p><span style="font-family: 宋体;">静态方法：使用</span> &nbsp;<span style="color: #ff0000;">static</span> &nbsp;<span style="font-family: 宋体;">修饰，供接口直接调用。</span></p>
<p><span style="font-family: 宋体;">代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> InterFaceName {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  执行语句</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  执行语句</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p><strong><span style="font-family: 宋体;">含有私有方法和私有静态方法</span></strong></p>
<p><span style="font-family: 宋体;">私有方法：使用</span> &nbsp;<span style="color: #ff0000;">private</span> &nbsp;<span style="font-family: 宋体;">修饰，供接口中的默认方法或者静态方法调用。</span></p>
<p><span style="font-family: 宋体;">代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> InterFaceName {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  执行语句</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong>1.3 </strong><strong>&nbsp;<span style="font-family: 宋体;">基本的实现</span></strong></p>
<p><strong><span style="font-family: 宋体;">实现的概述</span></strong></p>
<p><span style="font-family: 宋体;">类与接口的关系为实现关系，即</span><strong><span style="font-family: 宋体;">类实现接口</span></strong><span style="font-family: 宋体;">，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类</span></p>
<p><span style="font-family: 宋体;">似继承，格式相仿，只是关键字不同，实现使用</span> &nbsp;<span style="color: #ff0000;">implements</span> &nbsp;&nbsp;<span style="font-family: 宋体;">关键字。</span></p>
<p><span style="font-family: 宋体;">非抽象子类实现接口：</span></p>
<p>1. <span style="font-family: 宋体;">必须重写接口中所有抽象方法。</span></p>
<p>2. <span style="font-family: 宋体;">继承了接口的默认方法，即可以直接调用，也可以重写。</span></p>
<p><span style="font-family: 宋体;">实现格式：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> 类名 <span style="color: #0000ff;">implements</span><span style="color: #000000;"> 接口名 {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  重写接口中抽象方法【必须】
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  重写接口中默认方法【可选】</span>
}</code></pre>

<p><strong><span style="font-family: 宋体;">抽象方法的使用</span></strong></p>
<p><span style="font-family: 宋体;">必须全部实现，代码如下：</span></p>
<p><span style="font-family: 宋体;">定义接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> LiveAble {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  定义抽象方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat();
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> sleep();
}</span></code></pre>

<p><span style="font-family: 宋体;">定义实现类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Animal <span style="color: #0000ff;">implements</span><span style="color: #000000;"> LiveAble {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃东西"<span style="color: #000000;">);
    }
      
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> sleep() {
        System.out.println(</span>"晚上睡"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> InterfaceDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建子类对象</span>
        Animal a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Animal();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用实现后的方法</span>
<span style="color: #000000;">        a.eat();
        a.sleep();
    }
}

输出结果：
吃东西
晚上睡</span></code></pre>

<p>&nbsp;</p>
<p><strong><span style="font-family: 宋体;">默认方法的使用</span></strong></p>
<p><span style="font-family: 宋体;">可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。</span></p>
<p>1. <span style="font-family: 宋体;">继承默认方法，代码如下：</span></p>
<p><span style="font-family: 宋体;">定义接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> LiveAble {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> fly() {
        System.out.println(</span>"天上飞"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义实现类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Animal <span style="color: #0000ff;">implements</span><span style="color: #000000;"> LiveAble {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  继承，什么都不用写，直接调用</span>
}</code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> InterfaceDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建子类对象</span>
        Animal a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Animal();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用默认方法</span>
<span style="color: #000000;">        a.fly();
    }
}

输出结果：
天上飞</span></code></pre>

<p>&nbsp;</p>
<p>2. <span style="font-family: 宋体;">重写默认方法，代码如下：</span></p>
<p><span style="font-family: 宋体;">定义接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> LiveAble {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> fly() {
        System.out.println(</span>"天上飞"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义实现类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Animal <span style="color: #0000ff;">implements</span><span style="color: #000000;"> LiveAble {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> fly() {
        System.out.println(</span>"自由自在的飞"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> InterfaceDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建子类对象</span>
        Animal a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Animal();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用重写方法</span>
<span style="color: #000000;">        a.fly();
    }
}

输出结果：
自由自在的飞</span></code></pre>

<p><strong><span style="font-family: 宋体;">静态方法的使用</span></strong></p>
<p><span style="font-family: 宋体;">静态与</span>.class <span style="font-family: 宋体;">文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：</span></p>
<p><span style="font-family: 宋体;">定义接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> LiveAble {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        System.out.println(</span>"跑起来~~~"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义实现类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Animal <span style="color: #0000ff;">implements</span><span style="color: #000000;"> LiveAble {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  无法重写静态方法</span>
}</code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> InterfaceDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  Animal.run();  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 【错误】无法继承方法,也无法调用</span>
        LiveAble.run(); <span style="color: #008000;">//
</span><span style="color: #000000;">    }
}
输出结果：
跑起来</span>~~~</code></pre>

<p><strong><span style="font-family: 宋体;">私有方法的使用</span></strong></p>
<p><span style="font-family: 宋体;">私有方法：只有默认方法可以调用。</span></p>
<p><span style="font-family: 宋体;">私有静态方法：默认方法和静态方法可以调用。</span></p>
<p><span style="font-family: 宋体;">如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法</span></p>
<p><span style="font-family: 宋体;">去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。同学们在已学技术的基础上，可以自行测</span><span style="font-family: 宋体;">试。</span></p>
<p><span style="font-family: 宋体;">定义接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> LiveAble {
    </span><span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func() {
        func1();
        func2();
    }
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func1() {
        System.out.println(</span>"跑起来~~~"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> func2() {
        System.out.println(</span>"跑起来~~~"<span style="color: #000000;">);
    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong>1.4 </strong><strong>&nbsp;<span style="font-family: 宋体;">接口的多实现</span></strong></p>
<p><span style="font-family: 宋体;">之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接</span></p>
<p><span style="font-family: 宋体;">口的</span><strong><span style="font-family: 宋体;">多实现</span></strong><span style="font-family: 宋体;">。并且，一个类能继承一个父类，同时实现多个接口。</span></p>
<p><span style="font-family: 宋体;">实现格式：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> 类名[<span style="color: #0000ff;">extends</span> 父类名] <span style="color: #0000ff;">implements</span><span style="color: #000000;"> 接口名1, 接口名2, 接口名3... {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  重写接口中抽象方法【必须】
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  重写接口中默认方法【不重名时可选】</span>
}</code></pre>

<p>[ ]<span style="font-family: 宋体;">：</span> <span style="font-family: 宋体;">表示可选操作。</span></p>
<p><strong><span style="font-family: 宋体;">抽象方法</span></strong></p>
<p><span style="font-family: 宋体;">接口中，有多个抽象方法时，实现类必须重写所有抽象方法</span><strong><span style="font-family: 宋体;">。如果抽象方法有重名的，只需要重写一次。</span></strong><span style="font-family: 宋体;">代码如</span></p>
<p><span style="font-family: 宋体;">下：</span></p>
<p><span style="font-family: 宋体;">定义多个接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> A {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showA();
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show();
}
</span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> B {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showB();
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show();
}</span></code></pre>

<p><span style="font-family: 宋体;">定义实现类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">implements</span><span style="color: #000000;"> A, B {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showA() {
        System.out.println(</span>"showA"<span style="color: #000000;">);
    }
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showB() {
        System.out.println(</span>"showB"<span style="color: #000000;">);
    }
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        System.out.println(</span>"show"<span style="color: #000000;">);
    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong><span style="font-family: 宋体;">默认方法</span></strong></p>
<p><span style="font-family: 宋体;">接口中，有多个默认方法时，实现类都可继承使用。</span><strong><span style="font-family: 宋体;">如果默认方法有重名的，必须重写一次。</span></strong><span style="font-family: 宋体;">代码如下：</span></p>
<p><span style="font-family: 宋体;">定义多个接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> A {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> methodA() {}
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {}
}
</span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> B {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> methodB() {}
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {}
}</span></code></pre>

<p><span style="font-family: 宋体;">定义实现类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">implements</span><span style="color: #000000;"> A, B {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        System.out.println(</span>"method"<span style="color: #000000;">);
    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong><span style="font-family: 宋体;">静态方法</span></strong></p>
<p><span style="font-family: 宋体;">接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。</span></p>
<p><strong><span style="font-family: 宋体;">优先级的问题</span></strong></p>
<p><span style="font-family: 宋体;">当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执</span></p>
<p><span style="font-family: 宋体;">行父类的成员方法。代码如下：</span></p>
<p><span style="font-family: 宋体;">定义接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> A {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> methodA() {
        System.out.println(</span>"AAAAAAAAAAAA"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义父类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> D {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> methodA() {
        System.out.println(</span>"DDDDDDDDDDDD"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义子类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">extends</span> D <span style="color: #0000ff;">implements</span><span style="color: #000000;"> A {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  未重写methodA方法</span>
}</code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        C c </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> C();
        c.methodA();
    }
}

输出结果: DDDDDDDDDDDD</span></code></pre>

<p>&nbsp;</p>
<p><strong>1.5 </strong><strong>&nbsp;<span style="font-family: 宋体;">接口的多继承【了解】</span></strong></p>
<p><span style="font-family: 宋体;">一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用</span> &nbsp;extends &nbsp;<span style="font-family: 宋体;">关键字，子接口继</span></p>
<p><span style="font-family: 宋体;">承父接口的方法。</span><strong><span style="font-family: 宋体;">如果父接口中的默认方法有重名的，那么子接口需要重写一次。</span></strong><span style="font-family: 宋体;">代码如下：</span></p>
<p><span style="font-family: 宋体;">定义父接口：</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> A {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        System.out.println(</span>"AAAAAAAAAAAAAAAAAAA"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">interface</span><span style="color: #000000;"> B {
    </span><span style="color: #0000ff;">public</span>
    <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        System.out.println(</span>"BBBBBBBBBBBBBBBBBBB"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义子接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span> D <span style="color: #0000ff;">extends</span><span style="color: #000000;"> A, B {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">default</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method() {
        System.out.println(</span>"DDDDDDDDDDDDDD"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">小贴士：</span></p>
<p><span style="font-family: 宋体;">子接口重写默认方法时，</span>default<span style="font-family: 宋体;">关键字可以保留。</span></p>
<p><span style="font-family: 宋体;">子类重写默认方法时，</span>default<span style="font-family: 宋体;">关键字不可以保留。</span></p>
<p><strong>1.6 </strong><strong>&nbsp;<span style="font-family: 宋体;">其他成员特点</span></strong></p>
<p><span style="font-family: 宋体;">接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用</span>public static ﬁnal<span style="font-family: 宋体;">修饰。</span></p>
<p><span style="font-family: 宋体;">接口中，没有构造方法，不能创建对象。</span></p>
<p><span style="font-family: 宋体;">接口中，没有静态代码块。</span></p>
<p>&nbsp;</p>
<h2><strong><span style="font-family: 宋体;">第二章</span> <span style="font-family: 宋体;">多态</span></strong></h2>
<p><strong>2.1 </strong><strong>&nbsp;<span style="font-family: 宋体;">概述</span></strong></p>
<p><strong><span style="font-family: 宋体;">引入</span></strong></p>
<p><span style="font-family: 宋体;">多态是继封装、继承之后，面向对象的第三大特性。</span></p>
<p><span style="font-family: 宋体;">生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也</span></p>
<p><span style="font-family: 宋体;">是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。</span></p>
<p><strong><span style="font-family: 宋体;">定义</span></strong></p>
<p><strong><span style="font-family: 宋体;">多态</span></strong><span style="font-family: 宋体;">：</span> <span style="font-family: 宋体;">是指同一行为，具有多个不同表现形式。</span></p>
<p><strong><span style="font-family: 宋体;">前提【重点】</span></strong></p>
<p>1. <span style="font-family: 宋体;">继承或者实现【二选一】</span></p>
<p>2. <span style="font-family: 宋体;">方法的重写【意义体现：不重写，无意义】</span></p>
<p>3. <span style="font-family: 宋体;">父类引用指向子类对象【格式体现】</span></p>
<p><strong>2.2 </strong><strong>&nbsp;<span style="font-family: 宋体;">多态的体现</span></strong></p>
<p><span style="font-family: 宋体;">多态体现的格式：</span></p>
<src class="cnblogs_code">
<pre><code>父类类型 变量名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 子类对象；
变量名.方法名();</span></code></pre>

<p><span style="font-family: 宋体;">父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</span></p>
<p><span style="font-family: 宋体;">代码如下：</span></p>
<src class="cnblogs_code">
<pre><code>Fu f = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
f.method();</span></code></pre>

<p><strong><span style="font-family: 宋体;">当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写</span></strong></p>
<p><strong><span style="font-family: 宋体;">后方法。</span></strong></p>
<p><span style="font-family: 宋体;">代码如下：</span></p>
<p><span style="font-family: 宋体;">定义父类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat();
}</span></code></pre>

<p><span style="font-family: 宋体;">定义子类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> Cat <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃鱼"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span> Dog <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃骨头"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  多态形式，创建对象</span>
        Animal a1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Cat 的  eat</span>
<span style="color: #000000;">        a1.eat();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  多态形式，创建对象</span>
        Animal a2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Dog();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Dog 的  eat</span>
<span style="color: #000000;">        a2.eat();
    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong>2.3 </strong><strong>&nbsp;<span style="font-family: 宋体;">多态的好处</span></strong></p>
<p><span style="font-family: 宋体;">实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展</span></p>
<p><span style="font-family: 宋体;">性与便利。代码如下：</span></p>
<p><span style="font-family: 宋体;">定义父类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat();
}</span></code></pre>

<p><span style="font-family: 宋体;">定义子类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> Cat <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃鱼"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span> Dog <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃骨头"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  多态形式，创建对象</span>
        Cat c = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
        Dog d </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Dog();
       
         </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用showCatEat</span>
<span style="color: #000000;">        showCatEat(c);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用showDogEat</span>
<span style="color: #000000;">        showDogEat(d);
        
        </span><span style="color: #008000;">/*</span><span style="color: #008000;">
        以上两个方法,  均可以被showAnimalEat(Animal  a)方法所替代
        而执行效果一致
        </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        showAnimalEat(c);
        showAnimalEat(d);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showCatEat(Cat c) {
        c.eat();
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showDogEat(Dog d) {
        d.eat();
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showAnimalEat(Animal a) {
        a.eat();
    }
}        </span></code></pre>

<p><span style="font-family: 宋体;">由于多态特性的支持，</span>showAnimalEat<span style="font-family: 宋体;">方法的</span>Animal<span style="font-family: 宋体;">类型，是</span>Cat<span style="font-family: 宋体;">和</span>Dog<span style="font-family: 宋体;">的父类类型，父类类型接收子类对象，当</span></p>
<p><span style="font-family: 宋体;">然可以把</span>Cat<span style="font-family: 宋体;">对象和</span>Dog<span style="font-family: 宋体;">对象，传递给方法。</span></p>
<p><span style="font-family: 宋体;">当</span>eat<span style="font-family: 宋体;">方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与</span>showCatEat<span style="font-family: 宋体;">、</span>showDogEat<span style="font-family: 宋体;">方法一致，</span></p>
<p><span style="font-family: 宋体;">所以</span>showAnimalEat<span style="font-family: 宋体;">完全可以替代以上两方法。</span></p>
<p><span style="font-family: 宋体;">不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写</span>showXxxEat<span style="font-family: 宋体;">方法了，直接使用</span></p>
<p>showAnimalEat<span style="font-family: 宋体;">都可以完成。</span></p>
<p><span style="font-family: 宋体;">所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</span></p>
<p><strong>2.4 </strong><strong>&nbsp;<span style="font-family: 宋体;">引用类型转换</span></strong></p>
<p><span style="font-family: 宋体;">多态的转型分为向上转型与向下转型两种：</span></p>
<p><strong><span style="font-family: 宋体;">向上转型</span></strong></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">向上转型</span></strong></span><span style="font-family: 宋体;">：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</span></p>
<p><span style="font-family: 宋体;">当父类引用指向一个子类对象时，便是向上转型。</span></p>
<p><span style="font-family: 宋体;">使用格式：</span></p>
<p><span style="font-family: 宋体;">父类类型</span></p>
<src class="cnblogs_code">
<pre><code>变量名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 子类类型();
如： Animal a </span>= <span style="color: #0000ff;">new</span> Cat();</code></pre>

<p><strong><span style="font-family: 宋体;">向下转型</span></strong></p>
<p><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">向下转型</span></strong></span><span style="font-family: 宋体;">：父类类型向子类类型向下转换的过程，这个过程是强制的。</span></p>
<p><span style="font-family: 宋体;">一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</span></p>
<p><span style="font-family: 宋体;">使用格式：</span></p>
<src class="cnblogs_code">
<pre><code>子类类型 变量名 =<span style="color: #000000;"> (子类类型) 父类变量名;
如: Cat c </span>= (Cat) a;</code></pre>

<p><strong><span style="font-family: 宋体;">为什么要转型</span></strong></p>
<p><span style="font-family: 宋体;">当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，</span><strong><span style="font-family: 宋体;">不能调用</span></strong><span style="font-family: 宋体;">子类拥</span></p>
<p><span style="font-family: 宋体;">有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点</span>"<span style="font-family: 宋体;">小麻烦</span>"<span style="font-family: 宋体;">。所以，想要调用子</span></p>
<p><span style="font-family: 宋体;">类特有的方法，必须做向下转型。</span></p>
<p><span style="font-family: 宋体;">转型演示，代码如下：</span></p>
<p><span style="font-family: 宋体;">定义类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat();
}
</span><span style="color: #0000ff;">class</span> Cat <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃鱼"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> catchMouse() {
        System.out.println(</span>"抓老鼠"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span> Dog <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"吃骨头"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> watchHouse() {
        System.out.println(</span>"看家"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义测试类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  向上转型</span>
        Animal a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
        a.eat();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Cat 的  eat
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  向下转型</span>
        Cat c =<span style="color: #000000;"> (Cat) a;
        c.catchMouse();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Cat 的  catchMouse</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p><strong><span style="font-family: 宋体;">转型的异常</span></strong></p>
<p><span style="font-family: 宋体;">转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  向上转型</span>
        Animal a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
        a.eat();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Cat 的  eat
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  向下转型</span>
        Dog d =<span style="color: #000000;"> (Dog) a;
        d.watchHouse();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Dog 的  watchHouse  【运行报错】</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p><span style="font-family: 宋体;">这段代码可以通过编译，但是运行时，却报出了</span> &nbsp;<span style="color: #ff0000;">ClassCastException &nbsp;</span><span style="font-family: 宋体;">，类型转换异常！这是因为，明明创建了</span></p>
<p>Cat<span style="font-family: 宋体;">类型对象，运行时，当然不能转换成</span>Dog<span style="font-family: 宋体;">对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。</span></p>
<p><span style="font-family: 宋体;">为了避免</span>ClassCastException<span style="font-family: 宋体;">的发生，</span>Java<span style="font-family: 宋体;">提供了</span> &nbsp;<span style="color: #ff0000;">instanceof &nbsp;</span><span style="font-family: 宋体;">关键字，给引用变量做类型的校验，格式如下：</span></p>
<src class="cnblogs_code">
<pre><code>变量名  <span style="color: #0000ff;">instanceof</span><span style="color: #000000;">  数据类型
如果变量属于该数据类型，返回true。
如果变量不属于该数据类型，返回false。</span></code></pre>

<p><span style="font-family: 宋体;">所以，转换前，我们最好先做一个判断，代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  向上转型</span>
        Animal a = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
        a.eat();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Cat 的  eat
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  向下转型</span>
        <span style="color: #0000ff;">if</span>(a <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Cat) {
            Cat c </span>=<span style="color: #000000;"> (Cat) a;
            c.catchMouse();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Cat 的  catchMouse</span>
        } <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Dog) {
            Dog d </span>=<span style="color: #000000;"> (Dog) a;
            d.watchHouse();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用的是  Dog 的  watchHouse</span>
<span style="color: #000000;">        }
    }
}</span></code></pre>

<p>&nbsp;</p>
<h2><strong><span style="font-family: 宋体;">第三章</span> <span style="font-family: 宋体;">接口多态的综合案例</span></strong></h2>
<p><strong>3.1 </strong><strong>&nbsp;<span style="font-family: 宋体;">笔记本电脑</span></strong></p>
<p><span style="font-family: 宋体;">笔记本电脑（</span>laptop<span style="font-family: 宋体;">）通常具备使用</span>USB<span style="font-family: 宋体;">设备的功能。在生产时，笔记本都预留了可以插入</span>USB<span style="font-family: 宋体;">设备的</span>USB<span style="font-family: 宋体;">接口，</span></p>
<p><span style="font-family: 宋体;">但具体是什么</span>USB<span style="font-family: 宋体;">设备，笔记本厂商并不关心，只要符合</span>USB<span style="font-family: 宋体;">规格的设备都可以。</span></p>
<p><span style="font-family: 宋体;">定义</span>USB<span style="font-family: 宋体;">接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守</span></p>
<p>USB<span style="font-family: 宋体;">规范，实现</span>USB<span style="font-family: 宋体;">接口，否则鼠标和键盘的生产出来也无法使用。</span></p>
<p><strong>3.2 </strong><strong>&nbsp;<span style="font-family: 宋体;">案例分析</span></strong></p>
<p><span style="font-family: 宋体;">进行描述笔记本类，实现笔记本使用</span>USB<span style="font-family: 宋体;">鼠标、</span>USB<span style="font-family: 宋体;">键盘</span></p>
<p>USB<span style="font-family: 宋体;">接口，包含开启功能、关闭功能</span></p>
<p><span style="font-family: 宋体;">笔记本类，包含运行功能、关机功能、使用</span>USB<span style="font-family: 宋体;">设备功能</span></p>
<p><span style="font-family: 宋体;">鼠标类，要实现</span>USB<span style="font-family: 宋体;">接口，并具备点击的方法</span></p>
<p><span style="font-family: 宋体;">键盘类，要实现</span>USB<span style="font-family: 宋体;">接口，具备敲击的方法</span></p>
<p><strong>3.3 </strong><strong>&nbsp;<span style="font-family: 宋体;">案例实现</span></strong></p>
<p><span style="font-family: 宋体;">定义</span>USB<span style="font-family: 宋体;">接口：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">interface</span><span style="color: #000000;"> USB {
    </span><span style="color: #0000ff;">void</span> open(); <span style="color: #008000;">//</span><span style="color: #008000;">  开启功能</span>
    <span style="color: #0000ff;">void</span> close(); <span style="color: #008000;">//</span><span style="color: #008000;">  关闭功能</span>
}</code></pre>

<p><span style="font-family: 宋体;">定义鼠标类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> Mouse <span style="color: #0000ff;">implements</span><span style="color: #000000;"> USB {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> open() {
        System.out.println(</span>"鼠标开启，红灯闪一闪"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> close() {
        System.out.println(</span>"鼠标关闭，红灯熄灭"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> click() {
        System.out.println(</span>"鼠标单击"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义键盘类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> KeyBoard <span style="color: #0000ff;">implements</span><span style="color: #000000;"> USB {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> open() {
        System.out.println(</span>"键盘开启，绿灯闪一闪"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> close() {
        System.out.println(</span>"键盘关闭，绿灯熄灭"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> type() {
        System.out.println(</span>"键盘打字"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义笔记本类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Laptop {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  笔记本开启运行功能</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
            System.out.println(</span>"笔记本运行"<span style="color: #000000;">);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> useUSB(USB usb) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  判断是否有USB设备</span>
        <span style="color: #0000ff;">if</span>(usb != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            usb.open();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  类型转换,调用特有方法</span>
            <span style="color: #0000ff;">if</span>(usb <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Mouse) {
                Mouse m </span>=<span style="color: #000000;"> （Mouse） usb；
                m.click();
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(usb <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> KeyBoard) {
                KeyBoard kb </span>=<span style="color: #000000;"> (KeyBoard) usb;
                kb.type();
            }
            usb.close();
        }
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> shutDown() {
        System.out.println(</span>"笔记本关闭"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">测试类，代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建笔记本实体对象</span>
        Laptop lt = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Laptop();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  笔记本开启</span>
<span style="color: #000000;">        lt.run();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建鼠标实体对象</span>
        Usb u = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Mouse();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  笔记本使用鼠标</span>
<span style="color: #000000;">        lt.useUSB(u);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建键盘实体对象</span>
        KeyBoard kb = <span style="color: #0000ff;">new</span><span style="color: #000000;"> KeyBoard();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  笔记本使用键盘</span>
<span style="color: #000000;">        lt.useUSB(kb);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  笔记本关闭</span>
<span style="color: #000000;">        lt.shutDown();
    }
}</span></code></pre>

<p>&nbsp;</p>
<p><span style="color: #ff0000;">ending...</span></p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>