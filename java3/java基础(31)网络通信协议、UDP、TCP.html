<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(31)网络通信协议、UDP、TCP' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(31)网络通信协议、UDP、TCP</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11661360.html</div><br>
    <h1>1.&nbsp;<strong>网络通信协议</strong></h1>
<p class="16">通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>
<p class="16"><span style="font-family: 宋体;">网络通信协议有很多种，目前应用最广泛的是</span>TCP/IP<span style="font-family: 宋体;">协议</span><span style="font-family: 'Times New Roman';">(Transmission Control Protocal/Internet Protoal</span><span style="font-family: 宋体;">传输控制协议</span><span style="font-family: 'Times New Roman';">/</span><span style="font-family: 宋体;">英特网互联协议</span><span style="font-family: 'Times New Roman';">)</span><span style="font-family: 宋体;">，它是一个</span><span style="font-family: 宋体;">包括</span>TCP<span style="font-family: 宋体;">协议和</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">协议，</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">（</span><span style="font-family: 'Times New Roman';">User Datagram Protocol</span><span style="font-family: 宋体;">）协议</span>和其它一些协议的协议组，<span style="font-family: 宋体;">在学习具体协议之前首先了解一下</span>TCP/IP<span style="font-family: 宋体;">协议组的层次结构。</span></p>
<p class="16"><span style="font-family: 宋体;">在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。</span>TCP/IP<span style="font-family: 宋体;">协议的层次结构比较简单，共分为四层，如图所示。</span></p>
<p class="16"><img src="./images/java基础(31)网络通信协议、UDP、TCP0.png" alt="" /></p>
<p class="16"><span style="font-family: 宋体;">上图中，</span>TCP/IP<span style="font-family: 宋体;">协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。</span></p>
<p class="16">链路层：<span style="font-family: 宋体;">链路层</span><span style="font-family: 宋体;">是</span>用于定义<span style="font-family: 宋体;">物理传输通道，</span>通常是对某些网络连接设备的驱动协议，例如针对<span style="font-family: 宋体;">光纤、</span><a href="http://zhidao.baidu.com/search?word=%CB%AB%BD%CA%CF%DF&amp;fr=qb_search_exp&amp;ie=gbk"><span style="font-family: 宋体;">网线</span></a>提供的驱动。</p>
<p class="16">网络层：网络层<span style="font-family: 宋体;">是整个</span>TCP/IP<span style="font-family: 宋体;">协议的核心</span>，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</p>
<p class="16">传<span style="font-family: 宋体;">输层：主要使网络程序进行通信，在进行网络通信时，可以采用</span>TCP<span style="font-family: 宋体;">协议，也可以采用</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">协议。</span></p>
<p class="16"><span style="font-family: 宋体;">应用层：主要负责应用程序的协议，例如</span>HTTP<span style="font-family: 宋体;">协议、</span><span style="font-family: 'Times New Roman';">FTP</span><span style="font-family: 宋体;">协议等。</span></p>
<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]-->1.1&nbsp;<!--[endif]--><strong>IP<span style="font-family: 华文楷体;">地址和端口号</span></strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">要想使网络中的计算机能够进行通信，必须为每台计算机指定一个标识号，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">在</span>TCP/IP<span style="font-family: 宋体;">协议中，这个标识号就是</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址，它可以唯一标识一台计算机，目前，</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址广泛使用的版本是</span><span style="font-family: 'Times New Roman';">IPv4</span><span style="font-family: 宋体;">，它是由</span><span style="font-family: 'Times New Roman';">4</span><span style="font-family: 宋体;">个字节大小的二进制数来表示，如：</span><span style="font-family: 'Times New Roman';">00001010000000000000000000000001</span><span style="font-family: 宋体;">。由于二进制形式表示的</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址非常不便记忆和处理，因此通常会将</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址写成十进制的形式，每个字节用一个十进制数字</span><span style="font-family: 'Times New Roman';">(0-255)</span><span style="font-family: 宋体;">表示，数字间用符号&ldquo;</span><span style="font-family: 'Times New Roman';">.</span><span style="font-family: 宋体;">&rdquo;分开，如 &ldquo;</span><span style="font-family: 'Times New Roman';">192.168.1.100</span><span style="font-family: 宋体;">&rdquo;。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">随着计算机网络规模的不断扩大，对</span>IP<span style="font-family: 宋体;">地址的需求也越来越多，</span><span style="font-family: 'Times New Roman';">IPV4</span><span style="font-family: 宋体;">这种用</span><span style="font-family: 'Times New Roman';">4</span><span style="font-family: 宋体;">个字节表示的</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址面临枯竭，因此</span><span style="font-family: 'Times New Roman';">IPv6 </span><span style="font-family: 宋体;">便应运而生了，</span><span style="font-family: 'Times New Roman';">IPv6</span><span style="font-family: 宋体;">使用</span><span style="font-family: 'Times New Roman';">16</span><span style="font-family: 宋体;">个字节表示</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址，它所拥有的地址容量约是</span><span style="font-family: 'Times New Roman';">IPv4</span><span style="font-family: 宋体;">的</span><span style="font-family: 'Times New Roman';">8</span><span style="font-family: 宋体;">&times;</span><span style="font-family: 'Times New Roman';">10</span><sup>28</sup><span style="font-family: 宋体;">倍，达到</span>2<sup>128</sup>个（算上全零的），这样就解决了网络地址资源数量不够的问题。</p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">通过</span>IP<span style="font-family: 宋体;">地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（</span><span style="font-family: Calibri;">16</span><span style="font-family: 宋体;">位的二进制数）表示的，它的取值范围是</span><span style="font-family: Calibri;">0~65535</span><span style="font-family: 宋体;">，其中，</span><span style="font-family: Calibri;">0~1023</span><span style="font-family: 宋体;">之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用</span><span style="font-family: Calibri;">1024</span><span style="font-family: 宋体;">以上的端口号，从而避免端口号被另外一个应用或服务所占用。</span></p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">接下来通过一个图例来描述</span>IP<span style="font-family: 宋体;">地址和端口号的作用，如下图所示。</span></p>
<p><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP1.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">从上图中可以清楚地看到，位于网络中一台计算机可以通过</span>IP<span style="font-family: 宋体;">地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。</span></p>
<p>&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]-->1.2&nbsp;<!--[endif]--><strong>InetAddress</strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">了解了</span>IP<span style="font-family: 宋体;">地址的作用，我们看学习下</span><span style="font-family: Calibri;">JDK</span><span style="font-family: 宋体;">中提供了一个</span><span style="font-family: Calibri;">InetAdderss</span><span style="font-family: 宋体;">类，该类用于封装一个</span><span style="font-family: Calibri;">IP</span><span style="font-family: 宋体;">地址，并提供了一系列与</span><span style="font-family: Calibri;">IP</span><span style="font-family: 宋体;">地址相关的方法，下表中列出了</span><span style="font-family: Calibri;">InetAddress</span><span style="font-family: 宋体;">类的一些常用方法。</span></p>
<p><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP2.png" alt="" /></span></p>
<p class="16"><span style="font-family: 宋体;">上图中，列举了</span>InetAddress<span style="font-family: 宋体;">的四个常用方法。其中，前两个方法用于获得该类的实例对象，第一个方法用于获得表示指定主机的</span><span style="font-family: 'Times New Roman';">InetAddress</span><span style="font-family: 宋体;">对象，第二个方法用于获得表示本地的</span><span style="font-family: 'Times New Roman';">InetAddress</span><span style="font-family: 宋体;">对象。通过</span><span style="font-family: 'Times New Roman';">InetAddress</span><span style="font-family: 宋体;">对象便可获取指定主机名，</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址等，接下来通过一个案例来演示</span><span style="font-family: 'Times New Roman';">InetAddress</span><span style="font-family: 宋体;">的常用方法，如下所示。</span></p>
<p>&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Example01 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        InetAddress local </span>=<span style="color: #000000;"> InetAddress.getLocalHost();
        InetAddress remote </span>= InetAddress.getByName("www.itcast.cn"<span style="color: #000000;">);
        System.out.println(</span>"本机的IP地址：" +<span style="color: #000000;"> local.getHostAddress());
        System.out.println(</span>"itcast的IP地址：" +<span style="color: #000000;"> remote.getHostAddress());
        System.out.println(</span>"itcast的主机名为：" +<span style="color: #000000;"> remote.getHostName());
    }
}</span></code></pre>

<p class="16">&nbsp;</p>
<h1>2.&nbsp;<strong>UDP</strong><strong>与</strong><strong>TCP</strong><strong>协议</strong></h1>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">在介绍</span>TCP/IP<span style="font-family: 宋体;">结构时，提到传输层的两个重要的高级协议，分别是</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">TCP</span><span style="font-family: 宋体;">，其中</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">是</span><span style="font-family: 'Times New Roman';">User Datagram Protocol</span><span style="font-family: 宋体;">的简称，称为用户数据报协议，</span><span style="font-family: 'Times New Roman';">TCP</span><span style="font-family: 宋体;">是</span><span style="font-family: 'Times New Roman';">Transmission Control Protocol</span><span style="font-family: 宋体;">的简称，称为传输控制协议。</span></p>
<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]-->2.1&nbsp;<!--[endif]--><strong>UDP<span style="font-family: 华文楷体;">协议</span></strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">UDP<span style="font-family: 宋体;">是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">由于使用</span>UDP<span style="font-family: 宋体;">协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">但是在使用</span>UDP<span style="font-family: 宋体;">协议传送数据时，由于</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">协议。</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">的交换过程如下图所示。</span></p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP3.png" alt="" /></span></p>
<h2><!--[if !supportLists]-->2.2&nbsp;<!--[endif]--><strong>TCP<span style="font-family: 华文楷体;">协议</span></strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">TCP<span style="font-family: 宋体;">协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在</span><span style="font-family: 'Times New Roman';">TCP</span><span style="font-family: 宋体;">连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过&ldquo;三次握手&rdquo;。第一次握手，客户端向服务器端发出连接请求，等待服务器确认，第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求，第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP4.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">由于</span>TCP<span style="font-family: 宋体;">协议的面向连接特性，它可以保证传输数据的安全性，所以是一个被广泛采用的协议，例如在下载文件时，如果数据接收不完整，将会导致文件数据丢失而不能被打开，因此，下载文件时必须采用</span><span style="font-family: Calibri;">TCP</span><span style="font-family: 宋体;">协议。</span></p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<h1>3.&nbsp;<strong>UDP</strong><strong>通信</strong></h1>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]-->3.1&nbsp;<!--[endif]--><strong>DatagramPacket</strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">前面介绍了</span>UDP<span style="font-family: 宋体;">是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">通信也是一样，发送和接收的数据也需要使用&ldquo;集装箱&rdquo;进行打包，为此</span><span style="font-family: 'Times New Roman';">JDK</span><span style="font-family: 宋体;">中提供了一个</span><span style="font-family: 'Times New Roman';">DatagramPacket</span><span style="font-family: 宋体;">类，该类的实例对象就相当于一个集装箱，用于封装</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">通信中发送或者接收的数据。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">想要创建一个</span>DatagramPacket<span style="font-family: 宋体;">对象，首先需要了解一下它的构造方法。在创建发送端和接收端的</span><span style="font-family: 'Times New Roman';">DatagramPacket</span><span style="font-family: 宋体;">对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址和端口号。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">接下来根据</span>API<span style="font-family: 宋体;">文档的内容，对</span><span style="font-family: 'Times New Roman';">DatagramPacket</span><span style="font-family: 宋体;">的构造方法进行逐一详细地讲解。</span></p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP5.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">使用该构造方法在创建</span>DatagramPacket<span style="font-family: 宋体;">对象时，指定了封装数据的字节数组和数据的大小，没有指定</span><span style="font-family: Calibri;">IP</span><span style="font-family: 宋体;">地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地</span><span style="font-family: Calibri;">(ip</span><span style="font-family: 宋体;">地址和端口号</span><span style="font-family: Calibri;">)</span><span style="font-family: 宋体;">，</span>而接收端不需要明确知道数据的来源，只需要接收到数据即可。</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP6.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">使用该构造方法在创建</span>DatagramPacket<span style="font-family: 宋体;">对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标</span><span style="font-family: Calibri;">IP</span><span style="font-family: 宋体;">地址（</span><span style="font-family: Calibri;">addr</span><span style="font-family: 宋体;">）和端口号（</span><span style="font-family: Calibri;">port</span><span style="font-family: 宋体;">）。该对象通常用于发送端，因为在</span><span style="font-family: 宋体;">发送数据时必须指定接收端的</span>IP<span style="font-family: 宋体;">地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。</span></p>
<p class="16"><span style="font-family: 宋体;">上面我们讲解了</span>DatagramPacket<span style="font-family: 宋体;">的构造方法，接下来对</span><span style="font-family: 'Times New Roman';">DatagramPacket</span><span style="font-family: 宋体;">类中的常用方法进行详细地讲解，如下表所示。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP7.png" alt="" /></span></p>
<h2><!--[if !supportLists]-->3.2&nbsp;<!--[endif]--><strong>DatagramSocket</strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">DatagramPacket<span style="font-family: 宋体;">数据包的作用就如同是&ldquo;集装箱&rdquo;，可以将发送端或者接收端的数据封装起来。然而运输货物只有&ldquo;集装箱&rdquo;是不够的，还需要有码头。在程序中需要实现通信只有</span><span style="font-family: 'Times New Roman';">DatagramPacket</span><span style="font-family: 宋体;">数据包也同样不行，为此</span><span style="font-family: 'Times New Roman';">JDK</span><span style="font-family: 宋体;">中提供的一个</span><span style="font-family: 'Times New Roman';">DatagramSocket</span><span style="font-family: 宋体;">类。</span><span style="font-family: 'Times New Roman';">DatagramSocket</span><span style="font-family: 宋体;">类的作用就类似于码头，使用这个类的实例对象就可以发送和接收</span><span style="font-family: 'Times New Roman';">DatagramPacket</span><span style="font-family: 宋体;">数据包，发送数据的过程如下图所示。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP8.png" alt="" /></span></p>
<p class="16"><span style="font-family: 宋体;">在创建发送端和接收端的</span>DatagramSocket<span style="font-family: 宋体;">对象时，使用的构造方法也有所不同，下面对</span><span style="font-family: 'Times New Roman';">DatagramSocket</span><span style="font-family: 宋体;">类中常用的构造方法进行讲解。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP9.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">该构造方法用于创建发送端的</span>DatagramSocket<span style="font-family: 宋体;">对象</span><span style="font-family: 宋体;">，在创建</span>DatagramSocket<span style="font-family: 宋体;">对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP10.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">该构造方法既可用于创建接收端的</span>DatagramSocket<span style="font-family: 宋体;">对象</span><span style="font-family: 宋体;">，又可以创建发送端的</span>DatagramSocket<span style="font-family: 宋体;">对象，在创建接收端的</span><span style="font-family: Calibri;">DatagramSocket</span><span style="font-family: 宋体;">对象时，必须要指定一个端口号，这样就可以监听指定的端口。</span></p>
<p class="16"><span style="font-family: 宋体;">上面我们讲解了</span>DatagramSocket<span style="font-family: 宋体;">的构造方法，接下来对</span><span style="font-family: 'Times New Roman';">DatagramSocket</span><span style="font-family: 宋体;">类中的常用方法进行详细地讲解。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP11.png" alt="" /></span></p>
<h2><!--[if !supportLists]-->3.3&nbsp;<!--[endif]--><strong>UDP<span style="font-family: 华文楷体;">网络程序</span></strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">讲解了</span>DatagramPacket<span style="font-family: 宋体;">和</span><span style="font-family: 'Times New Roman';">DatagramSocket</span><span style="font-family: 宋体;">的作用，接下来通过一个案例来学习一下它们在程序中的具体用法。</span></p>
<p class="16"><span style="font-family: 宋体;">下图为</span>UDP<span style="font-family: 宋体;">发送端与接收端交互图解</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP12.png" alt="" /></span></p>
<p class="17"><span style="font-family: 宋体;">要实现</span>UDP<span style="font-family: 宋体;">通信需要创建一个发送端程序和一个接收端程序，很明显，在通信时只有接收端程序先运行，才能避免因发送端发送的数据无法接收，而造成数据丢失。因此，首先需要来完成接收端程序的编写。</span></p>
<p class="16">UDP完成数据的发送</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
* 发送端
 * 1,创建DatagramSocket对象
 * 2，创建DatagramPacket对象，并封装数据
 * 3，发送数据
 * 4，释放流资源
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> UDPSend {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,创建DatagramSocket对象</span>
        DatagramSocket sendSocket = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DatagramSocket();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2，创建DatagramPacket对象，并封装数据
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public DatagramPacket(byte[] buf, int length, InetAddress address,  int port)
        </span><span style="color: #008000;">//</span><span style="color: #008000;">构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</span>
        <span style="color: #0000ff;">byte</span>[] buffer = "hello,UDP"<span style="color: #000000;">.getBytes();
        DatagramPacket dp </span>= <span style="color: #0000ff;">new</span> DatagramPacket(buffer, buffer.length, InetAddress.getByName("192.168.75.58"), 12306<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3，发送数据
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public void send(DatagramPacket p) 从此套接字发送数据报包</span>
<span style="color: #000000;">        sendSocket.send(dp);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4，释放流资源</span>
<span style="color: #000000;">        sendSocket.close();
    }
}</span></code></pre>

<p class="16">&nbsp;</p>
<p class="16">UDP完成数据的接收</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * UDP接收端
 * 
 * 1,创建DatagramSocket对象
 * 2,创建DatagramPacket对象
 * 3,接收数据存储到DatagramPacket对象中
 * 4,获取DatagramPacket对象的内容
 * 5,释放流资源
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> UDPReceive {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,创建DatagramSocket对象,并指定端口号</span>
        DatagramSocket receiveSocket = <span style="color: #0000ff;">new</span> DatagramSocket(12306<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,创建DatagramPacket对象, 创建一个空的仓库</span>
        <span style="color: #0000ff;">byte</span>[] buffer = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
        DatagramPacket dp </span>= <span style="color: #0000ff;">new</span> DatagramPacket(buffer, 1024<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3,接收数据存储到DatagramPacket对象中</span>
<span style="color: #000000;">        receiveSocket.receive(dp);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4,获取DatagramPacket对象的内容
        </span><span style="color: #008000;">//</span><span style="color: #008000;">谁发来的数据  getAddress()</span>
        InetAddress ipAddress =<span style="color: #000000;"> dp.getAddress();
        String ip </span>= ipAddress.getHostAddress();<span style="color: #008000;">//</span><span style="color: #008000;">获取到了IP地址
        </span><span style="color: #008000;">//</span><span style="color: #008000;">发来了什么数据  getData()</span>
        <span style="color: #0000ff;">byte</span>[] data =<span style="color: #000000;"> dp.getData();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">发来了多少数据 getLenth()</span>
        <span style="color: #0000ff;">int</span> length =<span style="color: #000000;"> dp.getLength();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">显示收到的数据</span>
        String dataStr = <span style="color: #0000ff;">new</span> String(data,0<span style="color: #000000;">,length);
        System.out.println(</span>"IP地址："+ip+ "数据是"+<span style="color: #000000;"> dataStr);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5,释放流资源</span>
<span style="color: #000000;">        receiveSocket.close();
    }
}</span></code></pre>

<p class="16">&nbsp;</p>
<h1>4.&nbsp;<strong>TCP通信</strong></h1>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16">TCP<span style="font-family: 宋体;">通信同</span><span style="font-family: 'Times New Roman';">UDP</span><span style="font-family: 宋体;">通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建</span><span style="font-family: 'Times New Roman';">socket</span><span style="font-family: 宋体;">对象。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">区别在于，</span>UDP<span style="font-family: 宋体;">中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">而</span>TCP<span style="font-family: 宋体;">通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。</span></p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">在</span>JDK<span style="font-family: 宋体;">中提供了两个类用于实现</span><span style="font-family: Calibri;">TCP</span><span style="font-family: 宋体;">程序，</span><span style="font-family: 宋体;">一个是</span>ServerSocket<span style="font-family: 宋体;">类，用于表示服务器端，一个是</span><span style="font-family: Calibri;">Socket</span><span style="font-family: 宋体;">类，用于表示客户端</span>。</p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">通信时，首先创建代表服务器端的</span>ServerSocket<span style="font-family: 宋体;">对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的</span><span style="font-family: Calibri;">Socket</span><span style="font-family: 宋体;">对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</span></p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]-->4.1&nbsp;<!--[endif]--><strong>ServerSocket</strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">通过前面的学习知道，在开发</span>TCP<span style="font-family: 宋体;">程序时，首先需要创建服务器端程序。</span><span style="font-family: 'Times New Roman';">JDK</span><span style="font-family: 宋体;">的</span><span style="font-family: 'Times New Roman';">java.net</span><span style="font-family: 宋体;">包中提供了一个</span><span style="font-family: 'Times New Roman';">ServerSocket</span><span style="font-family: 宋体;">类，该类的实例对象可以实现一个服务器段的程序。通过查阅</span><span style="font-family: 'Times New Roman';">API</span><span style="font-family: 宋体;">文档可知，</span><span style="font-family: 'Times New Roman';">ServerSocket</span><span style="font-family: 宋体;">类提供了多种构造方法，接下来就对</span><span style="font-family: 'Times New Roman';">ServerSocket</span><span style="font-family: 宋体;">的构造方法进行逐一地讲解。</span></p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;<img src="./images/java基础(31)网络通信协议、UDP、TCP13.png" alt="" /></p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">使用该构造方法在创建</span>ServerSocket<span style="font-family: 宋体;">对象时，就可以将其绑定到一个指定的端口号上（参数</span><span style="font-family: Calibri;">port</span><span style="font-family: 宋体;">就是端口号）。</span></p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">接下来学习一下</span>ServerSocket<span style="font-family: 宋体;">的常用方法，如表所示。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP14.png" alt="" /></span></p>
<p>ServerSocket<span style="font-family: 宋体;">对象负责监听某台计算机的某个端口号，在创建</span><span style="font-family: Calibri;">ServerSocket</span><span style="font-family: 宋体;">对象后，需要继续调用该对象的</span><span style="font-family: Calibri;">accept()</span><span style="font-family: 宋体;">方法，接收来自客户端的请求。当执行了</span><span style="font-family: Calibri;">accept()</span><span style="font-family: 宋体;">方法之后，服务器端程序会发生阻塞，直到客户端发出连接请求，</span><span style="font-family: Calibri;">accept()</span><span style="font-family: 宋体;">方法才会返回一个</span><span style="font-family: Calibri;">Scoket</span><span style="font-family: 宋体;">对象用于和客户端实现通信，程序才能继续向下执行。</span></p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]-->4.2&nbsp;<!--[endif]--><strong>Socket</strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">讲解了</span>ServerSocket<span style="font-family: 宋体;">对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此</span><span style="font-family: 'Times New Roman';">JDK</span><span style="font-family: 宋体;">提供了一个</span><span style="font-family: 'Times New Roman';">Socket</span><span style="font-family: 宋体;">类，用于实现</span><span style="font-family: 'Times New Roman';">TCP</span><span style="font-family: 宋体;">客户端程序。</span></p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">通过查阅</span>API<span style="font-family: 宋体;">文档可知</span><span style="font-family: Calibri;">Socket</span><span style="font-family: 宋体;">类同样提供了多种构造方法，接下来就对</span><span style="font-family: Calibri;">Socket</span><span style="font-family: 宋体;">的常用构造方法进行详细讲解。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP15.png" alt="" /></span></p>
<p class="16"><span style="font-family: 宋体;">使用该构造方法在创建</span>Socket<span style="font-family: 宋体;">对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数</span><span style="font-family: 'Times New Roman';">host</span><span style="font-family: 宋体;">接收的是一个字符串类型的</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP16.png" alt="" /></span></p>
<p class="16"><span style="font-family: 宋体;">该方法在使用上与第二个构造方法类似，参数</span>address<span style="font-family: 宋体;">用于接收一个</span><span style="font-family: 'Times New Roman';">InetAddress</span><span style="font-family: 宋体;">类型的对象，该对象用于封装一个</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址。</span></p>
<p class="16">在以上Socket的构造方法中，最常用的是第一个构造方法。</p>
<p class="16"><span style="font-family: 宋体;">接下来学习一下</span>Socket<span style="font-family: 宋体;">的常用方法，如表所示。</span></p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="257">
<p class="16" align="center"><strong>方法声明</strong></p>
</td>
<td valign="top" width="516">
<p class="16" align="center"><strong>功能描述</strong></p>
</td>
</tr>
<tr>
<td valign="center" width="257">
<p class="16">int getPort()</p>
</td>
<td valign="top" width="516">
<p class="16">该方法返回一个<span style="font-family: 'Times New Roman';">int</span><span style="font-family: 宋体;">类型对象，该对象是</span><span style="font-family: 'Times New Roman';">Socket</span><span style="font-family: 宋体;">对象与服务器端连接的端口号</span></p>
</td>
</tr>
<tr>
<td valign="center" width="257">
<p class="16">InetAddress&nbsp;getLocalAddress()</p>
</td>
<td valign="top" width="516">
<p class="16">该方法用于获取<span style="font-family: 'Times New Roman';">Socket</span><span style="font-family: 宋体;">对象绑定的本地</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址，并将</span><span style="font-family: 'Times New Roman';">IP</span><span style="font-family: 宋体;">地址封装成</span>InetAddress类型的对象返回</p>
</td>
</tr>
<tr>
<td valign="center" width="257">
<p class="16">void close()</p>
</td>
<td valign="top" width="516">
<p class="16">该方法用于关闭<span style="font-family: 'Times New Roman';">Socket</span><span style="font-family: 宋体;">连接，结束本次通信。在关闭</span><span style="font-family: 'Times New Roman';">socket</span><span style="font-family: 宋体;">之前，应将与</span><span style="font-family: 'Times New Roman';">socket</span><span style="font-family: 宋体;">相关的所有的输入</span><span style="font-family: 'Times New Roman';">/</span><span style="font-family: 宋体;">输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源</span></p>
</td>
</tr>
<tr>
<td valign="center" width="257">
<p class="16">InputStream getInputStream()</p>
</td>
<td valign="top" width="516">
<p class="16">该方法返回一个<span style="font-family: 'Times New Roman';">InputStream</span><span style="font-family: 宋体;">类型的输入流对象，如果该对象是由服务器端的</span><span style="font-family: 'Times New Roman';">Socket</span><span style="font-family: 宋体;">返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据</span></p>
</td>
</tr>
<tr>
<td valign="center" width="257">
<p class="16">OutputStream getOutputStream()</p>
</td>
<td valign="top" width="516">
<p class="16">该方法返回一个<span style="font-family: 'Times New Roman';">OutputStream</span><span style="font-family: 宋体;">类型的输出流对象，如果该对象是由服务器端的</span><span style="font-family: 'Times New Roman';">Socket</span><span style="font-family: 宋体;">返回，就用于向客户端发送数据，反之，用于向服务器端发送数据</span></p>
</td>
</tr>
</tbody>
</table>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p><span style="font-family: 宋体;">在</span>Socket<span style="font-family: 宋体;">类的常用方法中，</span><span style="font-family: Calibri;">getInputStream()</span><span style="font-family: 宋体;">和</span><span style="font-family: Calibri;">getOutStream()</span><span style="font-family: 宋体;">方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，数据是以</span><span style="font-family: Calibri;">IO</span><span style="font-family: 宋体;">流的形式进行交互的，从而实现通信。</span></p>
<p class="16">&nbsp;</p>
<p>接下来通过一张图来描述服务器端和客户端的数据传输，如下图所示。</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP17.png" alt="" /></span></p>
<h2><!--[if !supportLists]-->4.3&nbsp;<!--[endif]--><strong><span style="font-family: 华文楷体;">简单的</span>TCP<span style="font-family: 华文楷体;">网络程序</span></strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">了解了</span>ServerSocket<span style="font-family: 宋体;">、</span><span style="font-family: 'Times New Roman';">Socket</span><span style="font-family: 宋体;">类的基本用法，为了让大家更好地掌握这两个类的使用，接下来通过一个</span><span style="font-family: 'Times New Roman';">TCP</span><span style="font-family: 宋体;">通信的案例来进一步学习。如下图所示。</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP18.png" alt="" /></span></p>
<p><span style="font-family: 宋体;">要实现</span>TCP<span style="font-family: 宋体;">通信需要创建一个服务器端程序和一个客户端程序，为了保证数据传输的安全性，首先需要实现服务器端程序。</span></p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * TCP 服务器端
 * 
 * 1,创建服务器ServerSocket对象（指定服务器端口号）
 * 2，开启服务器了，等待客户端的连接，当客户端连接后，可以获取到连接服务器的客户端Socket对象
 * 3,给客户端反馈信息
 * 4,关闭流资源
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TCPServer {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,创建服务器ServerSocket对象（指定服务器端口号）</span>
        ServerSocket ss = <span style="color: #0000ff;">new</span> ServerSocket(8888<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2，开启服务器了，等待客户端的连接，当客户端连接后，可以获取到连接服务器的客户端Socket对象</span>
        Socket s =<span style="color: #000000;"> ss.accept();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3,给客户端反馈信息</span>
        <span style="color: #008000;">/*</span><span style="color: #008000;">
         * a,获取客户端的输出流
         * b,在服务端端，通过客户端的输出流写数据给客户端
         </span><span style="color: #008000;">*/</span>
        <span style="color: #008000;">//</span><span style="color: #008000;">a,获取客户端的输出流</span>
        OutputStream out =<span style="color: #000000;"> s.getOutputStream();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">b,在服务端端，通过客户端的输出流写数据给客户端</span>
        out.write("你已经连接上了服务器"<span style="color: #000000;">.getBytes());
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4,关闭流资源</span>
<span style="color: #000000;">        out.close();
        s.close();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">ss.close();  服务器流 通常都是不关闭的</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p class="16">&nbsp;</p>
<p class="16">完成了服务器端程序的编写，接下来编写客户端程序。</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * TCP 客户端
 * 
 * 1，创建客户端Socket对象,（指定要连接的服务器地址与端口号）
 * 2,获取服务器端的反馈回来的信息
 * 3,关闭流资源
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TCPClient {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1，创建客户端Socket对象,（指定要连接的服务器地址与端口号）</span>
        Socket s = <span style="color: #0000ff;">new</span> Socket("192.168.74.58", 8888<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,获取服务器端的反馈回来的信息</span>
        InputStream in =<span style="color: #000000;"> s.getInputStream();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取获取流中的数据</span>
        <span style="color: #0000ff;">byte</span>[] buffer = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
        </span><span style="color: #008000;">//</span><span style="color: #008000;">把流中的数据存储到数组中，并记录读取字节的个数</span>
        <span style="color: #0000ff;">int</span> length =<span style="color: #000000;"> in.read(buffer);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">显示数据</span>
        System.out.println( <span style="color: #0000ff;">new</span> String(buffer, 0<span style="color: #000000;"> , length) );
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3,关闭流资源</span>
<span style="color: #000000;">        in.close();
        s.close();
    }
}</span></code></pre>

<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]-->4.4&nbsp;<!--[endif]--><strong>文件上传案例</strong></h2>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;">目前大多数服务器都会提供文件上传的功能，由于文件上传需要数据的安全性和完整性，很明显需要使用</span>TCP<span style="font-family: 宋体;">协议来实现。接下来通过一个案例来实现图片上传的功能。如下图所示。原图：文件上传</span><span style="font-family: 'Times New Roman';">.bmp</span></p>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP19.png" alt="" /></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>首先编写服务器端程序，用来接收图片。</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * 文件上传  服务器端
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TCPServer {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,创建服务器，等待客户端连接</span>
        ServerSocket serverSocket = <span style="color: #0000ff;">new</span> ServerSocket(8888<span style="color: #000000;">);
        Socket clientSocket </span>=<span style="color: #000000;"> serverSocket.accept();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">显示哪个客户端Socket连接上了服务器</span>
        InetAddress ipObject = clientSocket.getInetAddress();<span style="color: #008000;">//</span><span style="color: #008000;">得到IP地址对象</span>
        String ip = ipObject.getHostAddress(); <span style="color: #008000;">//</span><span style="color: #008000;">得到IP地址字符串</span>
        System.out.println("小样，抓到你了，连接我！！" + "IP:" +<span style="color: #000000;"> ip);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">7,获取Socket的输入流</span>
        InputStream in =<span style="color: #000000;"> clientSocket.getInputStream();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">8,创建目的地的字节输出流   D:\\upload\\192.168.74.58(1).jpg</span>
        BufferedOutputStream fileOut = <span style="color: #0000ff;">new</span> BufferedOutputStream(<span style="color: #0000ff;">new</span> FileOutputStream("D:\\upload\\192.168.74.58(1).jpg"<span style="color: #000000;">));
        </span><span style="color: #008000;">//</span><span style="color: #008000;">9,把Socket输入流中的数据，写入目的地的字节输出流中</span>
        <span style="color: #0000ff;">byte</span>[] buffer = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> len = -1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span>((len = in.read(buffer)) != -1<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">写入目的地的字节输出流中</span>
            fileOut.write(buffer, 0<span style="color: #000000;">, len);
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">-----------------反馈信息---------------------
        </span><span style="color: #008000;">//</span><span style="color: #008000;">10,获取Socket的输出流, 作用：写反馈信息给客户端</span>
        OutputStream out =<span style="color: #000000;"> clientSocket.getOutputStream();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">11,写反馈信息给客户端</span>
        out.write("图片上传成功"<span style="color: #000000;">.getBytes());
        
        out.close();
        fileOut.close();
        in.close();
        clientSocket.close();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">serverSocket.close();</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p class="16">&nbsp;</p>
<p class="16">编写客户端，完成上传图片</p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * 文件上传 客户端
 * 
 * public void shutdownOutput()  禁用此Socket的输出流,间接的相当于告知了服务器数据写入完毕
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TCPClient {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,创建客户端Socket，连接服务器</span>
        Socket socket = <span style="color: #0000ff;">new</span> Socket("192.168.74.58", 8888<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3,获取Socket流中的输出流，功能：用来把数据写到服务器</span>
        OutputStream out =<span style="color: #000000;"> socket.getOutputStream();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4,创建字节输入流，功能：用来读取数据源(图片)的字节</span>
        BufferedInputStream fileIn = <span style="color: #0000ff;">new</span> BufferedInputStream(<span style="color: #0000ff;">new</span> FileInputStream("D:\\NoDir\\test.jpg"<span style="color: #000000;">));
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5,把图片数据写到Socket的输出流中(把数据传给服务器)</span>
        <span style="color: #0000ff;">byte</span>[] buffer = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> len = -1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> ((len = fileIn.read(buffer)) != -1<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">把数据写到Socket的输出流中</span>
            out.write(buffer, 0<span style="color: #000000;">, len);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">6,客户端发送数据完毕，结束Socket输出流的写入操作，告知服务器端</span>
<span style="color: #000000;">        socket.shutdownOutput();

        </span><span style="color: #008000;">//</span><span style="color: #008000;">-----------------反馈信息---------------------
        </span><span style="color: #008000;">//</span><span style="color: #008000;">12,获取Socket的输入流  作用： 读反馈信息</span>
        InputStream in =<span style="color: #000000;"> socket.getInputStream();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">13,读反馈信息</span>
        <span style="color: #0000ff;">byte</span>[] info = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
        </span><span style="color: #008000;">//</span><span style="color: #008000;">把反馈信息存储到info数组中，并记录字节个数</span>
        <span style="color: #0000ff;">int</span> length =<span style="color: #000000;"> in.read(info);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">显示反馈结果</span>
        System.out.println( <span style="color: #0000ff;">new</span> String(info, 0<span style="color: #000000;">, length) );
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">关闭流</span>
<span style="color: #000000;">        in.close();
        fileIn.close();
        out.close();
        socket.close();
    }
}</span></code></pre>

<p class="16">&nbsp;</p>
<h2><!--[if !supportLists]--><span style="font-family: 华文楷体; font-size: 16pt;">4.5&nbsp;</span><!--[endif]--><strong><span style="font-family: 华文楷体; font-size: 16pt;">文件上传案例多线程版本</span></strong></h2>
<p class="16">&nbsp;</p>
<p class="16"><span style="font-family: 宋体;"><img src="./images/java基础(31)网络通信协议、UDP、TCP20.png" alt="" width="966" height="341" /></span></p>
<p>&nbsp;</p>
<p class="16">&nbsp;</p>
<p>&nbsp;<span style="font-family: 宋体; font-size: 10.5pt; text-indent: 21pt;">实现服务器端可以同时接收多个客户端上传的文件。</span></p>
<p class="16"><!--[if !supportLists]--><span style="mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.0000pt;">我们要修改服务器端代码</span></p>
<p class="16">&nbsp;</p>
<p class="16">&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * 文件上传多线程版本, 服务器端
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TCPServer {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,创建服务器，等待客户端连接</span>
        ServerSocket serverSocket = <span style="color: #0000ff;">new</span> ServerSocket(6666<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">实现多个客户端连接服务器的操作</span>
        <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">final</span> Socket clientSocket =<span style="color: #000000;"> serverSocket.accept();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">启动线程，完成与当前客户端的数据交互过程</span>
            <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(){
                </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                    </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">显示哪个客户端Socket连接上了服务器</span>
                        InetAddress ipObject = clientSocket.getInetAddress();<span style="color: #008000;">//</span><span style="color: #008000;">得到IP地址对象</span>
                        String ip = ipObject.getHostAddress(); <span style="color: #008000;">//</span><span style="color: #008000;">得到IP地址字符串</span>
                        System.out.println("小样，抓到你了，连接我！！" + "IP:" +<span style="color: #000000;"> ip);
                        
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">7,获取Socket的输入流</span>
                        InputStream in =<span style="color: #000000;"> clientSocket.getInputStream();
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">8,创建目的地的字节输出流   D:\\upload\\192.168.74.58(1).jpg</span>
                        BufferedOutputStream fileOut = <span style="color: #0000ff;">new</span> BufferedOutputStream(<span style="color: #0000ff;">new</span> FileOutputStream("D:\\upload\\"+ip+"("+System.currentTimeMillis()+").jpg"<span style="color: #000000;">));
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">9,把Socket输入流中的数据，写入目的地的字节输出流中</span>
                        <span style="color: #0000ff;">byte</span>[] buffer = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
                        </span><span style="color: #0000ff;">int</span> len = -1<span style="color: #000000;">;
                        </span><span style="color: #0000ff;">while</span>((len = in.read(buffer)) != -1<span style="color: #000000;">){
                            </span><span style="color: #008000;">//</span><span style="color: #008000;">写入目的地的字节输出流中</span>
                            fileOut.write(buffer, 0<span style="color: #000000;">, len);
                        }
                        
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">-----------------反馈信息---------------------
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">10,获取Socket的输出流, 作用：写反馈信息给客户端</span>
                        OutputStream out =<span style="color: #000000;"> clientSocket.getOutputStream();
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">11,写反馈信息给客户端</span>
                        out.write("图片上传成功"<span style="color: #000000;">.getBytes());
                        
                        out.close();
                        fileOut.close();
                        in.close();
                        clientSocket.close();
                    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(IOException e){
                        e.printStackTrace();
                    }
                };
            }.start();
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">serverSocket.close();</span>
<span style="color: #000000;">    }
}</span></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>