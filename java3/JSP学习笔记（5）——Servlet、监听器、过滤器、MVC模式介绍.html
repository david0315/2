<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JSP学习笔记（5）——Servlet、监听器、过滤器、MVC模式介绍' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JSP学习笔记（5）——Servlet、监听器、过滤器、MVC模式介绍</center></div><div class='banquan'>原文出处:本文由博客园博主Stars-one提供。<br/>
原文连接:https://www.cnblogs.com/kexing/p/11520412.html</div><br>
    <h2 id="mvc模式">MVC模式</h2>
<p>在讲解Servlet前，先介绍一下MVC模式。</p>
<ul>
<li>M：model 模型，相当于数据层，用于存放数据，如一个Java中的一个bean类</li>
<li>V：view 视图，相当于页面层，用于显示数据，如一个网页html,或者是jsp</li>
<li>C: controller 控制器，相当于业务层，用于处理数据</li>
</ul>
<p>我们之前使用的JSP，其中也是可以使用java小脚本来进行数据处理。</p>
<p>但是，我们又想要显示数据，又要处理数据，代码都放在JSP文件中，会造成代码的污染，不方便阅读和编写。</p>
<p>这个时候，就出现了MVC架构，用于把数据处理、数据显示、数据存放都分离，可以更好地管理。</p>
<p>这样一来，我们就可以把一个JavaWeb项目分为了三个层次，JSP就用来显示数据，Servlet用来处理数据，bean类用来存放数据。</p>
<h2 id="servlet介绍">Servlet介绍</h2>
<blockquote>
<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
</blockquote>
<p>简单来说，Servlet就是可以拦截请求，然后进行处理，之后进行数据的返回，或者是页面导航（重定向或请求转发）</p>
<p>作用：</p>
<ol>
<li>处理用户的请求数据</li>
<li>响应用户请求</li>
<li>页面导航</li>
<li>控制业务逻辑的处理</li>
</ol>
<h2 id="filter过滤器介绍">Filter过滤器介绍</h2>
<blockquote>
<p>过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。</p>
<p>可以将一个或多个过滤器附加到一个 Servlet 或一组 Servlet。过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。</p>
<p>过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：</p>
<p>在客户端的请求访问后端资源之前，拦截这些请求。在服务器的响应发送回客户端之前，处理这些响应。</p>
</blockquote>
<p>过滤器是指当客户端请求某些web组件（JSP/Servlet）前先对请求做一些预处理操作，例如提交的表单包含中文时、用户是否已经进行了登录等，可以用过滤器对请求数据做中文转码；判断用户是否进行了登录等应用场合</p>
<p>官方建议以下案例使用过滤器；</p>
<ul>
<li>身份验证过滤器（Authentication Filters）。</li>
<li>数据压缩过滤器（Data compression Filters）。</li>
<li>加密过滤器（Encryption Filters）。</li>
<li>触发资源访问事件过滤器。</li>
<li>图像转换过滤器（Image Conversion Filters）。</li>
<li>日志记录和审核过滤器（Logging and Auditing Filters）。</li>
<li>MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。</li>
<li>标记化过滤器（Tokenizing Filters）。</li>
<li>XSL/T 过滤器（XSL/T Filters），转换 XML 内容。</li>
</ul>
<h2 id="lisenter监听器介绍">Lisenter监听器介绍</h2>
<blockquote>
<p>监听器也叫Listener，是Servlet的监听器，它可以监听客户端的请求、服务端的操作等。通过监听器，可以自动激发一些操作，比如监听在线的用户的数量。</p>
</blockquote>
<p>由于用得不多，这里就先大概介绍一下监听器可以用在哪个哪些功能上</p>
<p>两种方式，注解 @WebListener和web.xml配置 listener</p>
<h2 id="servlet与过滤器的流程">Servlet与过滤器的流程</h2>
<p><img src="./images/JSP学习笔记（5）——Servlet、监听器、过滤器、MVC模式介绍0.png" /></p>
<h2 id="servlet实现">Servlet实现</h2>
<h3 id="编写一个class使其继承httpservlet重写doget和dopost方法">1. 编写一个Class，使其继承HTTPServlet，重写doGet和doPost方法</h3>
<ul>
<li>doGet 处理用户的get请求</li>
<li>doPost 处理用户的post请求</li>
</ul>
<p><strong>PS：如果提示没有发现这个HTTPServlet类，添加一下依赖</strong></p>
<pre><code><code>package controller;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
 * @author StarsOne
 * @date Create in  2019/9/14 0014 20:14
 * @description
 */
public class FirstServlet extends HttpServlet {
    /**
     * @param req 相当于request内置对象
     * @param resp 相当于response内置对象
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //调用doPost方法
        doPost(req,resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //重定向页面
        resp.sendRedirect(req.getContextPath()+&quot;/hello.jsp&quot;);
    }
}</code></code></pre>
<h3 id="打开web.xml配置servlet对请求进行拦截">2. 打开web.xml,配置Servlet，对请求进行拦截</h3>
<p><img src="./images/JSP学习笔记（5）——Servlet、监听器、过滤器、MVC模式介绍1.png" /></p>
<pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;
        &lt;!--这里要指定Servlet的类，也就是我们之前第一步编写的那个类--&gt;
        &lt;servlet-class&gt;controller.FirstServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;!--这里的FirstServlet是与上面的servlet-name属性对应，可以任意取名--&gt;
        &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;
        &lt;!--拦截的请求，请求为hello时，就会跳转到Servlet去执行--&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></code></pre>
<p><strong>关于url-pattern的补充：请看下面</strong></p>
<h3 id="测试说明">3. 测试说明</h3>
<p>我的项目中定义了两个jsp，一个是<code>index.jsp</code>，另外一个则是<code>hello.jsp</code><br />
<code>index.jsp</code>中有一个链接：</p>
<pre><code><code>&lt;a href=&quot;hello&quot;&gt;点击跳转&lt;/a&gt;</code></code></pre>
<p>之后点击上面的链接，就会被Servlet拦截，之后进行处理。我们的Servlet其实就是实现了页面重定向的操作，所以，之后就会跳转到<code>hello.jsp</code>的页面</p>
<p><strong>PS：除了使用web.xml配置的方式之外，也可以使用注解来标记</strong></p>
<p>在Servlet那个类上使用<code>@WebServlet</code>注解就可以,下面这段代码与之前在web.xml文件定义的也是一样的效果，点击之后也会跳转到<code>hello.jsp</code>中去</p>
<pre><code><code>@WebServlet(&quot;/hello&quot;)
public class FirstServlet{
    ...
}</code></code></pre>
<h3 id="url-pattern补充">url-pattern补充</h3>
<h4 id="精确匹配">1. 精确匹配：</h4>
<table>
<thead>
<tr class="header">
<th>形式</th>
<th>匹配的url</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/hello</td>
<td>http://localhost:8080/servletdemo/hello</td>
</tr>
<tr class="even">
<td>/hello.html</td>
<td>http://localhost:8080/servletdemo/hello.html</td>
</tr>
</tbody>
</table>
<p>之前我们写的链接的href属性，只写了hello，其实访问的url地址就是<code>http://localhost:8080/servletdemo/hello</code></p>
<h4 id="路径匹配">2. 路径匹配：</h4>
<p>**以“/”字符开头，并以“/*”结尾的字符串用于路径匹配**</p>
<table>
<thead>
<tr class="header">
<th>形式</th>
<th>匹配的url</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/user/*</td>
<td>http://localhost:8080/user/hello http://localhost:8080/user/he http://localhost:8080/user/hello/aa</td>
</tr>
<tr class="even">
<td>/hello.html</td>
<td>http://localhost:8080/servletdemo/hello.html</td>
</tr>
</tbody>
</table>
<h4 id="扩展名匹配">3. 扩展名匹配：</h4>
<p>简单来说，就是url以什么结尾的</p>
<table>
<thead>
<tr class="header">
<th>形式</th>
<th>匹配的url</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>*.do</td>
<td>http://localhost:8080/servletdemo/hello.do</td>
</tr>
<tr class="even">
<td>*.hello</td>
<td>http://localhost:8080/servletdemo/aa.hello</td>
</tr>
<tr class="odd">
<td>*.action</td>
<td>http://localhost:8080/servletdemo/aa.action</td>
</tr>
<tr class="even">
<td>*.jsp</td>
<td>http://localhost:8080/servletdemo/aa.jsp</td>
</tr>
</tbody>
</table>
<h4 id="缺省匹配">4. 缺省匹配：</h4>
<p>就是相当于不写，匹配所有的url</p>
<pre><code><code>&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></code></pre>
<p><a href="https://www.cnblogs.com/canger/p/6084846.html">参考 servlet的url-pattern匹配规则</a></p>
<h2 id="filter过滤器实现">Filter过滤器实现</h2>
<h3 id="实现filter接口重写方法">1.实现Filter接口，重写方法</h3>
<p>新建一个类，让它实现Filter接口</p>
<pre><code><code>import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

/**
 * @author StarsOne
 * @date Create in  2019/9/14 0014 21:35
 * @description
 */
public class FirstFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println(&quot;过滤器1已过滤...&quot;);
        //必须要有doFilter方法，之后过滤结束就会跳转到匹配的url的Servlet中进行业务逻辑处理
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {

    }
}
</code></code></pre>
<h3 id="配置web.xml文件">配置web.xml文件</h3>
<p>规则和Servlet的配置差不多，这里就不过多解释了</p>
<pre><code><code>&lt;filter&gt;
    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;!--如果有多个，过滤器的顺序就是按照web.xml中的过滤器顺序进行过滤 --&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;
    &lt;!--指定过滤全部的url --&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></code></pre>
<h3 id="测试">测试</h3>
<p>测试，会发现点击链接后，控制台输出了两次，这也是侧面说明了请求重定向，客户端发出了两次请求</p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>