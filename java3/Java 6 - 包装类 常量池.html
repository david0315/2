<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java 6 - 包装类 常量池' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java 6 - 包装类 常量池</center></div><div class='banquan'>原文出处:本文由博客园博主CoderJerry提供。<br/>
原文连接:https://www.cnblogs.com/yangyuanhu/p/11909467.html</div><br>
    <h2 id="概述">概述:</h2>
<p>在Java中存在一些基本数据类型,这些基本数据类型变量,不能像其他对象一样调用方法,属性....</p>
<p>一些情况下带来一些问题,包装类就是为了解决这个问题而出现</p>
<p><img src="./images/Java 6 - 包装类 常量池0.png" alt="image-20191121120735523" /></p>
<p>包装类可以使得这些基础数据类型,拥有对象的能力</p>
<p><img src="./images/Java 6 - 包装类 常量池1.png" alt="image-20191121121001152" /></p>
<h2 id="包装类与基础类型的对应关系">包装类与基础类型的对应关系</h2>
<p><img src="./images/Java 6 - 包装类 常量池2.png" alt="image-20191121120904649" /></p>
<h2 id="特点">特点:</h2>
<ul>
<li>包装类都是final修饰无法继承</li>
<li>数字类型的父类都是Number</li>
<li>当包装类作为类属性时,其默认值都为Null</li>
</ul>
<h2 id="拆箱与装箱">拆箱与装箱</h2>
<p>拆箱指的是将基础数据类型包装为对象,拆箱与之相反</p>
<ul>
<li><p>自动装箱</p>
<p>将基础数据类型直接赋值给对应包装类的引用变量,系统会自动进行装箱操作</p>
<pre><code><code>Integer a = 10;</code></code></pre></li>
<li><p>自动拆箱</p>
<pre><code><code>Integer a = new Integer(10);
int b = a;</code></code></pre></li>
<li><p>手动拆箱</p>
<pre><code><code>Integer a = new Integer(10);
int b = a.intValue();</code></code></pre></li>
<li><p>手动装箱/装箱</p>
<pre><code><code>Integer as = new Integer(10);//装箱
Integer.valueOf(1);//装箱
Float.valueOf(1.1);//装箱
....

as.intValue();//拆箱</code></code></pre>
<p>通常我们不需要进行手动拆装箱</p></li>
</ul>
<h2 id="自动拆箱的时机">自动拆箱的时机</h2>
<p>1.将包装类型变量直接赋值给对应基础类型时,系统会自动进行拆箱操作</p>
<p>2.当要访问这个对象的真实数据值时会进行自动拆箱,例如要输出对象的值</p>
<p>3.当要对包装类的实际值进行数学运算时,会自动拆箱,例如比较大小</p>
<h5 id="需要注意的是当使用判断是否相等时符号任意一边是基础数据类型另外一边都会自动拆箱不会出问题但如果两边都是包装类型则会比较对象引用是否相同可能产生问题">需要注意的是,当使用==判断是否相等时,==符号任意一边是基础数据类型另外一边都会自动拆箱(不会出问题),但如果两边都是包装类型则会比较对象引用是否相同(可能产生问题)</h5>
<pre><code><code>Integer i1 = new Integer(10);
Integer i2 = new Integer(10);
System.out.println(i1 == i2); //结果为false</code></code></pre>
<h3 id="字符串与包装类互相转换">字符串与包装类互相转换</h3>
<p>在开发中经常需要将基础数据类型与字符串类型相互转换</p>
<pre><code><code>//我们可以使用包装类提供的valueof()方法来将字符串转为对象的包装类
System.out.println(Float.valueOf(&quot;1.1ff&quot;));
System.out.println(Boolean.valueOf(&quot;true&quot;));
//相反的String提供了静态方法valueOf() 其他任意类型转换为字符串类型  Object表示所有类均可,包括包装类
System.out.println(String.valueOf(&#39;c&#39;));
System.out.println(String.valueOf(true));</code></code></pre>
<h2 id="对象常量池">对象常量池</h2>
<p>Java虚拟机会默认将一些简单的字面量对象放到常量池中,来减少频繁的内存操作;是一种优化机制;</p>
<p>测试代码:</p>
<pre><code><code>Long s1 = Long.valueOf(127l);
Long s2 = 127l;
Long s3 = new Long(127l);
System.out.println(s1 == s2); //true
System.out.println(s1 == s3); //false

String st1 = &quot;常量池噢噢噢噢&quot;;
String st2 = &quot;常量池噢噢噢噢&quot;;
String st3 = new String(&quot;常量池噢噢噢噢&quot;);
System.out.println(st1 == st2); //true
System.out.println(st1 == st3); //false

Boolean b1 = true;
Boolean b2 = true;
Boolean b3 = new Boolean(true);
System.out.println(b1 == b2); //true
System.out.println(b1 == b3); //false

Character c1 = &#39;a&#39;;
Character c2 = &#39;a&#39;;
Character c3 = new Character(&#39;a&#39;);
System.out.println(c1 == c2); // true
System.out.println(c1 == c3); // false

Float f1 = 1.0f;
Float f2 = 1.0f;
Float f3 = new Float(1.0f);
System.out.println(f1 == f2);//flase
System.out.println(f1 == f3);//flase

Double d1 = 1d;
Double d2 = 1d;
Double d3 = new Double(1d);
System.out.println(d1==d2);//flase
System.out.println(d1==d3);//flase</code></code></pre>
<ul>
<li>String类型的所有字面量都会进入常量池</li>
<li>Byte Short Integer Long 四种类型字面量在大于等于 -128 且小于等于127 时对象将进入常量池</li>
<li>Character 类型 不能为负数,字面量大于等于0 且 小于等于127时对象将进入常量池</li>
<li>Boolean类型 两个字面量都会进入常量池</li>
<li>Float 和Double 类型 不会进入常量池</li>
</ul>
<h4 id="强调">强调:</h4>
<p>字面量的意思是说,在编译期间就直接指定了实际值,非常明确的数据</p>
<p>这意味着当我们没有使用字面量而是使用 new关键字时,对象将直接进入堆区而不会进入常量池 ,请看下面的例子:</p>
<pre><code><code>Integer a1 = new Integer(10);
Integer a2 = new Integer(10);
System.out.println(a1 == a2);  //false</code></code></pre>
<p>一旦出现了new 则必然要开辟新内存空间,无法利用常量池了!因此建议在代码中尽量使用字面量避免使用new;<br />
补充说明:<br />
这些包装类,以及String类提供的静态方法valueOf();都会先访问常量池,而不是立即new, 所以使用字面量或者valueOf方法都可以利用常量池;</p>
<h4 id="注意">注意:</h4>
<p>基础数据类型不需要缓存到常量池中因为基础数据类型不存在引用这么一说,就是一个实际的值随方法存储在栈区;</p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>