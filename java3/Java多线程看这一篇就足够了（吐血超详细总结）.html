<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java多线程看这一篇就足够了（吐血超详细总结）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java多线程看这一篇就足够了（吐血超详细总结）</center></div><div class='banquan'>原文出处:本文由博客园博主Java团长提供。<br/>
原文连接:https://www.cnblogs.com/java1024/p/11950129.html</div><br>
    <h1>进程与线程</h1>
<p>进程是程序的一次动态执行过程，它需要经历从代码加载，代码执行到执行完毕的一个完整的过程，这个过程也是进程本身从产生，发展到最终消亡的过程。多进程操作系统能同时达运行多个进程（程序），由于 CPU 具备分时机制，所以每个进程都能循环获得自己的CPU 时间片。由于 CPU 执行速度非常快，使得所有程序好像是在同时运行一样。</p>
<p>多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是进程的基础之上进行进一步的划分。所谓多线程是指一个进程在执行过程中可以产生多个更小的程序单元，这些更小的单元称为线程，这些线程可以同时存在，同时运行，一个进程可能包含多个同时执行的线程。进程与线程的区别如图所示：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="27"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）0.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）0.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）0.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /></span></p>
<h1>Java中线程实现的方式</h1>
<p>在 Java 中实现多线程有两种手段，一种是继承 Thread 类，另一种就是实现 Runnable 接口。下面我们就分别来介绍这两种方式的使用。</p>
<p><strong>实现 Runnable 接口</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> ljz; 
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;"> 实现Runnable接口，作为线程的实现类 </span>
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">private</span> String name ;       <span style="color: #008000;">//</span><span style="color: #008000;"> 表示线程的名称 </span>
<span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> MyThread(String name){ 
</span><span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">this</span>.name = name ;      <span style="color: #008000;">//</span><span style="color: #008000;"> 通过构造方法配置name属性 </span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法，作为线程 的操作主体 </span>
<span style="color: #008080;"> 8</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;10;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 9</span>             System.out.println(name + "运行，i = " +<span style="color: #000000;"> i) ; 
</span><span style="color: #008080;">10</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">13</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> RunnableDemo01{ 
</span><span style="color: #008080;">14</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">15</span>         MyThread mt1 = <span style="color: #0000ff;">new</span> MyThread("线程A ") ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化对象 </span>
<span style="color: #008080;">16</span>         MyThread mt2 = <span style="color: #0000ff;">new</span> MyThread("线程B ") ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化对象 </span>
<span style="color: #008080;">17</span>         Thread t1 = <span style="color: #0000ff;">new</span> Thread(mt1) ;       <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Thread类对象 </span>
<span style="color: #008080;">18</span>         Thread t2 = <span style="color: #0000ff;">new</span> Thread(mt2) ;       <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Thread类对象 </span>
<span style="color: #008080;">19</span>         t1.start() ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 启动多线程 </span>
<span style="color: #008080;">20</span>         t2.start() ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 启动多线程 </span>
<span style="color: #008080;">21</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">22</span> };</code></pre>

<p>程序运行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="25"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）1.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）1.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）1.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /></span></p>
<p><strong>继承 Thread 类</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">extends</span> Thread{  <span style="color: #008000;">//</span><span style="color: #008000;"> 继承Thread类，作为线程的实现类 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> String name ;       <span style="color: #008000;">//</span><span style="color: #008000;"> 表示线程的名称 </span>
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> MyThread(String name){ 
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">this</span>.name = name ;      <span style="color: #008000;">//</span><span style="color: #008000;"> 通过构造方法配置name属性 </span>
<span style="color: #008080;"> 5</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法，作为线程 的操作主体 </span>
<span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;10;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 8</span>             System.out.println(name + "运行，i = " +<span style="color: #000000;"> i) ; 
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">11</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">12</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadDemo02{ 
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">14</span>         MyThread mt1 = <span style="color: #0000ff;">new</span> MyThread("线程A ") ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化对象 </span>
<span style="color: #008080;">15</span>         MyThread mt2 = <span style="color: #0000ff;">new</span> MyThread("线程B ") ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化对象 </span>
<span style="color: #008080;">16</span>         mt1.start() ;   <span style="color: #008000;">//</span><span style="color: #008000;"> 调用线程主体 </span>
<span style="color: #008080;">17</span>         mt2.start() ;   <span style="color: #008000;">//</span><span style="color: #008000;"> 调用线程主体 </span>
<span style="color: #008080;">18</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">19</span> };</code></pre>

<p>程序运行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="23"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）2.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）2.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）2.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container" style="background: rgba(220,220,220,0.5); background-image: url('https://csdnimg.cn/release/blog_editor_html/release1.5.9/ckeditor/plugins/widget/images/handle.png');"><img class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="" width="15" height="15" data-cke-widget-drag-handler="1" /></span><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></p>
<p>从程序可以看出，现在的两个线程对象是交错运行的，哪个线程对象抢到了 CPU 资源，哪个线程就可以运行，所以程序每次的运行结果肯定是不一样的，在线程启动虽然调用的是 start() 方法，但实际上调用的却是 run() 方法定义的主体。</p>
<p><strong>Thread 类和 Runnable 接口</strong></p>
<p>通过 Thread 类和 Runable 接口都可以实现多线程，那么两者有哪些联系和区别呢？下面我们观察 Thread 类的定义。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Thread <span style="color: #0000ff;">extends</span> Object <span style="color: #0000ff;">implements</span> Runnable</code></pre>

<p>从 Thread 类的定义可以清楚的发现，Thread 类也是 Runnable 接口的子类，但在Thread类中并没有完全实现 Runnable 接口中的 run() 方法，下面是 Thread 类的部分定义。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #000000;">Private Runnable target； 
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">public</span><span style="color: #000000;"> Thread(Runnable target,String name){ 
</span><span style="color: #008080;"> 3</span>     init(<span style="color: #0000ff;">null</span>,target,name,0<span style="color: #000000;">); 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">} 
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> init(ThreadGroup g,Runnable target,String name,<span style="color: #0000ff;">long</span><span style="color: #000000;"> stackSize){ 
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">    ... 
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">this</span>.target=<span style="color: #000000;">target; 
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">} 
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){ 
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">if</span>(target!=<span style="color: #0000ff;">null</span><span style="color: #000000;">){ 
</span><span style="color: #008080;">11</span> <span style="color: #000000;">        target.run(); 
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">13</span> }</code></pre>

<p>从定义中可以发现，在 Thread 类中的 run() 方法调用的是 Runnable 接口中的 run() 方法，也就是说此方法是由 Runnable 子类完成的，所以如果要通过继承 Thread 类实现多线程，则必须覆写 run()。</p>
<p>实际上 Thread 类和 Runnable 接口之间在使用上也是有区别的，如果一个类继承 Thread类，则不适合于多个线程共享资源，而实现了 Runnable 接口，就可以方便的实现资源的共享。</p>
<h1>线程的状态变化</h1>
<p>要想实现多线程，必须在主线程中创建新的线程对象。任何线程一般具有5种状态，即创建，就绪，运行，阻塞，终止。下面分别介绍一下这几种状态：</p>
<ul>
<li>
<p>创建状态&nbsp;</p>
</li>
</ul>
<p>在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时它已经有了相应的内存空间和其他资源，但还处于不可运行状态。新建一个线程对象可采用Thread 类的构造方法来实现，例如 &ldquo;Thread thread=new Thread()&rdquo;。</p>
<ul>
<li>
<p>就绪状态&nbsp;</p>
</li>
</ul>
<p>新建线程对象后，调用该线程的 start() 方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待 CPU 服务，这表明它已经具备了运行条件。</p>
<ul>
<li>
<p>运行状态&nbsp;</p>
</li>
</ul>
<p>当就绪状态被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的 run() 方法。run() 方法定义该线程的操作和功能。</p>
<ul>
<li>
<p>阻塞状态&nbsp;</p>
</li>
</ul>
<p>一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作，会让 CPU 暂时中止自己的执行，进入阻塞状态。在可执行状态下，如果调用sleep(),suspend(),wait() 等方法，线程都将进入阻塞状态，发生阻塞时线程不能进入排队队列，只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。</p>
<ul>
<li>
<p>死亡状态&nbsp;</p>
</li>
</ul>
<p>线程调用 stop() 方法时或 run() 方法执行结束后，即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。</p>
<p>在此提出一个问题，Java 程序每次运行至少启动几个线程？</p>
<p>回答：至少启动两个线程，每当使用 Java 命令执行一个类时，实际上都会启动一个 JVM，每一个JVM实际上就是在操作系统中启动一个线程，Java 本身具备了垃圾的收集机制。所以在 Java 运行时至少会启动两个线程，一个是 main 线程，另外一个是垃圾收集线程。</p>
<p><strong>取得和设置线程的名称</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;">实现Runnable接口 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){ 
</span><span style="color: #008080;"> 3</span>        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;3;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 4</span>            System.Out.Println(Thread.currentThread().getName()+"运行, i="+i);  <span style="color: #008000;">//</span><span style="color: #008000;">取得当前线程的名称 </span>
<span style="color: #008080;"> 5</span> <span style="color: #000000;">       } 
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  } 
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadDemo{ 
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">11</span>     MyThread my=<span style="color: #0000ff;">new</span> MyThread();  <span style="color: #008000;">//</span><span style="color: #008000;">定义Runnable子类对象 </span>
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">new</span> Thread(my).start;    <span style="color: #008000;">//</span><span style="color: #008000;">系统自动设置线程名称 </span>
<span style="color: #008080;">13</span>     <span style="color: #0000ff;">new</span> Thread(my,"线程A").start();  <span style="color: #008000;">//</span><span style="color: #008000;">手工设置线程名称 </span>
<span style="color: #008080;">14</span> <span style="color: #000000;">  } 
</span><span style="color: #008080;">15</span> };   </code></pre>

<p>程序运行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="19"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）4.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）4.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）4.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<h1>线程的操作方法</h1>
<p>刚才在分析自定义模式工作原理的时候其实就已经提到了，如果想要更改Glide的默认配</p>
<p><strong>线程的强制运行</strong></p>
<p>在线程操作中，可以使用 join() 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;"> 实现Runnable接口 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法 </span>
<span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;50;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">            System.out.println(Thread.currentThread().getName() 
</span><span style="color: #008080;"> 5</span>                     + "运行，i = " + i) ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 取得当前线程的名字 </span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadJoinDemo{ 
</span><span style="color: #008080;">10</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">11</span>         MyThread mt = <span style="color: #0000ff;">new</span> MyThread() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Runnable子类对象 </span>
<span style="color: #008080;">12</span>         Thread t = <span style="color: #0000ff;">new</span> Thread(mt,"线程");     <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Thread对象 </span>
<span style="color: #008080;">13</span>         t.start() ; <span style="color: #008000;">//</span><span style="color: #008000;"> 启动线程 </span>
<span style="color: #008080;">14</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;50;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;">15</span>             <span style="color: #0000ff;">if</span>(i&gt;10<span style="color: #000000;">){ 
</span><span style="color: #008080;">16</span>                 <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;">17</span>                     t.join() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 线程强制运行 </span>
<span style="color: #008080;">18</span>                 }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){
</span><span style="color: #008080;">19</span> <span style="color: #000000;">                } 
</span><span style="color: #008080;">20</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;">21</span>             System.out.println("Main线程运行 --&gt; " +<span style="color: #000000;"> i) ; 
</span><span style="color: #008080;">22</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">23</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">24</span> };</code></pre>

<p>程序运行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="17"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）5.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）5.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）5.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<p><strong>线程的休眠</strong></p>
<p>在程序中允许一个线程进行暂时的休眠，直接使用 Thread.sleep() 即可实现休眠。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;"> 实现Runnable接口 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法 </span>
<span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;50;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 4</span>             <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;"> 5</span>                 Thread.sleep(500) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 线程休眠 </span>
<span style="color: #008080;"> 6</span>             }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">            System.out.println(Thread.currentThread().getName() 
</span><span style="color: #008080;"> 9</span>                     + "运行，i = " + i) ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 取得当前线程的名字 </span>
<span style="color: #008080;">10</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">13</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadSleepDemo{ 
</span><span style="color: #008080;">14</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">15</span>         MyThread mt = <span style="color: #0000ff;">new</span> MyThread() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Runnable子类对象 </span>
<span style="color: #008080;">16</span>         Thread t = <span style="color: #0000ff;">new</span> Thread(mt,"线程");     <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Thread对象 </span>
<span style="color: #008080;">17</span>         t.start() ; <span style="color: #008000;">//</span><span style="color: #008000;"> 启动线程 </span>
<span style="color: #008080;">18</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">19</span> };</code></pre>

<p>程序执行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="15"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）6.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）6.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）6.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<p><strong>中断线程</strong></p>
<p>当一个线程运行时，另外一个线程可以直接通过interrupt()方法中断其运行状态。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;"> 实现Runnable接口 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法 </span>
<span style="color: #008080;"> 3</span>         System.out.println("1、进入run()方法"<span style="color: #000000;">) ; 
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;"> 5</span>             Thread.sleep(10000) ;   <span style="color: #008000;">//</span><span style="color: #008000;"> 线程休眠10秒 </span>
<span style="color: #008080;"> 6</span>             System.out.println("2、已经完成了休眠"<span style="color: #000000;">) ; 
</span><span style="color: #008080;"> 7</span>         }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){ 
</span><span style="color: #008080;"> 8</span>             System.out.println("3、休眠被终止"<span style="color: #000000;">) ; 
</span><span style="color: #008080;"> 9</span>             <span style="color: #0000ff;">return</span> ; <span style="color: #008000;">//</span><span style="color: #008000;"> 返回调用处 </span>
<span style="color: #008080;">10</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">11</span>         System.out.println("4、run()方法正常结束"<span style="color: #000000;">) ; 
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">13</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">14</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadInterruptDemo{ 
</span><span style="color: #008080;">15</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">16</span>         MyThread mt = <span style="color: #0000ff;">new</span> MyThread() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Runnable子类对象 </span>
<span style="color: #008080;">17</span>         Thread t = <span style="color: #0000ff;">new</span> Thread(mt,"线程");     <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Thread对象 </span>
<span style="color: #008080;">18</span>         t.start() ; <span style="color: #008000;">//</span><span style="color: #008000;"> 启动线程 </span>
<span style="color: #008080;">19</span>         <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;">20</span>             Thread.sleep(2000) ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 线程休眠2秒 </span>
<span style="color: #008080;">21</span>         }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){ 
</span><span style="color: #008080;">22</span>             System.out.println("3、休眠被终止"<span style="color: #000000;">) ; 
</span><span style="color: #008080;">23</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">24</span>         t.interrupt() ; <span style="color: #008000;">//</span><span style="color: #008000;"> 中断线程执行 </span>
<span style="color: #008080;">25</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">26</span> };</code></pre>

<p>程序运行结果是：</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="13"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）7.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）7.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）7.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<p><strong>后台线程</strong></p>
<p>在 Java 程序中，只要前台有一个线程在运行，则整个 Java 进程都不会消失，所以此时可以设置一个后台线程，这样即使 Java 线程结束了，此后台线程依然会继续执行，要想实现这样的操作，直接使用 setDaemon() 方法即可。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;"> 实现Runnable接口 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法 </span>
<span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){ 
</span><span style="color: #008080;"> 4</span>             System.out.println(Thread.currentThread().getName() + "在运行。"<span style="color: #000000;">) ; 
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadDaemonDemo{ 
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">10</span>         MyThread mt = <span style="color: #0000ff;">new</span> MyThread() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Runnable子类对象 </span>
<span style="color: #008080;">11</span>         Thread t = <span style="color: #0000ff;">new</span> Thread(mt,"线程");     <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化Thread对象 </span>
<span style="color: #008080;">12</span>         t.setDaemon(<span style="color: #0000ff;">true</span>) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 此线程在后台运行 </span>
<span style="color: #008080;">13</span>         t.start() ; <span style="color: #008000;">//</span><span style="color: #008000;"> 启动线程 </span>
<span style="color: #008080;">14</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">15</span> };</code></pre>

<p>在线程类 MyThread 中，尽管 run() 方法中是死循环的方式，但是程序依然可以执行完，因为方法中死循环的线程操作已经设置成后台运行。</p>
<p><strong>线程的优先级</strong></p>
<p>在 Java 的线程操作中，所有的线程在运行前都会保持在就绪状态，那么此时，哪个线程的优先级高，哪个线程就有可能会先被执行。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;"> 实现Runnable接口 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法 </span>
<span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;5;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 4</span>             <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;"> 5</span>                 Thread.sleep(500) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 线程休眠 </span>
<span style="color: #008080;"> 6</span>             }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">            System.out.println(Thread.currentThread().getName() 
</span><span style="color: #008080;"> 9</span>                     + "运行，i = " + i) ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 取得当前线程的名字 </span>
<span style="color: #008080;">10</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">13</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadPriorityDemo{ 
</span><span style="color: #008080;">14</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">15</span>         Thread t1 = <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span> MyThread(),"线程A") ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化线程对象 </span>
<span style="color: #008080;">16</span>         Thread t2 = <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span> MyThread(),"线程B") ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化线程对象 </span>
<span style="color: #008080;">17</span>         Thread t3 = <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span> MyThread(),"线程C") ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化线程对象 </span>
<span style="color: #008080;">18</span>         t1.setPriority(Thread.MIN_PRIORITY) ;   <span style="color: #008000;">//</span><span style="color: #008000;"> 优先级最低 </span>
<span style="color: #008080;">19</span>         t2.setPriority(Thread.MAX_PRIORITY) ;   <span style="color: #008000;">//</span><span style="color: #008000;"> 优先级最高 </span>
<span style="color: #008080;">20</span>         t3.setPriority(Thread.NORM_PRIORITY) ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 优先级最中等 </span>
<span style="color: #008080;">21</span>         t1.start() ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 启动线程 </span>
<span style="color: #008080;">22</span>         t2.start() ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 启动线程 </span>
<span style="color: #008080;">23</span>         t3.start() ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 启动线程 </span>
<span style="color: #008080;">24</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">25</span> };</code></pre>

<p>程序运行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="10"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）8.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）8.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）8.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<p>从程序的运行结果中可以观察到，线程将根据其优先级的大小来决定哪个线程会先运行，但是需要注意并非优先级越高就一定会先执行，哪个线程先执行将由 CPU 的调度决定。</p>
<p><strong>线程的礼让</strong></p>
<p>在线程操作中，也可以使用 yield() 方法将一个线程的操作暂时让给其他线程执行</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span> Runnable{ <span style="color: #008000;">//</span><span style="color: #008000;"> 实现Runnable接口 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法 </span>
<span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;5;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 4</span>             <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;"> 5</span>                 Thread.sleep(500<span style="color: #000000;">) ; 
</span><span style="color: #008080;"> 6</span>             }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(Exception e){
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">            System.out.println(Thread.currentThread().getName() 
</span><span style="color: #008080;"> 9</span>                     + "运行，i = " + i) ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 取得当前线程的名字 </span>
<span style="color: #008080;">10</span>             <span style="color: #0000ff;">if</span>(i==2<span style="color: #000000;">){ 
</span><span style="color: #008080;">11</span>                 System.out.print("线程礼让："<span style="color: #000000;">) ; 
</span><span style="color: #008080;">12</span>                 Thread.currentThread().yield() ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 线程礼让 </span>
<span style="color: #008080;">13</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;">14</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">16</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">17</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ThreadYieldDemo{ 
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">19</span>         MyThread my = <span style="color: #0000ff;">new</span> MyThread() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化MyThread对象 </span>
<span style="color: #008080;">20</span>         Thread t1 = <span style="color: #0000ff;">new</span> Thread(my,"线程A"<span style="color: #000000;">) ; 
</span><span style="color: #008080;">21</span>         Thread t2 = <span style="color: #0000ff;">new</span> Thread(my,"线程B"<span style="color: #000000;">) ; 
</span><span style="color: #008080;">22</span> <span style="color: #000000;">        t1.start() ; 
</span><span style="color: #008080;">23</span> <span style="color: #000000;">        t2.start() ; 
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">25</span> };</code></pre>

<p>程序执行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="8"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）9.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）9.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）9.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<h1>同步以及死锁</h1>
<p>一个多线程的程序如果是通过 Runnable 接口实现的，则意味着类中的属性被多个线程共享，那么这样就会造成一种问题，如果这多个线程要操作同一个资源时就有可能出现资源同步问题。</p>
<p>解决方法：</p>
<p><strong>同步代码块</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(同步对象)｛ 
</span><span style="color: #008080;">2</span> <span style="color: #000000;"> 需要同步的代码 
</span><span style="color: #008080;">3</span> ｝</code></pre>

<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{ 
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> ticket = 5 ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 假设一共有5张票 </span>
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){ 
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;100;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 5</span>             <span style="color: #0000ff;">synchronized</span>(<span style="color: #0000ff;">this</span>){ <span style="color: #008000;">//</span><span style="color: #008000;"> 要对当前对象进行同步 </span>
<span style="color: #008080;"> 6</span>                 <span style="color: #0000ff;">if</span>(ticket&gt;0){   <span style="color: #008000;">//</span><span style="color: #008000;"> 还有票 </span>
<span style="color: #008080;"> 7</span>                     <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;"> 8</span>                         Thread.sleep(300) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 加入延迟 </span>
<span style="color: #008080;"> 9</span>                     }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){ 
</span><span style="color: #008080;">10</span> <span style="color: #000000;">                        e.printStackTrace() ; 
</span><span style="color: #008080;">11</span> <span style="color: #000000;">                    } 
</span><span style="color: #008080;">12</span>                     System.out.println("卖票：ticket = " + ticket--<span style="color: #000000;"> ); 
</span><span style="color: #008080;">13</span> <span style="color: #000000;">                } 
</span><span style="color: #008080;">14</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;">15</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">16</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">17</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">18</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SyncDemo02{ 
</span><span style="color: #008080;">19</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">20</span>         MyThread mt = <span style="color: #0000ff;">new</span> MyThread() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 定义线程对象 </span>
<span style="color: #008080;">21</span>         Thread t1 = <span style="color: #0000ff;">new</span> Thread(mt) ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 定义Thread对象 </span>
<span style="color: #008080;">22</span>         Thread t2 = <span style="color: #0000ff;">new</span> Thread(mt) ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 定义Thread对象 </span>
<span style="color: #008080;">23</span>         Thread t3 = <span style="color: #0000ff;">new</span> Thread(mt) ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 定义Thread对象 </span>
<span style="color: #008080;">24</span> <span style="color: #000000;">        t1.start() ; 
</span><span style="color: #008080;">25</span> <span style="color: #000000;">        t2.start() ; 
</span><span style="color: #008080;">26</span> <span style="color: #000000;">        t3.start() ; 
</span><span style="color: #008080;">27</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">28</span> };</code></pre>

<p>程序执行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="5"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）10.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）10.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）10.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<p><strong>同步方法</strong></p>
<p>除了可以将需要的代码设置成同步代码块外，也可以使用 synchronized 关键字将一个方法声明为同步方法。</p>
<src class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_wrapper_has cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="代码段" data-cke-widget-id="4">
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">synchronized</span><span style="color: #000000;"> 方法返回值 方法名称（参数列表）｛ 
</span><span style="color: #008080;">2</span> 
<span style="color: #008080;">3</span> ｝</code></pre>

<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{ 
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> ticket = 5 ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 假设一共有5张票 </span>
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){ 
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;100;i++<span style="color: #000000;">){ 
</span><span style="color: #008080;"> 5</span>             <span style="color: #0000ff;">this</span>.sale() ;   <span style="color: #008000;">//</span><span style="color: #008000;"> 调用同步方法 </span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span> sale(){    <span style="color: #008000;">//</span><span style="color: #008000;"> 声明同步方法 </span>
<span style="color: #008080;"> 9</span>         <span style="color: #0000ff;">if</span>(ticket&gt;0){   <span style="color: #008000;">//</span><span style="color: #008000;"> 还有票 </span>
<span style="color: #008080;">10</span>             <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;">11</span>                 Thread.sleep(300) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 加入延迟 </span>
<span style="color: #008080;">12</span>             }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){ 
</span><span style="color: #008080;">13</span> <span style="color: #000000;">                e.printStackTrace() ; 
</span><span style="color: #008080;">14</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;">15</span>             System.out.println("卖票：ticket = " + ticket--<span style="color: #000000;"> ); 
</span><span style="color: #008080;">16</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">19</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">20</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SyncDemo03{ 
</span><span style="color: #008080;">21</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">22</span>         MyThread mt = <span style="color: #0000ff;">new</span> MyThread() ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 定义线程对象 </span>
<span style="color: #008080;">23</span>         Thread t1 = <span style="color: #0000ff;">new</span> Thread(mt) ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 定义Thread对象 </span>
<span style="color: #008080;">24</span>         Thread t2 = <span style="color: #0000ff;">new</span> Thread(mt) ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 定义Thread对象 </span>
<span style="color: #008080;">25</span>         Thread t3 = <span style="color: #0000ff;">new</span> Thread(mt) ;    <span style="color: #008000;">//</span><span style="color: #008000;"> 定义Thread对象 </span>
<span style="color: #008080;">26</span> <span style="color: #000000;">        t1.start() ; 
</span><span style="color: #008080;">27</span> <span style="color: #000000;">        t2.start() ; 
</span><span style="color: #008080;">28</span> <span style="color: #000000;">        t3.start() ; 
</span><span style="color: #008080;">29</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">30</span> };</code></pre>


<p>程序执行结果：&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="2"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）10.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）10.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）10.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸"><br /></span></span></p>
<p>从程序运行的结果可以发现，此代码完成了与之前同步代码同样的功能。</p>
<p><strong>死锁</strong></p>
<p>同步可以保证资源共享操作的正确性，但是过多同步也会产生问题。例如，现在张三想要李四的画，李四想要张三的书，张三对李四说&ldquo;把你的画给我，我就给你书&rdquo;，李四也对张三说&ldquo;把你的书给我，我就给你画&rdquo;两个人互相等对方先行动，就这么干等没有结果，这实际上就是死锁的概念。</p>
<p>所谓死锁，就是两个线程都在等待对方先完成，造成程序的停滞，一般程序的死锁都是在程序运行时出现的。</p>
<p>下面以一个简单范例说明这个概念</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span> Zhangsan{ <span style="color: #008000;">//</span><span style="color: #008000;"> 定义张三类 </span>
<span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> say(){ 
</span><span style="color: #008080;"> 3</span>         System.out.println("张三对李四说：&ldquo;你给我画，我就把书给你。&rdquo;"<span style="color: #000000;">) ; 
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> get(){ 
</span><span style="color: #008080;"> 6</span>         System.out.println("张三得到画了。"<span style="color: #000000;">) ; 
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">class</span> Lisi{ <span style="color: #008000;">//</span><span style="color: #008000;"> 定义李四类 </span>
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> say(){ 
</span><span style="color: #008080;">11</span>         System.out.println("李四对张三说：&ldquo;你给我书，我就把画给你&rdquo;"<span style="color: #000000;">) ; 
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> get(){ 
</span><span style="color: #008080;">14</span>         System.out.println("李四得到书了。"<span style="color: #000000;">) ; 
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">16</span> <span style="color: #000000;">}; 
</span><span style="color: #008080;">17</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ThreadDeadLock <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable{ 
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> Zhangsan zs = <span style="color: #0000ff;">new</span> Zhangsan() ;       <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化static型对象 </span>
<span style="color: #008080;">19</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> Lisi ls = <span style="color: #0000ff;">new</span> Lisi() ;       <span style="color: #008000;">//</span><span style="color: #008000;"> 实例化static型对象 </span>
<span style="color: #008080;">20</span>     <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">boolean</span> flag = <span style="color: #0000ff;">false</span> ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 声明标志位，判断那个先说话 </span>
<span style="color: #008080;">21</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){  <span style="color: #008000;">//</span><span style="color: #008000;"> 覆写run()方法 </span>
<span style="color: #008080;">22</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;">(flag){ 
</span><span style="color: #008080;">23</span>             <span style="color: #0000ff;">synchronized</span>(zs){   <span style="color: #008000;">//</span><span style="color: #008000;"> 同步张三 </span>
<span style="color: #008080;">24</span> <span style="color: #000000;">                zs.say() ; 
</span><span style="color: #008080;">25</span>                 <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;">26</span>                     Thread.sleep(500<span style="color: #000000;">) ; 
</span><span style="color: #008080;">27</span>                 }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){ 
</span><span style="color: #008080;">28</span> <span style="color: #000000;">                    e.printStackTrace() ; 
</span><span style="color: #008080;">29</span> <span style="color: #000000;">                } 
</span><span style="color: #008080;">30</span>                 <span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(ls){ 
</span><span style="color: #008080;">31</span> <span style="color: #000000;">                    zs.get() ; 
</span><span style="color: #008080;">32</span> <span style="color: #000000;">                } 
</span><span style="color: #008080;">33</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;">34</span>         }<span style="color: #0000ff;">else</span><span style="color: #000000;">{ 
</span><span style="color: #008080;">35</span>             <span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(ls){ 
</span><span style="color: #008080;">36</span> <span style="color: #000000;">                ls.say() ; 
</span><span style="color: #008080;">37</span>                 <span style="color: #0000ff;">try</span><span style="color: #000000;">{ 
</span><span style="color: #008080;">38</span>                     Thread.sleep(500<span style="color: #000000;">) ; 
</span><span style="color: #008080;">39</span>                 }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e){ 
</span><span style="color: #008080;">40</span> <span style="color: #000000;">                    e.printStackTrace() ; 
</span><span style="color: #008080;">41</span> <span style="color: #000000;">                } 
</span><span style="color: #008080;">42</span>                 <span style="color: #0000ff;">synchronized</span><span style="color: #000000;">(zs){ 
</span><span style="color: #008080;">43</span> <span style="color: #000000;">                    ls.get() ; 
</span><span style="color: #008080;">44</span> <span style="color: #000000;">                } 
</span><span style="color: #008080;">45</span> <span style="color: #000000;">            } 
</span><span style="color: #008080;">46</span> <span style="color: #000000;">        } 
</span><span style="color: #008080;">47</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">48</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]){ 
</span><span style="color: #008080;">49</span>         ThreadDeadLock t1 = <span style="color: #0000ff;">new</span> ThreadDeadLock() ;      <span style="color: #008000;">//</span><span style="color: #008000;"> 控制张三 </span>
<span style="color: #008080;">50</span>         ThreadDeadLock t2 = <span style="color: #0000ff;">new</span> ThreadDeadLock() ;      <span style="color: #008000;">//</span><span style="color: #008000;"> 控制李四 </span>
<span style="color: #008080;">51</span>         t1.flag = <span style="color: #0000ff;">true</span><span style="color: #000000;"> ; 
</span><span style="color: #008080;">52</span>         t2.flag = <span style="color: #0000ff;">false</span><span style="color: #000000;"> ; 
</span><span style="color: #008080;">53</span>         Thread thA = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(t1) ; 
</span><span style="color: #008080;">54</span>         Thread thB = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(t2) ; 
</span><span style="color: #008080;">55</span> <span style="color: #000000;">        thA.start() ; 
</span><span style="color: #008080;">56</span> <span style="color: #000000;">        thB.start() ; 
</span><span style="color: #008080;">57</span> <span style="color: #000000;">    } 
</span><span style="color: #008080;">58</span> };</code></pre>

<p>程序运行结果：</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-widget-wrapper="1" data-cke-filter="off" data-cke-display-name="图像" data-cke-widget-id="0"><img class="has cke_widget_element" src="./images/Java多线程看这一篇就足够了（吐血超详细总结）12.png" alt="" data-cke-saved-src="./images/Java多线程看这一篇就足够了（吐血超详细总结）12.png" data-cke-widget-data="{&amp;quot;hasCaption&amp;quot;:false,&amp;quot;src&amp;quot;:&amp;quot;./images/Java多线程看这一篇就足够了（吐血超详细总结）12.png&amp;quot;,&amp;quot;alt&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;width&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;height&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;lock&amp;quot;:true,&amp;quot;align&amp;quot;:&amp;quot;none&amp;quot;,&amp;quot;classes&amp;quot;:{&amp;quot;has&amp;quot;:1}}" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="image" /><br /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></p>
<p>以下代码不再执行，程序进入死锁状态。</p>
<h1>总结</h1>
<p>至此关于多线程一些基本操作就介绍完了，鉴于笔者经验有限，如果有什么不足和缺漏的地方，欢迎相互交流学习，感谢大家！</p>
<hr />
<h3>转自：https://blog.csdn.net/lijizhi19950123/article/details/78024612</h3>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>