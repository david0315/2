<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修单例模式' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>单例模式</center></div><div class='banquan'>原文出处:本文由博客园博主Mrann提供。<br/>
原文连接:https://www.cnblogs.com/lsk-130602/p/11829576.html</div><br>
    <p>单例模式：某个类只能有一个实例，提供一个全局的访问点。</p>
<src>单例模式<br />●核心作用:保证一个类只有一个实例,并且提供一一个访问该实例的全局访问点。
<src>●常见应用场景:<br />一Windows的Task Manager (任务管理器)就是很典型的单例模式<br />windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中,回收站一直维护着仅有的一个实例。<br />项目中,读取配置文件的类,一般也只有一 个对象。 没有必要每次使用配置文件数据,每次new-个对象去读取。<br />网站的计数器,一般也是 采用单例模式实现,否则难以同步。<br />-应用程序的日志应用 , -般都何用单例模式实现,这一般是由于共享的日志文件一直处于打开状态,因为只能有一个实例去操作<br />, 否则内容不好追加。<br />数据库连接池的设计-般也是采用单例模式 ，因为数据库连接是一种数据库资源。<br />-操作系统的文件系统 ,也是大的单例模式实现的具体例子，-个操作系统只能有一个文件系统。<br />Application也是单例的典型应用( Servlet编程中会涉及到)<br />-在Spring中 ,每个Bean默认就是单例的,这样做的优点是Spring容器可以管理<br />-在servlet编程中 ,每个Servlet也是单例<br />-在spring MVC框架/struts1框架中，控制器对象也是单例
<src><br />●单例模式的优点:<br />-由于单例模式只生成一 个实例,减少了系统性能开销,当-个对象的产生需要<br />比较多的资源时,如读取配置、产生其他依赖对象时 ,则可以通过在应用启动<br />时直接产生一个单例对象,然后永久驻留内存的方式来解决<br />单例模式可以在系统设置全局的访问点,优化环共享资源访问,例如可以设计<br />一个单例类,负责所有数据表的映射处理
<src>●常见的五种单例模式实现方式:<br />主要:<br />饿汉式(线程安全,调用效率高。但是,不能延时加载。)<br />//类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！<br />//方法没有同步，调用效率高！<br />public class SingletonDemo1 {<br />&nbsp;<br />&nbsp;//类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！<br />&nbsp;private static SingletonDemo1 instance = new SingletonDemo1();&nbsp; <br />&nbsp;<br />&nbsp;private SingletonDemo1(){<br />&nbsp;}<br />&nbsp;<br />&nbsp;//方法没有同步，调用效率高！<br />&nbsp;public static SingletonDemo1&nbsp; getInstance(){<br />&nbsp;&nbsp;return instance;<br />&nbsp;}<br />&nbsp;<br />}
<src>懒汉式(线程安全,调用效率不高。但是,可以延时加载。)<br />lazy load 延迟加载，懒加载，真正用的时候才去加载<br />资源利用率高了，但是每次调用getInstance都要同步，并发效率低了<br />public class SingletonDemo2 {<br />&nbsp;<br />&nbsp;//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。<br />&nbsp;private static SingletonDemo2 instance;&nbsp; <br />&nbsp;<br />&nbsp;private SingletonDemo2(){ //私有化构造器<br />&nbsp;}<br />&nbsp;<br />&nbsp;//方法同步，调用效率低！<br />&nbsp;public static&nbsp; synchronized SingletonDemo2&nbsp; getInstance(){<br />&nbsp;&nbsp;if(instance==null){<br />&nbsp;&nbsp;&nbsp;instance = new SingletonDemo2();<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;return instance;<br />&nbsp;}<br />&nbsp;<br />}
<src>其他:<br />双重检测锁式(由于JVM底层内部模型原因,偶尔会出问题。不建议使用)
<src>静态内部类式(线程安全,调用效率高。但是,可以延时加载)
<src>枚举单例(线程安全,调用效率高,不能延时加载)
<src>1.测试饿汉式单例模式<br />public class SingletonDemo1 {<br />&nbsp;//类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！<br />&nbsp;private static SingletonDemo1 instance = new SingletonDemo1();&nbsp; <br />&nbsp;private SingletonDemo1(){<br />&nbsp;}<br />&nbsp;//方法没有同步，调用效率高！<br />&nbsp;public static SingletonDemo1&nbsp; getInstance(){<br />&nbsp;&nbsp;return instance;<br />&nbsp;}<br />&nbsp;<br />}
<src>2.测试懒汉式单例模式<br />public class SingletonDemo2 {<br />&nbsp;//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。<br />&nbsp;private static SingletonDemo2 instance;&nbsp; &nbsp;<br />&nbsp;private SingletonDemo2(){ //私有化构造器<br />&nbsp;}<br />&nbsp;//方法同步，调用效率低！<br />&nbsp;public static&nbsp; synchronized SingletonDemo2&nbsp; getInstance(){<br />&nbsp;&nbsp;if(instance==null){<br />&nbsp;&nbsp;&nbsp;instance = new SingletonDemo2();<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;return instance;<br />&nbsp;}<br />&nbsp;<br />}
<src>3. 双重检查锁实现单例模式<br />public class SingletonDemo3 { 
<src>&nbsp; private static SingletonDemo3 instance = null; 
<src>&nbsp; public static SingletonDemo3 getInstance() { <br />&nbsp;&nbsp;&nbsp; if (instance == null) { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SingletonDemo3 sc; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (SingletonDemo3.class) { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc = instance; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sc == null) { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized (SingletonDemo3.class) { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(sc == null) { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc = new SingletonDemo3(); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instance = sc; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp; return instance; <br />&nbsp; } 
<src>&nbsp; private SingletonDemo3() { 
<src>&nbsp; } <br />&nbsp;&nbsp;&nbsp; <br />}
<src>4.测试静态内部类实现单例模式<br />&nbsp;* 这种方式：线程安全，调用效率高，并且实现了延时加载！<br />public class SingletonDemo4 {<br />&nbsp;private static class SingletonClassInstance {<br />&nbsp;&nbsp;private static final SingletonDemo4 instance = new SingletonDemo4();<br />&nbsp;}<br />&nbsp;<br />&nbsp;private SingletonDemo4(){<br />&nbsp;}<br />&nbsp;<br />&nbsp;//方法没有同步，调用效率高！<br />&nbsp;public static SingletonDemo4&nbsp; getInstance(){<br />&nbsp;&nbsp;return SingletonClassInstance.instance;<br />&nbsp;}<br />&nbsp;<br />}
<src>&nbsp;5.测试枚举式实现单例模式(没有延时加载)<br />public enum SingletonDemo5 {<br />&nbsp;//这个枚举元素，本身就是单例对象！<br />&nbsp;INSTANCE;<br />&nbsp;//添加自己需要的操作！<br />&nbsp;public void singletonOperation(){<br />&nbsp;}<br />&nbsp;<br />&nbsp;<br />}
<src><br />&nbsp;* 测试懒汉式单例模式(如何防止反射和反序列化漏洞)<br />public class SingletonDemo6 implements Serializable {<br />&nbsp;//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。<br />&nbsp;private static SingletonDemo6 instance;&nbsp; <br />&nbsp;<br />&nbsp;private SingletonDemo6(){ //私有化构造器<br />&nbsp;&nbsp;if(instance!=null){<br />&nbsp;&nbsp;&nbsp;throw new RuntimeException();<br />&nbsp;&nbsp;}<br />&nbsp;}<br />&nbsp;<br />&nbsp;//方法同步，调用效率低！<br />&nbsp;public static&nbsp; synchronized SingletonDemo6&nbsp; getInstance(){<br />&nbsp;&nbsp;if(instance==null){<br />&nbsp;&nbsp;&nbsp;instance = new SingletonDemo6();<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;return instance;<br />&nbsp;}<br />&nbsp;<br />&nbsp;//反序列化时，如果定义了readResolve()则直接返回此方法指定的对象。而不需要单独再创建新对象！<br />&nbsp;private Object readResolve() throws ObjectStreamException {<br />&nbsp;&nbsp;return instance;<br />&nbsp;}<br />&nbsp;<br />}
<src>测试反射和反序列化破解单例模式<br />public class Client2 {<br />&nbsp;<br />&nbsp;public static void main(String[] args) throws Exception {<br />&nbsp;&nbsp;SingletonDemo6 s1 = SingletonDemo6.getInstance();<br />&nbsp;&nbsp;SingletonDemo6 s2 = SingletonDemo6.getInstance();<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;System.out.println(s1);<br />&nbsp;&nbsp;System.out.println(s2);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;//通过反射的方式直接调用私有构造器<br />&nbsp;&nbsp;Class&lt;SingletonDemo6&gt; clazz = (Class&lt;SingletonDemo6&gt;) Class.forName("com.bjsxt.singleton.SingletonDemo6");<br />&nbsp;&nbsp;Constructor&lt;SingletonDemo6&gt; c = clazz.getDeclaredConstructor(null);<br />&nbsp;&nbsp;c.setAccessible(true);<br />&nbsp;&nbsp;SingletonDemo6&nbsp; s3 = c.newInstance();<br />&nbsp;&nbsp;SingletonDemo6&nbsp; s4 = c.newInstance();<br />&nbsp;&nbsp;System.out.println(s3);<br />&nbsp;&nbsp;System.out.println(s4);<br />&nbsp;}<br />}<br />&nbsp;//通过反序列化的方式构造多个对象 <br />&nbsp;&nbsp;FileOutputStream fos = new FileOutputStream("d:/a.txt");<br />&nbsp;&nbsp;ObjectOutputStream oos = new ObjectOutputStream(fos);<br />&nbsp;&nbsp;oos.writeObject(s1);<br />&nbsp;&nbsp;oos.close();<br />&nbsp;&nbsp;fos.close();<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;ObjectInputStream ois = new ObjectInputStream(new FileInputStream("d:/a.txt"));<br />&nbsp;&nbsp;SingletonDemo6 s3 =&nbsp; (SingletonDemo6) ois.readObject();<br />&nbsp;&nbsp;System.out.println(s3);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;}<br />}
<src>测试枚举式实现单例模式<br />public class Client {<br />&nbsp;<br />&nbsp;public static void main(String[] args) {<br />&nbsp;&nbsp;SingletonDemo4 s1 = SingletonDemo4.getInstance();<br />&nbsp;&nbsp;SingletonDemo4 s2 = SingletonDemo4.getInstance();<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;System.out.println(s1);<br />&nbsp;&nbsp;System.out.println(s2);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;System.out.println(SingletonDemo5.INSTANCE==SingletonDemo5.INSTANCE);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;}<br />}
<src>&nbsp;* 测试多线程环境下五种创建单例模式的效率<br />public class Client3 {<br />&nbsp;<br />&nbsp;public static void main(String[] args) throws Exception {<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;long start = System.currentTimeMillis();<br />&nbsp;&nbsp;int threadNum = 10;<br />&nbsp;&nbsp;final CountDownLatch&nbsp; countDownLatch = new CountDownLatch(threadNum);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;for(int i=0;i&lt;threadNum;i++){<br />&nbsp;&nbsp;&nbsp;new Thread(new Runnable() {<br />&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />&nbsp;&nbsp;&nbsp;&nbsp;public void run() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0;i&lt;1000000;i++){<br />//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object o = SingletonDemo4.getInstance();&nbsp; //测试静态内部类<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object o = SingletonDemo5.INSTANCE;&nbsp;&nbsp; //测试枚举类<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;countDownLatch.countDown();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;}).start();<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;countDownLatch.await();&nbsp;//main线程阻塞，直到计数器变为0，才会继续往下执行！<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;long end = System.currentTimeMillis();<br />&nbsp;&nbsp;System.out.println("总耗时："+(end-start));<br />&nbsp;}<br />}
<src>CountDownLatch<br />-同步辅助类,在完成一组正在其他线程中执行的操作之前,它允许一<br />个或多个线程一直等待。<br />countDown（）当前线程调此方法,则计数减一 (建议放在finally里执行)<br />await(，调用此方法会直阻塞当前线程,直到计时器的值为0）
<src>&nbsp;
<src>&nbsp;

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>