<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Spring源码分析' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Spring源码分析</center></div><div class='banquan'>原文出处:本文由博客园博主陈彦斌提供。<br/>
原文连接:https://www.cnblogs.com/chenyanbin/p/11756034.html</div><br>
    <h1 style="text-align: center;">Spring介绍</h1>
<h2>什么是Spring？</h2>
<p>百度百科的介绍</p>
<p><img src="./images/Spring源码分析0.png" alt="" /></p>
<p>&nbsp;</p>
<p>Spring官方网址：&nbsp;<a href="http://spring.io/"><span>http</span><span>://spring.io/</span></a></p>
<p>我们经常说的Spring其实指的是 <span style="color: #008000;">Spring Framework <span style="color: #000000;">(Spring 框架)</span></span></p>
<h2>为什么学习Spring？</h2>
<p><img src="./images/Spring源码分析1.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;好处</h3>
<p><img src="./images/Spring源码分析2.png" alt="" /></p>
<h2><!--[if !supportLists]--><strong>耦合和内聚介绍</strong></h2>
<p>　　<strong>耦合性</strong>(Coupling)，也叫耦合度，是对模块间关联程度的度量。</p>
<p>　　在软件工程中，耦合指的就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类与架构之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。<span style="color: #ff00ff;">划分模块的一个准则就是高内聚低耦合。</span></p>
<p>　　<strong>内聚标志</strong>一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当适当做一件好事。</p>
<p>　　内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。<span style="color: #ff00ff;">在进行软件设计时，应力争做到高内聚，低耦合</span>。</p>
<h2>Spring体系结构</h2>
<p><img src="./images/Spring源码分析3.png" alt="" /></p>
<p>&nbsp;</p>
<h2>&nbsp;Spring核心概念介绍</h2>
<p>　　<strong>IoC(<span style="color: #ff00ff;">核心中的核心</span>)：Inverse of Control，控制反转</strong>。对象的创建权力由程序反转给Spring框架。</p>
<p>　　<strong>AOP：Aspect Oriented Programming，面向切面编程</strong>。在不修改目标对象的源代码情况下，增强IoC容器中Bean的功能。</p>
<p>　　<strong>DI：Dependency Injection，依赖注入</strong>。在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！</p>
<p>　　<strong>Spring容器：指的就是IoC容器。</strong></p>
<h1 style="text-align: center;">&nbsp;Spring IoC原理分析</h1>
<h2>什么是IoC容器？</h2>
<p>　　所谓的IoC容器就是指的是Spring中<strong>Bean工厂</strong>里面的Map存储结构(<span style="color: #ff0000;">存储了Bean的实例</span>)。</p>
<h2>Spring框架中的工厂有哪些？</h2>
<p>　　<span style="color: #ff0000;">ApplicationContext</span>接口()</p>
<p>　　　　<span style="color: #ff0000;">实现了BeanFactory接口</span></p>
<p>　　　　实现ApplicationContext接口的工厂，可以获取到容器中具体的Bean对象</p>
<p>　　<span style="color: #ff0000;">BeanFactory</span>工厂(<span style="color: #ff0000;">是Spring架构早期的创建Bean对象的工厂接口</span>)</p>
<p>　　　　实现BeanFactory接口的工厂也可以获取到Bean对象</p>
<p>其实通过源码分析，不管是BeanFactory还是ApplicationContext，其实最终的底层BeanFactory都是<span style="color: #ff0000;">DefaultListableBeanFactory</span></p>
<p>　　ApplicationContext和BeanFactory的区别？</p>
<p>　　创建Bean对象的时机不同：</p>
<p>　　　　BeanFactory采取延迟加载，第一次getBean时才会初始化Bean。</p>
<p>　　　　ApplicationContext是加载完applicationContext.xml时，就创建具体的Bean对象的实例。(<span style="color: #ff0000;">只对BeanDefition中描述为时单例的Bean，才进行饿汉堡式加载</span>)</p>
<p><img src="./images/Spring源码分析4.png" alt="" /></p>
<p>&nbsp;</p>
<p><img src="./images/Spring源码分析5.png" alt="" /></p>
<p>&nbsp;</p>
<h2>&nbsp;如何创建Web环境中的IoC容器？</h2>
<h3>创建方式</h3>
<ul>
<li>ApplicationContext接口常用实现类</li>
</ul>
<p>　　　　ClassPathXmlApplicationContext：</p>
<p>　　　　　　它是从类的根路径下加载配置文件　　推荐使用这种</p>
<p>　　　　FileSystemXmlApplicationContext：</p>
<p>　　　　　　它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p>
<p>　　　　AnnotationConfigApplicationContext：</p>
<p>　　　　　　当我们使用注解配置容器对象时，需要使用此类来创建Spring容器。它用来读取注解。</p>
<ul>
<li>Java应用中创建IoC容器：(了解)</li>
</ul>
<p>　　　　ApplicationContext context=<span style="color: #ff0000;">new ClassPathXmlApplicationContext</span>(xml路径);</p>
<ul>
<li>Web应用中创建IoC容器：(重点)</li>
</ul>
<p>　　　　<span style="color: #ff0000;">web.xml中配置ContextLoaderListener接口，并配置ContextConfigLocation参数</span></p>
<p>　　　　web容器启动之后加载web.xml，此时加载<span style="color: #ff0000;">ContextLoaderListener</span>监听器(<span style="color: #ff0000;">实现了ServletContextListener接口，该接口的描述请见下面的《三类八种监听器》</span>)</p>
<p>　　　　ContextLoaderListener监听器会在web容器启动的时候，出发<span style="color: #ff0000;">ContextInitialized</span>()方法</p>
<p>　　　　ContextInitialized()方法会调用<span style="color: #ff0000;">initWebApplicationContext</span>()方法，该方法负责创建Spring容器(<span style="color: #ff0000;">DefaultListableBeanFactory</span>)</p>
<p>【Web三类八种监听器】</p>
<p>　　监听<span style="color: #ff0000;">域对象</span>的生命周期</p>
<p>　　　　ServletContextListener：</p>
<p>　　　　　　创建：服务器启动</p>
<p>　　　　　　销毁：服务器正常关闭</p>
<p>　　　　　　spring ContextLoaderListener(服务器启动时负责加载spring配置文件)</p>
<p>&nbsp;　　　　HttpSessionListener</p>
<p>　　　　　　创建：第一次访问request.getHttpSession()</p>
<p>　　　　　　销毁：调用invalidate()；非法关闭；过期</p>
<p>　　　　ServletRequestListener</p>
<p>　　　　　　创建：每一次访问</p>
<p>　　　　　　销毁：相应结束</p>
<p>　　监听域对象的属性：(添加、删除、替换)</p>
<p>　　　　<span style="color: #ff0000;">ServletContextAttributeListener</span></p>
<p>　　　　HttpSessionAttributeListener</p>
<p>　　　　ServletRequestAttributeListener</p>
<p>　　监听HttpSession中JavaBean的改变：</p>
<p>　　　　HttpSessionBindingListener(HttpSession和JavaBean对象的绑定和解绑)</p>
<p>　　　　HttpSessionActivationListener(HttpSession的序列化，活化，纯化)</p>
<h3>源码分析</h3>
<p>参考资料中的源码中的工程《Spring-sourcecode》</p>
<p><span style="color: #ff0000;">1.web服务器(tomcat)启动会加载web.xml(启动ContextLoaderListener监听器)：</span></p>
<p><img src="./images/Spring源码分析6.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;2.创建web环境中的Spring容器</p>
<p><img src="./images/Spring源码分析7.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;3.ContextLoader类中创建Spring容器并初始化容器中的Bean实例</p>
<p><img src="./images/Spring源码分析8.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;4.configureAndRefreshWebApplicationContext方法中调用初始化Bean的<span style="color: #ff0000;">refresh</span>方法</p>
<p><img src="./images/Spring源码分析9.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;图示</h3>
<p>该图主要是分析上面第三步骤中【创建Spring容器】的图示</p>
<p><img src="./images/Spring源码分析10.png" alt="" /></p>
<p>&nbsp;</p>
<h2>&nbsp;IoC容器如何创建Bean对象？</h2>
<h3>源码分析</h3>
<p>源码来源于<span style="color: #ff0000;">AbstractApplicationContext</span>类：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> refresh() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> BeansException, IllegalStateException {
        </span><span style="color: #0000ff;">synchronized</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.startupShutdownMonitor) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Prepare this context for refreshing.</span>
<span style="color: #000000;">            prepareRefresh();

              </span><span style="color: #008000;">//</span><span style="color: #008000;">1.创建真正的Spring容器（DefaultListableBeanFactory）
              </span><span style="color: #008000;">//</span><span style="color: #008000;">2.加载BeanDefition（描述要初始化的Bean的信息）
              </span><span style="color: #008000;">//</span><span style="color: #008000;">3.将BeanDefition注册到BeanDefitionRegistry
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Tell the subclass to refresh the internal bean factory.</span>
            ConfigurableListableBeanFactory beanFactory =<span style="color: #000000;"> obtainFreshBeanFactory();

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Prepare the bean factory for use in this context.</span>
<span style="color: #000000;">            prepareBeanFactory(beanFactory);

            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Allows post-processing of the bean factory in context subclasses.</span>
<span style="color: #000000;">                postProcessBeanFactory(beanFactory);

                  </span><span style="color: #008000;">//</span><span style="color: #008000;">执行实现了BeanFactoryPostProcessor接口的Bean
                  </span><span style="color: #008000;">//</span><span style="color: #008000;">比如PropertyPlaceHolderConfigurer（context:property-placeholer）就是此处被调用的，替换掉BeanDefition中的占位符（${}）中的内容
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Invoke factory processors registered as beans in the context.</span>
<span style="color: #000000;">                invokeBeanFactoryPostProcessors(beanFactory);

                  </span><span style="color: #008000;">//</span><span style="color: #008000;">注册BeanPostProcessor（后置处理器）
                  </span><span style="color: #008000;">//</span><span style="color: #008000;">比如容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器（实现@Autowired注解功能）
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Register bean processors that intercept bean creation.</span>
<span style="color: #000000;">                registerBeanPostProcessors(beanFactory);

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Initialize message source for this context.</span>
<span style="color: #000000;">                initMessageSource();

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Initialize event multicaster for this context.</span>
<span style="color: #000000;">                initApplicationEventMulticaster();

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Initialize other special beans in specific context subclasses.</span>
<span style="color: #000000;">                onRefresh();

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Check for listener beans and register them.</span>
<span style="color: #000000;">                registerListeners();

                  </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化非懒加载方式的单例Bean实例
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Instantiate all remaining (non-lazy-init) singletons.</span>
<span style="color: #000000;">                finishBeanFactoryInitialization(beanFactory);

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Last step: publish corresponding event.</span>
<span style="color: #000000;">                finishRefresh();
            }

            </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (BeansException ex) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (logger.isWarnEnabled()) {
                    logger.warn(</span>"Exception encountered during context initialization - " +
                            "cancelling refresh attempt: " +<span style="color: #000000;"> ex);
                }

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Destroy already created singletons to avoid dangling resources.</span>
<span style="color: #000000;">                destroyBeans();

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Reset 'active' flag.</span>
<span style="color: #000000;">                cancelRefresh(ex);

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Propagate exception to caller.</span>
                <span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex;
            }

            </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Reset common introspection caches in Spring's core, since we
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> might not ever need metadata for singleton beans anymore...</span>
<span style="color: #000000;">                resetCommonCaches();
            }
        }
    }</span></code></pre>

<h3>图示</h3>
<p><img src="./images/Spring源码分析11.png" alt="" /></p>
<p>&nbsp;</p>
<h1 style="text-align: center;">Spring 容器初始化源码分析</h1>
<h2>容器初始化主流程分析</h2>
<h3><span style="color: #ff0000;">主流程入口</span></h3>
<p class="15"><span style="color: #ff0000;">ApplicationContext context = new ClassPathXmlApplicationContext（&ldquo;spring.xml&rdquo;）</span></p>
<p class="15"><strong>ClassPathXmlApplicationContext类：重载的构造方法依次调用，进入下面代码</strong></p>
<p class="15"><strong><img src="./images/Spring源码分析12.png" alt="" /></strong></p>
<p>&nbsp;</p>
<p><strong>AbstractApplicationContext<span style="font-family: 宋体;">的</span><span style="font-family: 'YaHei Consolas Hybrid';">refresh</span><span style="font-family: 宋体;">方法：初始化</span><span style="font-family: 'YaHei Consolas Hybrid';">spring</span><span style="font-family: 宋体;">容器的核心代码</span></strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> refresh() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> BeansException, IllegalStateException {
        </span><span style="color: #0000ff;">synchronized</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">.startupShutdownMonitor) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">1、 Prepare this context for refreshing.</span>
<span style="color: #000000;">            prepareRefresh();

               </span><span style="color: #008000;">//</span><span style="color: #008000;">创建DefaultListableBeanFactory（真正生产和管理bean的容器）
               </span><span style="color: #008000;">//</span><span style="color: #008000;">加载BeanDefition并注册到BeanDefitionRegistry
               </span><span style="color: #008000;">//</span><span style="color: #008000;">通过NamespaceHandler解析自定义标签的功能（比如:context标签、aop标签、tx标签）
            </span><span style="color: #008000;">//</span><span style="color: #008000;">2、 Tell the subclass to refresh the internal bean factory.</span>
            ConfigurableListableBeanFactory beanFactory =<span style="color: #000000;"> obtainFreshBeanFactory();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">3、 Prepare the bean factory for use in this context.</span>
<span style="color: #000000;">            prepareBeanFactory(beanFactory);

            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;">4、 Allows post-processing of the bean factory in context subclasses.</span>
<span style="color: #000000;">                postProcessBeanFactory(beanFactory);

                     </span><span style="color: #008000;">//</span><span style="color: #008000;">实例化并调用实现了BeanFactoryPostProcessor接口的Bean
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">比如：PropertyPlaceHolderConfigurer（context:property-placeholer）
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">就是此处被调用的，作用是替换掉BeanDefinition中的占位符（${}）中的内容
                </span><span style="color: #008000;">//</span><span style="color: #008000;">5、 Invoke factory processors registered as beans in the context.</span>
<span style="color: #000000;">                invokeBeanFactoryPostProcessors(beanFactory);

                     </span><span style="color: #008000;">//</span><span style="color: #008000;">创建并注册BeanPostProcessor到BeanFactory中（Bean的后置处理器）
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">比如：AutowiredAnnotationBeanPostProcessor（实现@Autowired注解功能）
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">      RequiredAnnotationBeanPostProcessor（实现@d注解功能）
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">这些注册的BeanPostProcessor
                </span><span style="color: #008000;">//</span><span style="color: #008000;">6、 Register bean processors that intercept bean creation.</span>
<span style="color: #000000;">                registerBeanPostProcessors(beanFactory);

                </span><span style="color: #008000;">//</span><span style="color: #008000;">7、 Initialize message source for this context.</span>
<span style="color: #000000;">                initMessageSource();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">8、 Initialize event multicaster for this context.</span>
<span style="color: #000000;">                initApplicationEventMulticaster();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">9、 Initialize other special beans in specific context subclasses.</span>
<span style="color: #000000;">                onRefresh();

                </span><span style="color: #008000;">//</span><span style="color: #008000;">10、 Check for listener beans and register them.</span>
<span style="color: #000000;">                registerListeners();

                     </span><span style="color: #008000;">//</span><span style="color: #008000;">创建非懒加载方式的单例Bean实例（未设置属性）
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">填充属性
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化实例（比如调用init-method方法）
                     </span><span style="color: #008000;">//</span><span style="color: #008000;">调用BeanPostProcessor（后置处理器）对实例bean进行后置处理
                </span><span style="color: #008000;">//</span><span style="color: #008000;">11、 Instantiate all remaining (non-lazy-init) singletons.</span>
<span style="color: #000000;">                finishBeanFactoryInitialization(beanFactory);

                </span><span style="color: #008000;">//</span><span style="color: #008000;">12、 Last step: publish corresponding event.</span>
<span style="color: #000000;">                finishRefresh();
            }

            </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (BeansException ex) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (logger.isWarnEnabled()) {
                    logger.warn(</span>"Exception encountered during context initialization - " +
                            "cancelling refresh attempt: " +<span style="color: #000000;"> ex);
                }

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Destroy already created singletons to avoid dangling resources.</span>
<span style="color: #000000;">                destroyBeans();

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Reset 'active' flag.</span>
<span style="color: #000000;">                cancelRefresh(ex);

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Propagate exception to caller.</span>
                <span style="color: #0000ff;">throw</span><span style="color: #000000;"> ex;
            }

            </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> Reset common introspection caches in Spring's core, since we
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> might not ever need metadata for singleton beans anymore...</span>
<span style="color: #000000;">                resetCommonCaches();
            }
        }
    }</span></code></pre>

<h3>图示</h3>
<p><img src="./images/Spring源码分析13.png" alt="" /></p>
<p>&nbsp;</p>
<h2>创建BeanFactory流程分析</h2>
<h3>&nbsp;获取新的BeanFactory子流程</h3>
<h3>子流程入口(<span style="color: #ff0000;"><strong>从主流程refresh方法中的第二步开始</strong></span>)</h3>
<p><img src="./images/Spring源码分析14.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;调用AbstractApplicationContext中的obtainFreshBeanFactory方法</h3>
<p><img src="./images/Spring源码分析15.png" alt="" /></p>
<p>&nbsp;</p>
<h3>调用AbstractRefreshableApplicationContext的refreshBeanFactory方法&nbsp;</h3>
<p><img src="./images/Spring源码分析16.png" alt="" /></p>
<p>&nbsp;</p>
<h2>&nbsp;加载解析BeanDefinition子流程(loadDefinitions方法)</h2>
<h3>源码分析</h3>
<p>子流程入口(<span style="color: #ff0000;"><strong>AbstractRefreshableApplicationContext类的方法</strong></span>)</p>
<p><img src="./images/Spring源码分析17.png" alt="" /></p>
<p>&nbsp;</p>
<h3 class="15">&nbsp;此处依次调用多个类的loadBeanDefinitions方法（AbstractXmlApplicationContext&agrave;&nbsp;AbstractBeanDefinitionReader&agrave;&nbsp;XmlBeanDefinitionReader），一直调用到XmlBeanDefinitionReader&nbsp;<span style="font-family: 'YaHei Consolas Hybrid';">类的</span>doLoadBeanDefinitions方法</h3>
<p>&nbsp;<img src="./images/Spring源码分析18.png" alt="" /></p>
<h3 class="15"><span style="font-family: 'YaHei Consolas Hybrid';">对于</span>doLoadDocument方法不是我们关注的重点，我们进入到该类的registerBeanDefinitions方法看看</h3>
<p><img src="./images/Spring源码分析19.png" alt="" /></p>
<h3 class="15"><span style="font-family: 'YaHei Consolas Hybrid';">此处有两个地方是我们关注的：一个</span>createRederContext方法，一个是DefaultBeanDefinitionDocumentReader类的registerBeanDefinitions方法，先进入createRederContext方法看看</h3>
<p><img src="./images/Spring源码分析20.png" alt="" /></p>
<h3 class="15"><span style="font-family: 'YaHei Consolas Hybrid';">至此，</span>14个NamespaceHandlerResolver初始化成功。然后我们再进入DefaultBeanDefinitionDocumentReader类的registerBeanDefinitions方法</h3>
<p><img src="./images/Spring源码分析21.png" alt="" /></p>
<h3 class="15">继续进入到该类的doRegisterBeanDefinitions方法看看，这是真正干活的方法</h3>
<p><img src="./images/Spring源码分析22.png" alt="" /></p>
<h3 class="15"><span style="font-family: 'YaHei Consolas Hybrid';">继续进入</span>parseBeanDefinitions方法</h3>
<p><img src="./images/Spring源码分析23.png" alt="" /></p>
<p><span style="font-family: 宋体;">我们看到有两种解析方案，先看看</span>parseDefaultElement<span style="font-family: 宋体;">方法</span></p>
<p><img src="./images/Spring源码分析24.png" alt="" /></p>
<h3 class="15">不过我们重点看看BeanDefinitionParserDelegate类的parseCustomElement方法（<span style="color: #ff0000;"><strong>AOP标签、tx标签的解析都是在该步骤中完成的</strong></span>）</h3>
<p><img src="./images/Spring源码分析25.png" alt="" /></p>
<h3 class="15">getNamespaceURI方法的作用一目了然，我们就不去追踪了，接下来我们进入DefaultNamespaceHandlerResolver类的resolve方法看看：</h3>
<p><img src="./images/Spring源码分析26.png" alt="" /></p>
<p>&nbsp;</p>
<h3 class="15">在上面代码中，我们看到了一行代码：namespaceHandler.init();这个方法是很重要的。它实现了自定义标签到处理类的注册工作，<span style="font-family: 'YaHei Consolas Hybrid';">不过</span>NamespaceHandler是一个接口，<span style="font-family: 'YaHei Consolas Hybrid';">具体的</span>init方法需要不同的实现类进行实现，我们通过<span style="color: #ff0000;"><strong>AopNamespaceHandler</strong></span><span style="font-family: 'YaHei Consolas Hybrid';">了解一下</span>init的作用，其中<strong><span style="color: #ff0000;">aop:config标签是由ConfigBeanDefinitionParser</span>类进行处理</strong>：</h3>
<p>&nbsp;<img src="./images/Spring源码分析27.png" alt="" /></p>
<h3><span style="font-family: 宋体;">至此</span>，<span style="font-family: 宋体;">我们了解到了</span>xml<span style="font-family: 宋体;">中的</span><span style="font-family: 'YaHei Consolas Hybrid';">aop</span><span style="font-family: 宋体;">标签都是由哪些类进行处理的了</span>。<span style="font-family: 宋体;">不过</span>init<span style="font-family: 宋体;">方法只是注册了</span><span style="font-family: 宋体;">标签和处理类</span><span style="font-family: 宋体;">的对应关系</span>，<span style="font-family: 宋体;">那么什么时候调用处理类进行解析的呢</span>？<span style="font-family: 宋体;">我们再回到</span>BeanDefinitionParserDelegate<span style="font-family: 宋体;">类的</span><span style="font-family: 'YaHei Consolas Hybrid';">parseCustomElement</span><span style="font-family: 宋体;">方法看看</span></h3>
<p><img src="./images/Spring源码分析28.png" alt="" /></p>
<h3 class="15">我们看到，<span style="font-family: 'YaHei Consolas Hybrid';">最后一行执行了</span>parse方法，<span style="font-family: 'YaHei Consolas Hybrid';">那么</span>parse方法，在哪呢？我们需要到NamespaceHandlerSupport类中去看看，<span style="font-family: 'YaHei Consolas Hybrid';">它是实现</span>NamespaceHandler接口的，<span style="font-family: 'YaHei Consolas Hybrid';">并且</span>AopNamespaceHandler是继承了NamespaceHandlerSupport类，<span style="font-family: 'YaHei Consolas Hybrid';">那么该方法也会继承到</span>AopNamespaceHandler类中。</h3>
<p><img src="./images/Spring源码分析29.png" alt="" /></p>
<p><span style="font-family: 宋体;">　　至此</span><span style="font-family: 宋体;">，整个</span>XML<span style="font-family: 宋体;">文档的解析工作，包括</span><span style="font-family: 'YaHei Consolas Hybrid';">bean</span><span style="font-family: 宋体;">标签以及</span><span style="font-family: 宋体;">自定义标签如何解析为</span>BeanDefinition<span style="font-family: 宋体;">信息的过程</span>，<span style="font-family: 宋体;">我们已经了解了</span>。</p>
<p class="15"><span style="font-family: 'YaHei Consolas Hybrid';">　　后续具体想了解哪个自定义标签的处理逻辑，可以自行去查找</span>xxxNamespaceHandler类进行分析。</p>
<h3>图示</h3>
<p class="15"><strong><img src="./images/Spring源码分析30.png" alt="" /></strong></p>
<p>&nbsp;</p>
<h2>创建Bean流程分析&nbsp;</h2>
<h3>子流程入口</h3>
<p><img src="./images/Spring源码分析31.png" alt="" /></p>
<h3>我们进入finishBeanFactoryInitialization<span style="font-family: 宋体;">方法看看</span></h3>
<p><img src="./images/Spring源码分析32.png" alt="" /></p>
<h3 class="15">继续进入DefaultListableBeanFactory类的preInstantiateSingletons方法，我们找到下面部分的代码，<span style="font-family: 'YaHei Consolas Hybrid';">看到工厂</span>Bean或者普通Bean，<span style="font-family: 'YaHei Consolas Hybrid';">最终都是通过</span>getBean的方法获取实例的。</h3>
<p><img src="./images/Spring源码分析33.png" alt="" /></p>
<h3><span style="font-family: 宋体;">继续跟踪下去，我们进入到了</span>AbstractBeanFactory<span style="font-family: 宋体;">类的</span><span style="font-family: 'YaHei Consolas Hybrid';">doGetBean</span><span style="font-family: 宋体;">方法，这个方法中的代码很多，我们直接找到核心部分</span></h3>
<p><img src="./images/Spring源码分析34.png" alt="" /></p>
<p>&nbsp;</p>
<h3>接着进入到AbstractAutowireCapableBeanFactory<span style="font-family: 宋体;">类的方法</span>，<span style="font-family: 宋体;">找到以下代码部分</span></h3>
<p><img src="./images/Spring源码分析35.png" alt="" /></p>
<h3><span style="font-family: 宋体;">我们终于找到核心的地方了，进入</span>doCreateBean<span style="font-family: 宋体;">方法看看，该方法我们关注两块重点区域</span></h3>
<p><img src="./images/Spring源码分析36.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/Spring源码分析37.png" alt="" /></p>
<h3 class="15"><span style="font-family: 'YaHei Consolas Hybrid';">对于如何创建</span>Bean的实例，和填充属性，暂时先不去追踪了，我们先去看看initializeBean方法是如何调用BeanPostProcessor的，因为这个牵扯到我们对于AOP动态代理的理解。</h3>
<p><img src="./images/Spring源码分析38.png" alt="" /></p>
<h1 style="text-align: center;">&nbsp;Spring Ioc基于XML的使用</h1>
<h2>创建工程</h2>
<h2>环境准备</h2>
<ul>
<li>maven</li>
<li>jdk</li>
<li>spring</li>
<li>Eclipse</li>
</ul>
<h2>工程搭建</h2>
<p>POM文件</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">project </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">="http://maven.apache.org/POM/4.0.0"</span><span style="color: #ff0000;">
    xmlns:xsi</span><span style="color: #0000ff;">="http://www.w3.org/2001/XMLSchema-instance"</span><span style="color: #ff0000;">
    xsi:schemaLocation</span><span style="color: #0000ff;">="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">modelVersion</span><span style="color: #0000ff;">&gt;</span>4.0.0<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">modelVersion</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>com.kkb<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>0.0.1-SNAPSHOT<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependencies</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> spring 核心组件中的4个依赖 </span><span style="color: #008000;">--&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-core<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.0.7.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-context<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.0.7.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-beans<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.0.7.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-expression<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.0.7.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>

         <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 单元测试Junit </span><span style="color: #008000;">--&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>junit<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>junit<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>4.12<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependencies</span><span style="color: #0000ff;">&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">build</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">plugins</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 配置Maven的JDK编译级别 </span><span style="color: #008000;">--&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">plugin</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.apache.maven.plugins<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>maven-compiler-plugin<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>3.2<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">configuration</span><span style="color: #0000ff;">&gt;</span>
                    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">source</span><span style="color: #0000ff;">&gt;</span>1.8<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">source</span><span style="color: #0000ff;">&gt;</span>
                    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">target</span><span style="color: #0000ff;">&gt;</span>1.8<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">target</span><span style="color: #0000ff;">&gt;</span>
                    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">encoding</span><span style="color: #0000ff;">&gt;</span>UTF-8<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">encoding</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">configuration</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">plugin</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">plugins</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">build</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">project</span><span style="color: #0000ff;">&gt;</span></code></pre>

<p>Spring配置文件(只编写配置文件头)</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="UTF-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans"</span><span style="color: #ff0000;">
    xmlns:xsi</span><span style="color: #0000ff;">="http://www.w3.org/2001/XMLSchema-instance"</span><span style="color: #ff0000;">
    xsi:schemaLocation</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span style="color: #0000ff;">&gt;</span>

<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></code></pre>

<p>具体实现</p>
<p>　　在Spring的XML配置文件中配置一个<span style="color: #ff0000;">bean标签<span style="color: #000000;">，该标签最终会被加载为一个<span style="color: #ff0000;">BeanDefition</span>对象(描述对象信息)</span></span></p>
<p>思路：</p>
<p>　　编写UserService接口的实现类</p>
<p>　　将UserService实现类交给Spring IoC容器管理</p>
<p>　　从Spring IoC容器中获取UserService实现类</p>
<p>编写接口：UserService</p>
<p>&nbsp;<img src="./images/Spring源码分析39.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;编写实现类：UserServiceImpl</p>
<p><img src="./images/Spring源码分析40.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;编写XML文件：applicationContext.xml</p>
<p><img src="./images/Spring源码分析41.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;编写单元测试代码：TestSpring</p>
<p><img src="./images/Spring源码分析42.png" alt="" /></p>
<p>&nbsp;</p>
<h2>bean标签详解</h2>
<h3>bean标签作用：</h3>
<p>　　用于配置对象让Spring来创建</p>
<p>　　默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</p>
<h3>bean标签属性：</h3>
<p>　　id：给对象在<span style="color: #ff0000;">容器中</span>提供一个唯一标识。用于获取对象。</p>
<p>　　class：指定类的全限定类名。用于反射创建对象。默认情况下<span style="color: #ff0000;">调用无参构造函数</span>。</p>
<p>　　scope：指定对象的作用范围。</p>
<p>　　　　<span style="color: #ff0000;">singleton</span>：<span style="color: #ff0000;">默认值</span>，单例的(<span style="color: #ff0000;">在整个容器中只有一个对象</span>)。</p>
<p>　　　　<span style="color: #ff0000;">prototype</span>：多例的。</p>
<p>　　　　request：web项目中，Spring创建一个Bean的对象，将对象存入到request域中。</p>
<p>　　　　session：web项目中，Spring创建一个Bean的对象，将对象存入到session域中。</p>
<p>　　　　global session：web项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession相当于session。</p>
<p>　　　　init-method：指定类中的初始化方法名称。</p>
<p>　　　　<span style="color: #ff0000;">destroy-method</span>：指定类中销毁方法名称。比如DataSource的配置中一般需要指定destroy-method="close"。</p>
<h3>bean的作用范围：</h3>
<p>　　单例对象：scope="<span style="color: #ff0000;">singleton</span>"</p>
<p>　　　　一个应用只有一个对象的实例。它的作用范围就是整个应用</p>
<p>　　　　生命周期：</p>
<p>　　　　　　对象出生：当应用加载，创建容器时，对象就被创建了。</p>
<p>　　　　　　对象活着：只要容器在，对象一直活着。</p>
<p>　　　　　　对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</p>
<p>　　多例对象：scope="<span style="color: #ff0000;">prototype</span>"</p>
<p>　　　　每次访问对象时，都会重新创建对象实例。</p>
<p>　　　　生命周期：</p>
<p>　　　　　　对象出生：当使用对象时，创建新的对象实例。</p>
<p>　　　　　　对象活着：只要对象在使用中，就一直活着。</p>
<p>　　　　　　对象死亡：当对象长时间不用时，被java的垃圾回收期回收了。</p>
<h3>实例化bean的三种方式</h3>
<p>　　<span style="color: #ff0000;">第一种：使用默认无参构造函数(重点)</span></p>
<p>　　　　在默认情况下：它会根据默认无参构造函数来创建类对象。</p>
<p>　　　　如果bean中没有默认无参构造函数，将会创建失败</p>
<src class="cnblogs_code">
<pre><code>&lt;bean id=<span style="color: #800000;">"</span><span style="color: #800000;">userService</span><span style="color: #800000;">"</span> <span style="color: #0000ff;">class</span>=<span style="color: #800000;">"</span><span style="color: #800000;">com.chenyanbin.spring.service.UserServiceImpl</span><span style="color: #800000;">"</span>&gt;</code></pre>

<p>　　第二种：静态工厂(了解)</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
* 模拟一个静态工厂，创建业务层实现类
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> StaticFactory {
　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> UserService createUserService(){
　　　　</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> UserServiceImpl();
　　}
}</span></code></pre>

<src class="cnblogs_code">
<pre><code>&lt;!--<span style="color: #000000;">此种方法时：  
使用StaticFactory类中的静态方法createUserService创建对象，并存入Spring容器
id属性：指定bean的id，用于从容器中获取
class属性：指定静态工厂的全限定类名
factory</span>-<span style="color: #000000;">method属性：指定生产对象的静态方法
</span>--&gt;
&lt;bean id="userService" <span style="color: #0000ff;">class</span>="com.chenyanbin.spring.factory.StaticFactory" factory-method="createUserService"&gt;&lt;/bean&gt;</code></pre>

<p>　　第三种：实例工厂(了解)</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
*    模拟一个实例工厂，创建业务层实现类
*    此工厂创建对象，必须现有工厂实例对象，再调用方法
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> InstanceFactory {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> UserService createUserService(){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> UserServiceImpl();
    } 
}</span></code></pre>

<src class="cnblogs_code">
<pre><code>&lt;!--<span style="color: #000000;">
此种方式是：
    先把工厂的创建交给spring来管理。
    然后在使用工厂的bean来调用里面的方法
        factory</span>-<span style="color: #000000;">ben属性：用于指定实例工厂bean的id。
        factory</span>-<span style="color: #000000;">method属性：用于指定实例工厂中创建对象的方法。
</span>--&gt;
&lt;bean id="instanceFactory" <span style="color: #0000ff;">class</span>="com.chenyanbin.factory.InstanceFactory"&gt;&lt;/bean&gt;
&lt;bean id="userService" factory-bean="instanceFactory" factory-method="createUserService"&gt;&lt;/bean&gt;</code></pre>

<h1 style="text-align: center;">Spring DI(依赖注入)介绍</h1>
<h2>概述</h2>
<h3>　　什么是依赖？</h3>
<p>　　　　依赖指的就是Bean实例中的属性</p>
<p>　　　　属性分为：简单类型(8种基本类型和String类型)的属性、POJO类型的属性、集合数组类型的属性。</p>
<h3>　　什么是依赖注入</h3>
<p>　　　　依赖注入：Dependency Injection。它是Spring框架核心IoC的具体实现。</p>
<h3>　　为什么要进行依赖注入？</h3>
<p>　　　　我们的程序在编写时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。</p>
<p>　　　　IoC解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。</p>
<p>　　　　简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
<h2>依赖注入的方式(基于XML)</h2>
<h3>&nbsp;构造函数注入</h3>
<p>　　顾名思义，就是使用类中的构造函数，给成员变量赋值。</p>
<p>　　注意，赋值的操作不是我们自己做的，而是通过配置的方式，让Spring框架来为我们注入。</p>
<p>　　具体代码如下：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> UserServiceImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> UserService {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> id;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
    
    </span><span style="color: #0000ff;">public</span> UserServiceImpl(<span style="color: #0000ff;">int</span><span style="color: #000000;"> id, String name) {
        </span><span style="color: #0000ff;">this</span>.id =<span style="color: #000000;"> id;
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> saveUser() {
        System.out.println(</span>"保存用户:id为"+id+"，name为"+name+"   Service实现"<span style="color: #000000;">);
    }
}</span></code></pre>

<src class="cnblogs_code">
<pre><code>&lt;!--<span style="color: #000000;">使用构造函数的方式，给Service中的属性传值要求：类中需要提供一个对应参数列表的构造函数。
        涉及的标签：constructor</span>-<span style="color: #000000;">arg
            index：指定参数在构造函数参数列表的索引位置
            name：指定参数在构造函数中的名称
            value：它能赋的值是基本数据类型和String类型
            ref：他能赋的值是其他bean类型，也就是说，必须得是在配置文件中配置过的bean
</span>--&gt; 
&lt;bean id="userService" <span style="color: #0000ff;">class</span>="com.chenyanbin.spring.service.UserServiceImpl"&gt;
    &lt;constructor-arg name="id" value="1"&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name="name" value="zhangsan"&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>

<h3>set方法注入(重点)</h3>
<p>　　set方法注入又分为<span style="color: #008000;">手动装配方式注入</span>和<span style="color: #008000;">自动装配方式注入</span>。</p>
<p>　　　　手动装配方式(XML方式)：bean标签的子标签<span style="color: #ff0000;">property</span>，<span style="color: #ff0000;">需要在类中指定set方法</span>。</p>
<p>　　　　自动装配方式(注解方式)：@Autowired注解、@Resource注解。</p>
<p>　　　　　　@Autowired：一部分功能是<span style="color: #ff0000;">查询实例</span>，从spring容器中根据<span style="color: #ff0000;">类型</span>(java类)获取对应的实例。另一部分功能就是<span style="color: #ff0000;">赋值</span>，将找到的实例，装配和另一个实例的属性值。(<span style="color: #ff0000;">注意事项：一个java类型在同一个spring容器中，只能有一个实例</span>)</p>
<p>　　　　　　@Resource：一部分功能是<span style="color: #ff0000;">查询实例</span>，从spring容器中根据<span style="color: #ff0000;">Bean的名称</span>(Bean标签的名称)获取对应的实例。另一部分功能就是<span style="color: #ff0000;">赋值</span>，将找到的实例，装配给另一个实例的属性值。</p>
<p>　　使用p名称空间注入数据(本质上还是调用set方法)</p>
<p>1.步骤一：需要先引入p名称空间</p>
<p>　　在schema的名称空间中加入该行：</p>
<src class="cnblogs_code">
<pre><code>xmlns:p="http://www.springframework.org/schema/p"</code></pre>

<p>2.步骤二：使用p名称空间的语法</p>
<src class="cnblogs_code">
<pre><code>p:属性名=""<span style="color: #000000;">
p:属性名</span>-ref=""</code></pre>

<p>3.步骤三：测试</p>
<src class="cnblogs_code">
<pre><code>&lt;bean id="person" <span style="color: #0000ff;">class</span>="com.chenyanbin.spring.demo.Person" p:pname="隔壁老王" p:car2-ref="car2" /&gt;
&lt;bean id="car2" <span style="color: #0000ff;">class</span>="com.chenyanbin.spring.demo.Car2" /&gt;</code></pre>

<h2>依赖注入不同类型的属性(<span style="color: #ff0000;">基于XML</span>)</h2>
<h3>简单类型(value)</h3>
<src class="cnblogs_code">
<pre><code>&lt;bean id="userService" <span style="color: #0000ff;">class</span>="com.chenyanbin.spring.service.UserServiceImpl"&gt;
    &lt;property name="id" value="1"&gt;&lt;/property&gt;
    &lt;property name="name" value="zhangsan"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<h3>引用类型(ref)</h3>
<p><span style="color: #ff0000;">ref就是reference的缩写，是引用的意思</span></p>
<src class="cnblogs_code">
<pre><code>&lt;bean id="userService" <span style="color: #0000ff;">class</span>="com.chenyanbin.spring.service.UserServiceImpl"&gt;
    &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="userDao" <span style="color: #0000ff;">class</span>="com.chenyanbin.spring.dao.UserDaoImpl"&gt;&lt;/bean&gt;</code></pre>

<h3>集合类型(数组)</h3>
<p>1.如果是数组或者List集合，注入配置文件的方式是一样的</p>
<src class="cnblogs_code">
<pre><code>&lt;bean id="collectionBean" <span style="color: #0000ff;">class</span>="com.chenyanbin.demo5.CollectionBean"&gt;
    &lt;property name="arrs"&gt;
        &lt;list&gt;
&lt;!--如果集合内是简单类型，使用value子标签，如果是POJO类型，则使用bean标签--&gt;
            &lt;value&gt;张三&lt;/value&gt;
            &lt;value&gt;李四&lt;/value&gt;
            &lt;value&gt;王五&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>

<p>2.如果是Set集合，注入的配置文件方式如下：</p>
<src class="cnblogs_code">
<pre><code>&lt;property name="sets"&gt;
    &lt;set&gt;
&lt;!--如果集合内是简单类型，使用value子标签，如果是POJO类型，则使用bean标签--&gt;
        &lt;value&gt;哈哈&lt;/value&gt;
        &lt;value&gt;喜喜&lt;/value&gt;
    &lt;/set&gt;
&lt;/property&gt;</code></pre>

<p>3.如果是Map集合，注入的配置方式如下</p>
<src class="cnblogs_code">
<pre><code>&lt;property name="map"&gt;
    &lt;map&gt;
        &lt;entry key="老王" value="18" /&gt;
        &lt;entry key="王五" value="19" /&gt;
    &lt;/map&gt;
&lt;/property&gt;</code></pre>

<p>4.如果是<span style="color: #ff0000;">Properties</span>集合的方式，注入的配置如下：</p>
<src class="cnblogs_code">
<pre><code>&lt;property name="pro"&gt;
    &lt;props&gt;
        &lt;prop key="userName"&gt;root&lt;/prop&gt;
        &lt;prop key="userPassword"&gt;123&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;&nbsp;</code></pre>

<p style="text-align: left;"><a href="https://files-cdn.cnblogs.com/files/chenyanbin/Spring-demo.rar" target="_blank">练习demo</a></p>
<h1 style="text-align: center;">Spring IoC和DI基于注解使用</h1>
<p>　　学习基于注解的IoC配置，大家脑海里首先得有一个认识，即<span style="color: #ff0000;">注解配置和xml配置要实现的功能都是一样的</span>，都是要降低程序间的耦合。只是配置的形式不一样。</p>
<p>　　关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以<span style="color: #ff0000;">这两种配置方式都需要掌握</span>。</p>
<p>　　在讲解注解配置时，采用上一章节的案例，把Spring的xml配置内容改为使用注解逐步实现。</p>
<h2>IoC注解使用</h2>
<h3>第一步：Spring配置文件中，配置context:component-scan标签</h3>
<p><img src="./images/Spring源码分析43.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;第二步：类上面加上注解@Component，或者它的衍生注解<span style="color: #ff0000;">@Controller、@Service、@Repository</span></h3>
<p><img src="./images/Spring源码分析44.png" alt="" /></p>
<p>&nbsp;</p>
<h2>&nbsp;常用注解</h2>
<h3>IoC注解(创建对象)</h3>
<p><span style="color: #ff0000;">相当于：&lt;bean id="" class=""&gt;&lt;/bean&gt;</span></p>
<p>@Component注解</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">作用：
    把资源让Spring来管理。相当于在XML中配置一个bean。
属性：
    value：指定bean的id。
<span style="color: #ff0000;">如果不指定value属性，默认bean的id时当前类的类型。首字母小写</span>。</span></code></pre>

<p>@Controller、@Service、@Repository注解</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">他们三个注解都是针对@Component的衍生注解
他们的作用及属性都是一摸一样的。他们只不过是提供了更加明确的语义化。
    @<span style="color: #ff0000;">Controller</span>：一般用于表现层的注解。
    @<span style="color: #ff0000;">Service</span>：一般用于业务层的注解。
    @<span style="color: #ff0000;">Repository</span>：一般用于持久层的注解。
细节：如果注解中有且只有一个属性要赋值时，且名称是<span style="color: #ff0000;">value</span>，value在赋值是可以不写。</span></code></pre>

<h3>&nbsp;DI注解(依赖注入)</h3>
<p>相当于：&lt;property name="" ref=""&gt;</p>
<p><span style="color: #ff0000;">@Autowired</span></p>
<p>　　默认按<span style="color: #ff0000;">类型装配</span>(byType)</p>
<p>　　这个注解是spring自身的</p>
<p>　　默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：<span style="color: #ff0000;">@Autowired(required=false)</span></p>
<p>　　如何我们想使用名称装配可以结合<span style="color: #ff0000;">@Qualifier注解</span>进行使用</p>
<p>@Qualifier</p>
<p>　　在自动按照类型注入的基础之上，再按照Bean的id注入。</p>
<p>　　它在给<span style="color: #ff0000;">字段注入</span>时不能独立使用，<span style="color: #ff0000;">必须和@Autowire一起使用</span>；但是给方法参数注入时，可以单独使用。</p>
<p><span style="color: #ff0000;">@Resource</span></p>
<p>　　默认按照<span style="color: #ff0000;">名称</span>(byName)进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取<span style="color: #ff0000;">字段名</span>进行按照名称查询，当找不到域名称匹配的bean时才按照<span style="color: #ff0000;">类型</span>进行装配。</p>
<p>　　但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p><span style="color: #ff0000;">推荐使用@Resource注解，因为这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起来就比较优雅。</span></p>
<p><span style="color: #ff0000;">相当于：&lt;property name="" value=""&gt;</span></p>
<p>@Value</p>
<p>　　给基本类型和String类型注入值</p>
<p>　　可以使用占位符获取属性文件中的值。</p>
<p>@Value("${<span style="color: #ff0000;">name</span>}") //name是properties文件中的key</p>
<p>用例</p>
<p>UserServiceImpl.java</p>
<src class="cnblogs_code">
<pre><code>    @Value("${id}"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> id;
    
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> saveUser() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
        System.out.println("IoC演示之UerService:"+<span style="color: #000000;">id);
    }</span></code></pre>

<p>applicationContext.xml</p>
<src class="cnblogs_code">
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"<span style="color: #000000;">
    xmlns:xsi</span>="http://www.w3.org/2001/XMLSchema-instance"<span style="color: #000000;">
    xmlns:context</span>="http://www.springframework.org/schema/context"<span style="color: #000000;">
    xsi:schemaLocation</span>="http://www.springframework.org/schema/beans
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/beans/spring-beans.xsd</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/context</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/context/spring-context.xsd"&gt;</span>
    &lt;!-- 组件扫描器，主要是spring使用，用来扫描带有指定注解的类，将这些加载成BeanDefinition --&gt;
    &lt;context:component-<span style="color: #000000;">scan
        base</span>-<span style="color: #0000ff;">package</span>="com.cyb.spring.service" /&gt;
        &lt;!-- 占位符,location：路径 --&gt;
        &lt;context:property-placeholder location="classpath:data.properties"/&gt;
&lt;/beans&gt;</code></pre>

<p>data.properties</p>
<src class="cnblogs_code">
<pre><code>id=123</code></pre>

<h3>改变作用范围</h3>
<p>@Scope</p>
<p>相当于：&lt;bean id="" class="" <span style="color: #ff0000;">scope=""</span>&gt;</p>
<p>作用：</p>
<p>　　指定bean的作用范围</p>
<p>属性：</p>
<p>　　value：指定范围的值</p>
<p>　　　　取值：<span style="color: #ff0000;">singleton prototype</span> request session globalsession</p>
<h3>和生命周期相关</h3>
<p>相当于：&lt;bean id="" class="" <span style="color: #ff0000;">init-method="" destroy-method=""</span>&gt;</p>
<p>@PostConstruct和@PreDestroy</p>
<h3>关于注解和XML的选择问题</h3>
<p>　　注解的优势：</p>
<p>　　　　配置简单，维护方便(我们找到类，就相当于找到了对应的配置)。</p>
<p>　　XML的优势：</p>
<p>　　　　修改时，不用改源码。不涉及重新编译和部署。</p>
<p>　　Spring管理Bean方式的比较</p>
<p><img src="./images/Spring源码分析45.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 style="text-align: center;">&nbsp;Spring的纯注解配置</h1>
<p>　　到这里，基于注解的IoC配置已经完成，但是大家都发现了一个问题：我们依然离不开spring的xml配置文件，<span style="color: #ff0000;">那么能不能不写这个applicationContext.xml，所有配置都用注解来实现呢？</span></p>
<p>　　需要注意以下，我们选择那种配置的原则是简化开发和配置方便，而非追求某种技术。</p>
<h2>待改造的问题</h2>
<p>　　想一想能不能将以下这些bean的配置都从xml中去掉，并且最终将xml也去掉。</p>
<p>　　如果可以，那么我们就可以脱离xml配置了。</p>
<ul>
<li>注解扫描配置(能不能去掉)</li>
</ul>
<src class="cnblogs_code">
<pre><code>&lt;!--开启注解并扫描指定包中带有注解的类--&gt;
&lt;context:component-scan base-<span style="color: #0000ff;">package</span>="com.chenyanbin.spring.service" /&gt;</code></pre>

<ul>
<li>非自定义的Bean配置(比如：SqlSessionFactory和BasicDataSource配置)</li>
</ul>
<src class="cnblogs_code">
<pre><code>&lt;bean id="sqlSessionFactory" <span style="color: #0000ff;">class</span>="org.mybatis.spring.SqlSessionFactoryBean"&gt;
    &lt;property name="dataSource" value="dataSource"&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>

<ul>
<li>去掉XML后，如何创建ApplicationContext</li>
</ul>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">之前创建ApplicationContext都是通过读取XML文件进行创建的。
ApplicationContext context</span>=<span style="color: #0000ff;">new</span> ClassPathXmlApplicationContext("beans.xml");</code></pre>

<h2>新的注解</h2>
<h3>　　@Configuration</h3>
<p>　　介绍：</p>
<p>　　　　从Spring3.0，@Configuration用于定义<span style="color: #ff0000;">配置类</span>，可<span style="color: #ff0000;">替换XML配置文件</span></p>
<p>　　　　<span style="color: #ff0000;">相当于&lt;beans&gt;根标签</span></p>
<p>　　　　<span style="color: #ff0000;">配置类</span>内部包含有一个或多个被<span style="color: #ff0000;">@Bean</span>注解的方法，这些方法将会被<span style="color: #ff0000;">AnnotationConfigApplicationContext</span>或<span style="color: #ff0000;">AnnotationConfigWebApplicationContext</span>类进行扫描，并用于构建bean定义，初始化Spring容器。</p>
<p>　　属性：</p>
<p>　　　　value：用于指定配置类的字节码</p>
<p>　　示例代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">    @Configuration
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SpringConfiguration {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">spring容器初始化时，会调用配置类的无参构造函数</span>
        <span style="color: #0000ff;">public</span><span style="color: #000000;"> SpringConfiguration(){
            System.out.println(&ldquo;容器启动初始化。。。&rdquo;);
        }
    }</span></code></pre>

<h3>　　@Bean</h3>
<p>　　介绍：</p>
<p>　　　　@Bean标注在方法上(返回某个实例的方法)，等价于spring配置文件中的&lt;bean&gt;</p>
<p>　　作用：</p>
<p>　　　　注册bean对象</p>
<p>　　　　主要用来配置非自定义的bean，比如DruidDataSource、SqlSessionFactory</p>
<p>　　属性：</p>
<p>　　　　name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id)。</p>
<p>　　　　如果不指定，<span style="color: #ff0000;">默认与标注的方法名相同</span></p>
<p>　　　　@Bean注解<span style="color: #ff0000;">默认作用域为单例singleton作用域</span>，可通过@Scope("prototype")设置为原型作用域；</p>
<p>　　示例代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SpringConfiguration {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">spring容器初始化时，会调用配置类的无参构造函数</span>
        <span style="color: #0000ff;">public</span><span style="color: #000000;"> SpringConfiguration(){
            System.out.println(&ldquo;容器启动初始化。。。&rdquo;);
    }
    @Bean
    @Scope(&ldquo;prototype&rdquo;)
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> UserService userService(){
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> UserServiceImpl(1<span style="color: #000000;">,&ldquo;张三&rdquo;);
    }
}</span></code></pre>

<h3>　　@ComponentScan</h3>
<p>　　介绍：</p>
<p>　　　　相当于context:component-scan标签</p>
<p>　　　　组件扫描器，扫描@Component、@Controller、@Service、@Repository注解的类。</p>
<p>　　　　该注解是编写在类上面的，<span style="color: #ff0000;">一般配合@Configuration</span>注解一起使用。</p>
<p>　　属性：</p>
<p>　　　　basePackages：用于指定要扫描的包</p>
<p>　　　　value：和basePackages作用一样</p>
<p>　　示例代码：</p>
<p>　　Bean类(Service类)：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Service
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> UserServiceImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> UserService {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> saveUser() {
        System.out.println(</span>"保存用户   Service实现"<span style="color: #000000;">);
    }
}</span></code></pre>

<p>　　配置类：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Configuration
@ComponentScan(basePackages</span>="com.kkb.spring.service"<span style="color: #000000;">)
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SpringConfiguration {

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> SpringConfiguration() {
        System.out.println(</span>"容器初始化..."<span style="color: #000000;">);
    }
    
</span><span style="color: #008000;">//</span><span style="color: #008000;">    @Bean
</span><span style="color: #008000;">//</span><span style="color: #008000;">    @Scope("prototype")
</span><span style="color: #008000;">//</span><span style="color: #008000;">    public UserService userService() {
</span><span style="color: #008000;">//</span><span style="color: #008000;">        return new UserServiceImpl(1,"张三");
</span><span style="color: #008000;">//</span><span style="color: #008000;">    }</span>
}</code></pre>

<h3>　　@PropertySource</h3>
<p>　　介绍</p>
<p>　　　　加载properties配置文件</p>
<p>　　　　编写在类上面</p>
<p>　　　　相当于 context:property-placeholder 标签</p>
<p>　　属性</p>
<p>　　　　value[]：用于指定properties文件路径，如果在类路径下，需要写上classpath</p>
<p>　　示例代码</p>
<p>配置类：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Configuration
@PropertySource(&ldquo;classpath:jdbc.properties&rdquo;)
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> JdbcConfig {
    @Value(</span>"${jdbc.driver}"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String driver;
    @Value(</span>"${jdbc.url}"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String url;
    @Value(</span>"${jdbc.username}"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String username;
    @Value(</span>"${jdbc.password}"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String password;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
*创建一个数据源，并存入 spring 容器中
*</span><span style="color: #808080;">@return</span>
<span style="color: #008000;">*/</span><span style="color: #000000;">
@Bean(name</span>="dataSource"<span style="color: #000000;">)
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> DataSource createDataSource() {
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        ComboPooledDataSource ds </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ComboPooledDataSource();                     
        ds.setDriverClass(driver);
        ds.setJdbcUrl(url); 
        ds.setUser(username); 
        ds.setPassword(password); 
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ds;
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> RuntimeException(e);
    }
    }
}  </span></code></pre>

<p>properties文件：</p>
<src class="cnblogs_code">
<pre><code>jdbc.driver=<span style="color: #000000;">com.mysql.jdbc.Driver 
jdbc.url</span>=jdbc:mysql:<span style="color: #008000;">//</span><span style="color: #008000;">/spring</span>
jdbc.username=<span style="color: #000000;">root 
jdbc.password</span>=root</code></pre>

<p>　　问题：</p>
<p>　　　　当系统中有多个配置类时怎么办？想一想之前使用XML配置的时候时如何解决该问题的。</p>
<h3>　　@Import</h3>
<p>　　介绍</p>
<p>　　　　用来组合多个配置类</p>
<p>　　　　相当于spring配置文件中的<span style="color: #ff0000;">Import标签</span></p>
<p>　　　　在引入其他配置类时，可以不用再写@Configuration注解。当前，写上也没问题。</p>
<p>　　属性</p>
<p>　　　　value：用来指定其他配置类的字节码文件</p>
<p>示例代码</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">@Configuration
@ComponentScan(basePackages </span>= "com.kkb.spring"<span style="color: #000000;">)
@Import({ JdbcConfig.</span><span style="color: #0000ff;">class</span><span style="color: #000000;">})
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SpringConfiguration {
}


@Configuration
@PropertySource(</span>"classpath:jdbc.properties"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> JdbcConfig{
}</span></code></pre>

<h3>　　通过注解获取容器</h3>
<ul>
<li>Java应用(AnnotationConfigApplicationContext)</li>
</ul>
<src class="cnblogs_code">
<pre><code>ApplicationContext context = <span style="color: #0000ff;">new</span>    AnnotationConfigApplicationContext(SpringConfiguration.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
UserService service </span>= context.getBean(UserService.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
service.saveUser();</span></code></pre>

<ul>
<li>Web应用(AnnotationConfigWebApplicationContext)</li>
</ul>
<src class="cnblogs_code">
<pre><code>&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;<span style="color: #000000;">
            org.springframework.web.context.
            support.AnnotationConfigWebApplicationContext
        </span>&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;<span style="color: #000000;">
            com.kkb.spring.test.SpringConfiguration
        </span>&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;listener&gt;
        &lt;listener-<span style="color: #0000ff;">class</span>&gt;<span style="color: #000000;">
            org.springframework.web.context.ContextLoaderListener
        </span>&lt;/listener-<span style="color: #0000ff;">class</span>&gt;
    &lt;/listener&gt;
&lt;/web-app&gt;</code></pre>

<h1 style="text-align: center;">Spring分模块开发</h1>
<p>　　分模块开发场景描述</p>
<p>　　　　表现层：spring配置文件，只想管理表现层的Bean</p>
<p>　　　　业务层：spring配置文件，只想管理业务层的Bean，并且进行事务控制</p>
<p>　　　　持久层：spring配置文件，只想管理持久层的Bean，并且还有需要管理数据源的Bean</p>
<p>　　为了方便管理项目中不同层的Bean对象，一般都是将一个spring配置文件，分解为多个spring配置文件。</p>
<p>　　分解之后的spring配置文件如何一起被加载呢？</p>
<p>　　　　一种就是同时指定多个配置文件的地址一起加载</p>
<p>　　　　<span style="color: #ff0000;">另一种就是：定义一个import.xml文件，通过import标签将其他多个spring配置文件导入到该文件中，tomcat启动时只需要加载import.xml就可以。</span></p>
<h1 style="text-align: center;">IoC和DI总结</h1>
<p>&nbsp;</p>
<p>@Autowired注解，它是如何生效的？<span style="color: #ff0000;">AutowiredBeanPostProcessor类</span></p>
<h2>IoC和DI使用</h2>
<p>　　XML配置方式</p>
<p>　　注解+XML配置方式</p>
<p>　　　　@Component</p>
<p>　　　　@Controller</p>
<p>　　　　@Service</p>
<p>　　　　@Repository</p>
<p>　　　　@Autowired</p>
<p>　　　　@Resource</p>
<p>　　纯注解方式</p>
<p>　　　　@Configuration</p>
<p>　　　　@Bean</p>
<p>　　　　@ComponentScan</p>
<p>　　　　@PropertySource</p>
<p>　　　　@Import</p>
<h1 style="text-align: center;">Spring整合Junit</h1>
<h2>单元测试问题</h2>
<p>　　在测试类中，每个测试方法都有以下两行代码：</p>
<src class="cnblogs_code">
<pre><code>ApplicationContext context = <span style="color: #0000ff;">new</span> ClassPathXmlApplicationContext("applicationContext.xml"<span style="color: #000000;">);
UserService service1 </span>= context.getBean(UserService.<span style="color: #0000ff;">class</span>);</code></pre>

<p>　　我们使用单元测试要测试的是业务问题，以上两端代码明显不是<span style="color: #ff0000;">业务代码</span>。</p>
<p>　　但是这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p>
<h2>解决思路分析</h2>
<p>　　针对上述问题，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建spring容器，我们就无需手动创建了，问题也就解决了。</p>
<p>　　但紧接的问题就是Juit它本身不认识spring，更无法帮助创建spring容器了，不过好在Junit给我们暴露一个注解(<span style="color: #ff0000;">@RunWith</span>)，可以让我们替换掉它的运行器。</p>
<p>　　这时，我们需要依靠<span style="color: #ff0000;">spring框架</span>，因为<span style="color: #ff0000;">它提供了一个运行器</span>，可以读取配置文件(或注解)来创建容器。我们只需告诉它配置文件在哪就行了。</p>
<h2>具体实现</h2>
<h3>添加依赖</h3>
<p>　　添加spring-test包即可</p>
<src class="cnblogs_code">
<pre><code>        &lt;!-- spring单元测试组件包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>

<h3>通过@RunWith注解，指定spring的运行器</h3>
<p>　　Spring的运行器是SpringJunit4ClassRunner</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.cyb.spring.test;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.annotation.Resource;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.junit.Test;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.junit.runner.RunWith;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.test.context.ContextConfiguration;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.cyb.spring.configuration.SpringConfiguration;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.cyb.spring.service.UserService;

</span><span style="color: #008000;">//</span><span style="color: #008000;">@RunWith：Junit自身的注解，它的作用是可以指定一个新的运行器
</span><span style="color: #008000;">//</span><span style="color: #008000;">SpringJUnit4ClassRunner.class:spring提供的单元测试运行器</span>
@RunWith(SpringJUnit4ClassRunner.<span style="color: #0000ff;">class</span><span style="color: #000000;">)
</span><span style="color: #008000;">//</span><span style="color: #008000;">@ContextConfiguration:SpringJUnit4ClassRunner运行器需要的上下文配置信息，方便创建spring容器
</span><span style="color: #008000;">//</span><span style="color: #008000;">classes:纯注解方式时，读取配置类
</span><span style="color: #008000;">//</span><span style="color: #008000;">locations:xml方式时，读取配置文件</span>
@ContextConfiguration(classes = SpringConfiguration.<span style="color: #0000ff;">class</span><span style="color: #000000;">)
</span><span style="color: #008000;">//</span><span style="color: #008000;">@ContextConfiguration(locations = "classpath:applicationContext.xml")</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TestSpring2 {
    @Resource
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> UserService service;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">执行@Test方法之前调用该方法</span>
<span style="color: #000000;">
    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test1() {
        service.saveUser();
    }
}</span></code></pre>

<h3><img src="./images/Spring源码分析46.png" alt="" /></h3>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/Spring源码分析47.png" alt="" /></p>
<p>&nbsp;</p>
<p><img src="./images/Spring源码分析48.png" alt="" /></p>
<p>&nbsp;</p>
<p><img src="./images/Spring源码分析49.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/Spring源码分析50.png" alt="" /></p>
<p>&nbsp;</p>
<p><a href="https://files-cdn.cnblogs.com/files/chenyanbin/spring-demo4.rar" target="_blank">&nbsp;Demo示例源码</a></p>
<h3>通过@ContextConfiguration注解，指定spring运行器需要的配置文件路径</h3>
<h3>通过@Autowired注解给测试类中的变量注入数据</h3>
<p><img src="./images/Spring源码分析51.png" alt="" /></p>
<p>&nbsp;</p>
<h1 style="text-align: center;">&nbsp;Spring AOP原理分析</h1>
<h2>AOP介绍</h2>
<p>　　什么是AOP?</p>
<p><img src="./images/Spring源码分析52.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;　　在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向<span style="color: #ff0000;">切面</span>编程</p>
<p>　　AOP是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构</p>
<p>　　AOP最早由AOP联盟的组织提出的，制定了一套规范，spring将AOP思想引入到框架中，必须遵守AOP联盟的规范</p>
<p>　　通过预编译方式和<span style="color: #ff0000;">运行期动态代理</span>实现程序功能的统一维护的一种技术</p>
<p>　　AOP是OOP的延续，是软件开发中的一个热点，也是spring框架中的一个重要内容，是函数式编程的一种衍生范式</p>
<p>　　利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p>
<h2>AOP的作用及优势是什么？&nbsp;</h2>
<p>作用：</p>
<p>　　AOP采用<span style="color: #ff0000;">横向抽取</span>机制，取代了<span style="color: #ff0000;">传统纵向继承体系</span>重复性代码(性能监视、事务管理、安全检查、缓存)</p>
<p>　　在程序运行期间，不修改源码对已有方法进行增强。</p>
<p>　　将业务逻辑和系统处理的代码(<span style="color: #ff0000;">关闭连接、事务管理、操作日志记录</span>)解耦。</p>
<p>优势：</p>
<ul>
<li>减少重复代码</li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
<p><img src="./images/Spring源码分析53.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src="./images/Spring源码分析54.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>&nbsp;AOP相关术语介绍</h2>
<ol>
<li>Joinpoint(连接点)：所谓连接点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持类型的连接点</li>
<li><span style="color: #ff0000;">Pointcut(切入点)</span>：所谓切入点是指我们要对那些Joinpoint进行拦截的定义</li>
<li><span style="color: #ff0000;">Advice(通知/增强)</span>：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知(切面要完成的功能)</li>
<li>Introduction(引介)：引介时一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field</li>
<li><span style="color: #ff0000;">Target(目标类)</span>：代理的目标对象</li>
<li>Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程</li>
<li><span style="color: #ff0000;">Proxy(代理)</span>：一个类被AOP织入增强后，就产生一个结果代理类</li>
<li><span style="color: #ff0000;">Aspect(切面)</span>：是切入点和通知的结合，在以后的开发中编写和配置的</li>
</ol>
<p><img src="./images/Spring源码分析55.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>&nbsp;AOP实现指AspectJ(了解)</h2>
<p>　　AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译(一般在编译期进行)，让java代码具有AspectJ的AOP功能(当然需要特殊的编译器)</p>
<p>　　可以这样说<span style="color: #ff0000;">AspectJ是目前实现AOP框架中最成熟</span>，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用非常容易。</p>
<p>　　了解AspectJ应用到java代码的过程(这个过程称为织入)，对于织入这个概念，可以简单理解为Aspect(切面)应用到目标函数(类)的过程。</p>
<p>　　对于这个过程，一般分为<span style="color: #ff0000;">动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中</span>，这样往往时通过<span style="color: #ff0000;">动态代理技术完成的</span>。如java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术。</p>
<p>　　AspectJ采用的就是静态织入的方式。AspectJ主要采用的是编译期织入，这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。</p>
<p><img src="./images/Spring源码分析56.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Spring AOP实现原理分析&nbsp;</h2>
<p>　　Spring AOP是通过<span style="color: #ff0000;">动态代理技术</span>实现的，而动态代理是基于<span style="color: #ff0000;">反射</span>设计的。</p>
<p>　　动态代理技术的实现方式有两种：基于接口的JDK动态代理和基于继承的CGLib动态代理。</p>
<p><img src="./images/Spring源码分析57.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;JDK动态代理</p>
<p>　　目标对象必须实现接口</p>
<p>使用Proxy类来生成代理对象的一些代码如下</p>
<src class="cnblogs_code">
<pre><code> <span style="color: #008000;">/**</span><span style="color: #008000;">
     * 使用JDK的方式生成代理对象
     * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> Administrator
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyProxyUtils {
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> UserService getProxy(<span style="color: #0000ff;">final</span><span style="color: #000000;"> UserService service) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 使用Proxy类生成代理对象</span>
            UserService proxy =<span style="color: #000000;"> 
                 (UserService) Proxy.newProxyInstance(
                    service.getClass().getClassLoader(),
                    service.getClass().getInterfaces(), 
                    </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> InvocationHandler() {

                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 代理对象方法一执行，invoke方法就会执行一次</span>
                        <span style="color: #0000ff;">public</span> Object invoke(Object proxy, Method method, Object[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
                            </span><span style="color: #0000ff;">if</span>("save"<span style="color: #000000;">.equals(method.getName())){
                                System.out.println(</span>"记录日志..."<span style="color: #000000;">);
                                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 开启事务</span>
<span style="color: #000000;">                            }
                            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 提交事务
                            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 让service类的save或者update方法正常的执行下去</span>
                            <span style="color: #0000ff;">return</span><span style="color: #000000;"> method.invoke(service, args);
                        }
                    });
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回代理对象</span>
            <span style="color: #0000ff;">return</span><span style="color: #000000;"> proxy;
        }
    }</span></code></pre>

<p>CGLib动态代理</p>
<p>　　目标对象不需要实现接口</p>
<p>　　底层是通过继承目标对象产生代理子对象(代理子对象中继承了目标对象的方法，并可以对该方法进行增强)</p>
<src class="cnblogs_code">
<pre><code>    <span style="color: #008000;">/**</span><span style="color: #008000;">
     * 使用CGLib动态代理技术实现
     * 它是基于继承的方式实现的
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> service
     * </span><span style="color: #808080;">@return</span>
     <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> UserService getProxyByClib(UserService service) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建增强器</span>
        Enhancer enhancer=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Enhancer();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">设置需要增强类的类对象</span>
        enhancer.setSuperclass(UserServiceImpl.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">设置回调函数</span>
        enhancer.setCallback(<span style="color: #0000ff;">new</span><span style="color: #000000;"> MethodInterceptor() {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">methodProxy：代理之后的对象的方法引用</span>
<span style="color: #000000;">            @Override
            </span><span style="color: #0000ff;">public</span> Object intercept(Object object, Method method, Object[] arg, MethodProxy methodProxy) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
                Long start</span>=<span style="color: #000000;"> System.currentTimeMillis();
                System.out.println(</span>"记录程序开始时间。。。"+<span style="color: #000000;">start);
                </span><span style="color: #008000;">//</span><span style="color: #008000;">因为代理对象是目标对象的子类
                </span><span style="color: #008000;">//</span><span style="color: #008000;">该行代码，实际调用的是目标对象的方法
                </span><span style="color: #008000;">//</span><span style="color: #008000;">object:代理对象</span>
                Object object2=<span style="color: #000000;">methodProxy.invokeSuper(object, arg);
                Long end</span>=<span style="color: #000000;"> System.currentTimeMillis();
                System.out.println(</span>"记录程序结束时间。。。"+<span style="color: #000000;">end);
                System.out.println(</span>"记录总时长.."+(end-<span style="color: #000000;">start));
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> object2;
            }
        });
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> (UserService)enhancer.create();
    }</span></code></pre>

<h1 style="text-align: center;">Spring AOP使用</h1>
<h2>Spring AOP开发需要明确的事情</h2>
<p>　　a、开发阶段(我们做的)</p>
<p>　　　　<span style="color: #ff0000;">编写</span>核心业务代码(开发主线)：大部分程序员来做，要求熟悉业务需求。</p>
<p>　　　　把公司代码抽取出来，制作成<span style="color: #ff0000;">通知</span>。(开发阶段最后在做)：AOP编程人员来做。</p>
<p>　　　　在配置文件中，声明切入点与通知间的关系，即<span style="color: #ff0000;">切面</span>。：AOP编程人员来做。</p>
<p>　　b、运行阶段(Spring框架完成的)</p>
<p>　　　　Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<h2>编写目标类</h2>
<p>编写接口和实现类(目标对象)</p>
<p>UserService接口</p>
<p>UserServiceImpl实现类</p>
<p>配置目标类，将目标类交给Spring IoC容器管理</p>
<p><img src="./images/Spring源码分析58.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;基于AspectJ的XML实现</h3>
<p>实现步骤</p>
<p>POM.XML</p>
<src class="cnblogs_code">
<pre><code>        &lt;!-- 基于AspectJ的aop依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;aopalliance&lt;/groupId&gt;
            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>

<p>编写<span style="color: #ff0000;">通知</span>(增强类，一个普通的类)</p>
<p><img src="./images/Spring源码分析59.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;配置通知，将通知类交给Spring IoC容器管理</p>
<p><img src="./images/Spring源码分析60.png" alt="" /></p>
<p>&nbsp;</p>
<p>配置AOP切面&nbsp;</p>
<p><img src="./images/Spring源码分析61.png" alt="" /></p>
<src class="cnblogs_code">
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"<span style="color: #000000;">
    xmlns:xsi</span>="http://www.w3.org/2001/XMLSchema-instance"<span style="color: #000000;">
    xmlns:aop</span>="http://www.springframework.org/schema/aop"<span style="color: #000000;">
    xsi:schemaLocation</span>="http://www.springframework.org/schema/beans
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/beans/spring-beans.xsd</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/aop</span>
        http:<span style="color: #008000;">//</span><span style="color: #008000;">www.springframework.org/schema/aop/spring-aop.xsd"&gt;</span>
&lt;/beans&gt;</code></pre>

<p>&nbsp;<a href="https://files-cdn.cnblogs.com/files/chenyanbin/spring-demo6.rar" target="_blank">直接下载</a></p>
<p>切入点表达式</p>
<p>　　execution(<span style="color: #ff0000;">[修饰符] 返回值 包名.类名.方法名(参数)</span>)</p>
<p>　　　　<span style="color: #ff0000;">execution：必须有</span></p>
<p>　　　　修饰符：可省略</p>
<p>　　　　返回值类型：<span style="color: #ff0000;">必须要</span>，但是可以使用*通配符</p>
<p>　　　　包名：</p>
<p>　　　　　　多级包之间使用.分割</p>
<p>　　　　　　包名可以使用*代替，多级包名可以使用多个*代替</p>
<p>　　　　　　如果想省略中间的报名可以使用..</p>
<p>　　　　类名：</p>
<p>　　　　　　可以使用*代替</p>
<p>　　　　　　也可以写成*DaoImpl</p>
<p>　　　　方法名：</p>
<p>　　　　　　也可以使用*代替</p>
<p>　　　　　　也可以写成add*</p>
<p>　　　　参数：</p>
<p>　　　　　　参数使用*代替</p>
<p>　　　　　　如果有多个参数，可以使用..代替</p>
<p><img src="./images/Spring源码分析62.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;通知类型</h3>
<p>　　通知类型(五种)：前置通知、后置通知、最终通知、环绕通知、异常抛出通知。</p>
<p>　　前置通知：</p>
<p>　　　　执行时机：<span style="color: #ff0000;">目标对象方法之前执行通知</span></p>
<p>　　　　配置文件：&lt;<span style="color: #ff0000;">aop:before</span> method="before" pointcut-ref="myPointcut" /&gt;</p>
<p>　　　　应用场景：方法开始时可以进行校验</p>
<p>　　后置通知：</p>
<p>　　　　执行时机：<span style="color: #ff0000;">目标对象方法之后执行通知，有异常则不执行了</span></p>
<p>　　　　配置文件：&lt;<span style="color: #ff0000;">aop:after-returning</span> method="afterReturning" pointcut-ref="myPointcut" /&gt;</p>
<p>　　应用场景：可以修改方法的返回值</p>
<p>　　最终通知：</p>
<p>　　　　执行时机：<span style="color: #ff0000;">目标对象方法之后执行通知，有没有异常都会执行</span></p>
<p>　　　　<span style="color: #ff0000;">配置文件</span>：&lt;<span style="color: #ff0000;">aop:after</span> method="after" pointcut-ref="myPointcut" /&gt;</p>
<p>　　　　应用场景：例如像释放资源</p>
<p>　　<span style="color: #ff0000;">环绕通知</span>：</p>
<p>　　　　执行时机：目标对象方法之前和之后都会执行。</p>
<p>　　　　配置文件：&lt;<span style="color: #ff0000;">aop:around</span> method="around" pointcut-ref="myPointcut" /&gt;</p>
<p>　　　　应用场景：事务、统计代码执行时机</p>
<src class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> log(ProceedingJoinPoint joinPoint)
    {
        System.out.println(</span>"前置通知"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            joinPoint.proceed();
            System.out.println(</span>"后置通知"<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">相当于实现异常通知</span>
            System.out.println("异常抛出通知"<span style="color: #000000;">);
            e.printStackTrace();
        }
        </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            System.out.println(</span>"最终通知"<span style="color: #000000;">);    
        }        
    }</span></code></pre>

<p>　　异常抛出通知：</p>
<p>　　　　执行时机：在抛出异常后通知</p>
<p>　　　　配置文件：&lt;<span style="color: #ff0000;">aop:after-throwing</span> method="afterThrowing" pointcut-ref="myPointcut" /&gt;</p>
<p>　　　　应用场景：包装异常</p>
<h3>&nbsp;基于AspectJ的注解实现</h3>
<p><strong>实现步骤</strong></p>
<p>　　编写<span style="color: #ff0000;">切面类</span>(注意不是<span style="color: #ff0000;">通知类</span>，因为该类中可以指定<span style="color: #ff0000;">切入点</span>)</p>
<p><img src="./images/Spring源码分析63.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>&nbsp;配置切面类</strong></p>
<src class="cnblogs_code">
<pre><code>&lt;context:component-scan back-<span style="color: #0000ff;">package</span>="com.chenyanbin.spring" /&gt;</code></pre>

<p><strong>开启AOP自动代理</strong></p>
<p><img src="./images/Spring源码分析64.png" alt="" /></p>
<p>&nbsp;pom.xml</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">project </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">="http://maven.apache.org/POM/4.0.0"</span><span style="color: #ff0000;">
    xmlns:xsi</span><span style="color: #0000ff;">="http://www.w3.org/2001/XMLSchema-instance"</span><span style="color: #ff0000;">
    xsi:schemaLocation</span><span style="color: #0000ff;">="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">modelVersion</span><span style="color: #0000ff;">&gt;</span>4.0.0<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">modelVersion</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>spring-demo7<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-demo7<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>0.0.1-SNAPSHOT<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependencies</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> Spring IoC组件依赖 </span><span style="color: #008000;">--&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-beans<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.2.0.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-core<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.2.0.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-context<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.2.0.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-expression<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.2.0.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>

        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>javax.annotation<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>javax.annotation-api<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>1.3.1<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 单元测试 </span><span style="color: #008000;">--&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>junit<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>junit<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>4.12<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> spring单元测试组件包 </span><span style="color: #008000;">--&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-test<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.2.0.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 基于AspectJ的aop依赖 </span><span style="color: #008000;">--&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.springframework<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>spring-aspects<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>5.0.7.RELEASE<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>aopalliance<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>aopalliance<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>1.0<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependency</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">dependencies</span><span style="color: #0000ff;">&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">build</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">plugins</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 配置Maven的JDK编译级别 </span><span style="color: #008000;">--&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">plugin</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>org.apache.maven.plugins<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">groupId</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>maven-compiler-plugin<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">artifactId</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>3.2<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">version</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">configuration</span><span style="color: #0000ff;">&gt;</span>
                    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">source</span><span style="color: #0000ff;">&gt;</span>1.8<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">source</span><span style="color: #0000ff;">&gt;</span>
                    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">target</span><span style="color: #0000ff;">&gt;</span>1.8<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">target</span><span style="color: #0000ff;">&gt;</span>
                    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">encoding</span><span style="color: #0000ff;">&gt;</span>UTF-8<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">encoding</span><span style="color: #0000ff;">&gt;</span>
                <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">configuration</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">plugin</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">plugins</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">build</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">project</span><span style="color: #0000ff;">&gt;</span></code></pre>

<p>applicationContext.xml</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="UTF-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans"</span><span style="color: #ff0000;">
    xmlns:xsi</span><span style="color: #0000ff;">="http://www.w3.org/2001/XMLSchema-instance"</span><span style="color: #ff0000;">
    xmlns:context</span><span style="color: #0000ff;">="http://www.springframework.org/schema/context"</span><span style="color: #ff0000;">
    xmlns:aop</span><span style="color: #0000ff;">="http://www.springframework.org/schema/aop"</span><span style="color: #ff0000;">
    xsi:schemaLocation</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 组件扫描器，扫描切面类 </span><span style="color: #008000;">--&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">context:component-scan
        </span><span style="color: #ff0000;">base-package</span><span style="color: #0000ff;">="com.cyb.spring"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">context:component-scan</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 开启AOP自动代理 </span><span style="color: #008000;">--&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">aop:aspectj-autoproxy </span><span style="color: #0000ff;">/&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></code></pre>

<p><a href="https://files-cdn.cnblogs.com/files/chenyanbin/spring-demo7.rar" target="_blank">直接下载</a></p>
<h3>&nbsp;环绕通知注解配置</h3>
<p><span style="color: #ff0000;">　　@Around</span></p>
<p>　　作用：</p>
<p>　　　　把当前方法看成是环绕通知属性。</p>
<p>　　value：</p>
<p>　　　　用于指定切入点表达式，还可以指定切入点表达式的引用。</p>
<p><img src="./images/Spring源码分析65.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;定义通用切入点</h3>
<p>　　使用@PointCut注解在切面类中定义一个通用的切入点，其他通知可以引用该切入点</p>
<p><img src="./images/Spring源码分析66.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;不使用XML的配置方式</h3>
<p>　　@Configuration</p>
<p>　　@ComponentScan(basePackages="com.chenyanbin")</p>
<p>　　<span style="color: #ff0000;">@EnableAspectJAutoProxy</span></p>
<p>　　public class SpringConfiguration{　　</p>
<p>　　}</p>
<h1 style="text-align: center;">Spring 应用之Spring JDBC实现</h1>
<h2>JdbcTemplate类的入门使用</h2>
<p>　　POM.XML</p>
<ul>
<li style="list-style-type: none;">
<ul>
<li>MySQL数据库的驱动包</li>
<li>Spring-jdbc.jar</li>
<li>Spring-tx.jar</li>
</ul>
</li>
</ul>
<p>　　编写测试代码</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">    @Test
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run1(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建连接池，先使用Spring框架内置的连接池</span>
        DriverManagerDataSource dataSource = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DriverManagerDataSource();
        dataSource.setDriverClassName(</span>"com.mysql.jdbc.Driver"<span style="color: #000000;">);
        dataSource.setUrl(</span>"jdbc:mysql:///spring "<span style="color: #000000;">);
        dataSource.setUsername(</span>"root"<span style="color: #000000;">);
        dataSource.setPassword(</span>"root"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建模板类</span>
        JdbcTemplate jdbcTemplate = <span style="color: #0000ff;">new</span><span style="color: #000000;"> JdbcTemplate(dataSource);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 完成数据的添加</span>
        jdbcTemplate.update("insert into t_account values (null,?,?)", "测试",10000<span style="color: #000000;">);
    }</span></code></pre>

<h2>Spring管理JdbcTemplate</h2>
<p>　　步骤一：Spring管理内置的连接池</p>
<src class="cnblogs_code">
<pre><code>&lt;bean id="dataSource" <span style="color: #0000ff;">class</span>="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
    &lt;property name="url" value="jdbc:mysql:///spring_day03"/&gt;
    &lt;property name="username" value="root"/&gt;
    &lt;property name="password" value="root"/&gt;
&lt;/bean&gt;</code></pre>

<p>　　步骤二：Spring管理模板类</p>
<src class="cnblogs_code">
<pre><code>&lt;bean  id="jdbcTemplate" <span style="color: #0000ff;">class</span>="org.springframework.jdbc.core.JdbcTemplate"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>

<p>　　步骤三：编写测试程序</p>
<src class="cnblogs_code">
<pre><code>　　　　@RunWith(SpringJUnit4ClassRunner.<span style="color: #0000ff;">class</span><span style="color: #000000;">)
　　　　@ContextConfiguration(</span>"classpath:applicationContext.xml"<span style="color: #000000;">)
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo2{
            @Resource(name</span>="jdbcTemplate"<span style="color: #000000;">)
            </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> JdbcTemplate jdbcTemplate;

            @Test
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
                jdbcTemplate.update(</span>"insert into t_account values (null,?,?)", "测试2",10000<span style="color: #000000;">);
            }

　　　　}</span></code></pre>

<h2>Spring管理第三方DataSource</h2>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">    管理DBCP连接池
    </span>*<span style="color: #000000;"> 先引入DBCP的2个jar包
        </span>* com.springsource.org.apache.commons.dbcp-1.2.2<span style="color: #000000;">.osgi.jar
        </span>* com.springsource.org.apache.commons.pool-1.5.3<span style="color: #000000;">.jar
        如果是maven环境，需要填写GAV坐标
    </span>*<span style="color: #000000;"> 编写配置文件
        </span>&lt;bean id="dataSource" <span style="color: #0000ff;">class</span>="org.apache.commons.dbcp.BasicDataSource"&gt;
            &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
            &lt;property name="url" value="jdbc:mysql:///spring "/&gt;
            &lt;property name="username" value="root"/&gt;
            &lt;property name="password" value="root"/&gt;
        &lt;/bean&gt;<span style="color: #000000;">

    管理C3P0连接池
    </span>*<span style="color: #000000;"> 先引入C3P0的jar包
        </span>* com.springsource.com.mchange.v2.c3p0-0.9.1.2<span style="color: #000000;">.jar

    </span>*<span style="color: #000000;"> 编写配置文件
        </span>&lt;bean id="dataSource" <span style="color: #0000ff;">class</span>="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
            &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;
            &lt;property name="jdbcUrl" value="jdbc:mysql:///spring"/&gt;
            &lt;property name="user" value="root"/&gt;
            &lt;property name="password" value="root"/&gt;
        &lt;/bean&gt;</code></pre>

<h2>使用JdbcTemplate完成增删改查操作</h2>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">    增删改查的操作
    @RunWith(SpringJUnit4ClassRunner.</span><span style="color: #0000ff;">class</span><span style="color: #000000;">)
    @ContextConfiguration(</span>"classpath:applicationContext.xml"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> SpringDemo {

        @Resource(name</span>="jdbcTemplate"<span style="color: #000000;">)
        </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> JdbcTemplate jdbcTemplate;

        @Test
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 插入操作</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> demo1(){
            jdbcTemplate.update(</span>"insert into account values (null,?,?)", "冠希"<span style="color: #000000;">,10000d);
        }

        @Test
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 修改操作</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> demo2(){
            jdbcTemplate.update(</span>"update account set name=?,money =? where id = ?", "思雨",10000d,5<span style="color: #000000;">);
        }

        @Test
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 删除操作</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> demo3(){
            jdbcTemplate.update(</span>"delete from account where id = ?", 5<span style="color: #000000;">);
        }

        @Test
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 查询一条记录</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> demo4(){
            Account account </span>= jdbcTemplate.queryForObject("select * from account where id = ?", <span style="color: #0000ff;">new</span> BeanMapper(), 1<span style="color: #000000;">);
            System.out.println(account);
        }

        @Test
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 查询所有记录</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> demo5(){
            List</span>&lt;Account&gt; list = jdbcTemplate.query("select * from t_account", <span style="color: #0000ff;">new</span><span style="color: #000000;"> BeanMapper());
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Account account : list) {
                System.out.println(account);
            }
        }
    }

    </span><span style="color: #0000ff;">class</span> BeanMapper <span style="color: #0000ff;">implements</span> RowMapper&lt;Account&gt;<span style="color: #000000;">{
        </span><span style="color: #0000ff;">public</span> Account mapRow(ResultSet rs, <span style="color: #0000ff;">int</span> arg1) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> SQLException {
            Account account </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Account();
            account.setId(rs.getInt(</span>"id"<span style="color: #000000;">));
            account.setName(rs.getString(</span>"name"<span style="color: #000000;">));
            account.setMoney(rs.getDouble(</span>"money"<span style="color: #000000;">));
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> account;
        }
    }</span></code></pre>

<h2>Spring dao开发之jdbcDaoSupport</h2>
<src class="cnblogs_code">
<pre><code>1<span style="color: #000000;">. 步骤一：创建WEB工程，引入需要的jar包
    </span>*<span style="color: #000000;"> IOC的6个包
    </span>*<span style="color: #000000;"> AOP的4个包
    </span>*<span style="color: #000000;"> C3P0的1个包
    </span>*<span style="color: #000000;"> MySQL的驱动包
    </span>*<span style="color: #000000;"> JDBC的2个包
    </span>*<span style="color: #000000;"> 整合JUnit测试包

</span>2<span style="color: #000000;">. 步骤二：引入配置文件
    </span>*<span style="color: #000000;"> 引入配置文件
        </span>*<span style="color: #000000;"> 引入log4j.properties

        </span>*<span style="color: #000000;"> 引入applicationContext.xml
            </span>&lt;bean id="dataSource" <span style="color: #0000ff;">class</span>="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
                &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;
                &lt;property name="jdbcUrl" value="jdbc:mysql:///spring "/&gt;
                &lt;property name="user" value="root"/&gt;
                &lt;property name="password" value="root"/&gt;
            &lt;/bean&gt;

3<span style="color: #000000;">. 步骤三：创建对应的包结构和类
    </span>*<span style="color: #000000;"> com.kkb.demo1
        </span>*<span style="color: #000000;"> AccountService
        </span>*<span style="color: #000000;"> AccountServlceImpl
        </span>*<span style="color: #000000;"> AccountDao
        </span>*<span style="color: #000000;"> AccountDaoImpl

</span>4<span style="color: #000000;">. 步骤四:引入Spring的配置文件,将类配置到Spring中
    </span>&lt;bean id="accountService" <span style="color: #0000ff;">class</span>="com.kkb.demo1.AccountServiceImpl"&gt;
    &lt;/bean&gt;

    &lt;bean id="accountDao" <span style="color: #0000ff;">class</span>="com.kkb.demo1.AccountDaoImpl"&gt;
    &lt;/bean&gt;

5<span style="color: #000000;">. 步骤五：在业务层注入DAO ,在DAO中注入JDBC模板（强调：简化开发，以后DAO可以继承JdbcDaoSupport类）
    </span>&lt;bean id="accountService" <span style="color: #0000ff;">class</span>="com.kkb.demo1.AccountServiceImpl"&gt;
        &lt;property name="accountDao" ref="accountDao"/&gt;
    &lt;/bean&gt;

    &lt;bean id="accountDao" <span style="color: #0000ff;">class</span>="com.kkb.demo1.AccountDaoImpl"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

6<span style="color: #000000;">. 步骤六：编写DAO和Service中的方法
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> AccountDaoImpl <span style="color: #0000ff;">extends</span> JdbcDaoSupport <span style="color: #0000ff;">implements</span><span style="color: #000000;"> AccountDao {
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> outMoney(String out, <span style="color: #0000ff;">double</span><span style="color: #000000;"> money) {
            </span><span style="color: #0000ff;">this</span>.getJdbcTemplate().update("update t_account set money = money = ? where name = ?"<span style="color: #000000;">, money,out);
        }
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> inMoney(String in, <span style="color: #0000ff;">double</span><span style="color: #000000;"> money) {
            </span><span style="color: #0000ff;">this</span>.getJdbcTemplate().update("update t_account set money = money + ? where name = ?"<span style="color: #000000;">, money,in);
        }
    }

</span>7<span style="color: #000000;">. 步骤七：编写测试程序.
    @RunWith(SpringJUnit4ClassRunner.</span><span style="color: #0000ff;">class</span><span style="color: #000000;">)
    @ContextConfiguration(</span>"classpath:applicationContext.xml"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo1 {

        @Resource(name</span>="accountService"<span style="color: #000000;">)
        </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> AccountService accountService;

        @Test
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run1(){
            accountService.pay(</span>"冠希", "美美", 1000<span style="color: #000000;">);
        }
    }</span></code></pre>

<h1 style="text-align: center;">Spring 应用之事务支持</h1>
<h2>事务回顾</h2>
<p>　　事务：指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功，要么一起失败！</p>
<h2>事务特性</h2>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h2>如果不考虑隔离性，引发安全性问题</h2>
<ul>
<li>读问题
<ul>
<li>脏读</li>
<li>不可重复读</li>
<li>虚读</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h2>如何解决安全性问题</h2>
<p>　　读问题解决，设置数据库隔离级别</p>
<h2>Spring 框架的事务管理相关的类和API</h2>
<ol>
<li><span style="color: #ff0000;">PlatformTransactionManager</span>接口：平台事务管理器(真正管理事务的类)。该接口有具体的实现类，根据不同持久层框架，需要选择不同的实现类！</li>
<li>TransactionDefinition接口：事务定义信息(事务的隔离级别，传播行为，超时，只读)</li>
<li>TransactionStatus接口：事务的状态</li>
<li>总结：上述对象之间的关系，平台事务管理器真正管理事务对象，根据事务定义的信息 TransactionDefition 进行事务管理，在管理事务中产生一些状态，将状态记录到 TransactionStatus中</li>
<li>PlaformTransactionManager接口中实现类和常用的方法
<ul>
<li>接口的实现类
<ul>
<li>如果使用的 Spring的JDBC模板或者MyBatis框架，需要选择 <span style="color: #ff0000;">DataSourceTransactionManager</span>实现类</li>
<li>如果使用的是Hibernate框架，需要选择<span style="color: #ff0000;">HibernateTransactionManager</span>实现类</li>
</ul>
</li>
<li>该接口的常用方法
<ul>
<li>void commit(TransactionStatus status)</li>
<li>TransactionStatus getTransaction(TransactionDefinition definition)</li>
<li>void rollback(TransactionStatus status)</li>
</ul>
</li>
</ul>
</li>
<li>TransactionDefinition</li>
</ol>
<ul>
<li style="list-style-type: none;">
<ul>
<li>事务隔离级别的常量
<ul>
<li style="list-style-type: none;">
<ul>
<li>static int ISOLATION_DEFAULT　　--采用数据库的默认隔离级别</li>
<li>static int ISOLATION_READ_UNCOMMITTED</li>
<li>static int ISOLATION_READ_COMMITTED</li>
<li>static int ISOLATION_REPEATABLE_READ</li>
<li>static int ISOLATION_SERIALIZABLE</li>
</ul>
</li>
</ul>
</li>
<li>事务的传播行为常量(不用设置，使用默认值)
<ul>
<li>先解释什么是事务的传播行为：解决的是业务层之间的方法调用</li>
<li>PROPAGATION_REQUIRED(默认值) --A中有事务，使用A中的事务，如果没有，B就会开启一个新的事务，将A包含进来.(保证A,B在同一个事务中)，默认值</li>
<li>PROPAGATION_SUPPORTS --A中有事务，使用A中的事务。如果A中没有事务，那么B也不使用事务</li>
<li>PROPAGATION_MANDATORY --A中有事务，使用A中事务，如果A没有事务，抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW --A中有事务，将A中的事务挂起，B创建一个新的事务。(保证A,B没有在一个事务中)</li>
<li>PROPAGATION_NOT_SUPPORTED --A中有事务，将A中的事务挂起</li>
<li>PROPAGATION_NEVER --A中有事务，抛出异常、</li>
<li>PROPAGATION_NESTED --嵌套事务，当A执行之后，就会在这个位置设置一个保存点，如果B没有问题，执行通过，如果B出现异常，运行客户根据需求回滚(选择回滚到保存点或者是最初始状态)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>&nbsp;Spring 框架事务管理的分类</h2>
<ol>
<li>Spring 的编程式事务管理(不推荐使用)
<ul>
<li>通过手动编写代码的方式完成事务的管理(不推荐)</li>
</ul>
</li>
<li>Spring的声明式事务管理(底层采用AOP的技术)
<ul>
<li>通过一段配置的方式完成事务的管理</li>
</ul>
</li>
</ol>
<h2>编程式事务管理(了解)</h2>
<src class="cnblogs_code">
<pre><code>1<span style="color: #000000;">. 说明：Spring为了简化事务管理的代码:提供了模板类 TransactionTemplate，所以手动编程的方式来管理事务，只需要使用该模板类即可！！

</span>2<span style="color: #000000;">. 手动编程方式的具体步骤如下：
    </span>1<span style="color: #000000;">. 步骤一:配置一个事务管理器，Spring使用PlatformTransactionManager接口来管理事务，所以咱们需要使用到他的实现类！！
        </span>&lt;!-- 配置事务管理器 --&gt;
        &lt;bean id="transactionManager" <span style="color: #0000ff;">class</span>="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
            &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;/bean&gt;

    2<span style="color: #000000;">. 步骤二:配置事务管理的模板
        </span>&lt;!-- 配置事务管理的模板 --&gt;
        &lt;bean id="transactionTemplate" <span style="color: #0000ff;">class</span>="org.springframework.transaction.support.TransactionTemplate"&gt;
            &lt;property name="transactionManager" ref="transactionManager"/&gt;
        &lt;/bean&gt;

    3<span style="color: #000000;">. 步骤三:在需要进行事务管理的类中,注入事务管理的模板
        </span>&lt;bean id="accountService" <span style="color: #0000ff;">class</span>="com.itheima.demo1.AccountServiceImpl"&gt;
            &lt;property name="accountDao" ref="accountDao"/&gt;
            &lt;property name="transactionTemplate" ref="transactionTemplate"/&gt;
        &lt;/bean&gt;

    4<span style="color: #000000;">. 步骤四:在业务层使用模板管理事务:
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 注入事务模板对象</span>
        <span style="color: #0000ff;">private</span><span style="color: #000000;"> TransactionTemplate transactionTemplate;
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setTransactionTemplate(TransactionTemplate transactionTemplate) {
            </span><span style="color: #0000ff;">this</span>.transactionTemplate =<span style="color: #000000;"> transactionTemplate;
        }

        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> pay(<span style="color: #0000ff;">final</span> String out, <span style="color: #0000ff;">final</span> String in, <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">double</span><span style="color: #000000;"> money) {
            transactionTemplate.execute(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> TransactionCallbackWithoutResult() {

                </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> doInTransactionWithoutResult(TransactionStatus status) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 扣钱</span>
<span style="color: #000000;">                    accountDao.outMoney(out, money);
                    </span><span style="color: #0000ff;">int</span> a = 10/0<span style="color: #000000;">;
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 加钱</span>
<span style="color: #000000;">                    accountDao.inMoney(in, money);
                }
            });
        }</span></code></pre>

<h2>声明式事务管理</h2>
<p>声明式事务管理又分成两种方式</p>
<ul>
<li style="list-style-type: none;">
<ul>
<li>基于AspectJ的XML方式(重点掌握)</li>
<li>基于AspectJ的注解方式(重点掌握)</li>
</ul>
</li>
</ul>
<h2>事务管理之基于AspectJ的XML方式(重点掌握)</h2>
<p>准备转账环境</p>
<p>　　业务层：</p>
<p>　　　　AccountService</p>
<p>　　　　AccountServiceImpl</p>
<p><img src="./images/Spring源码分析67.png" alt="" /></p>
<p>&nbsp;</p>
<p>持久层</p>
<p>　　AccountDao</p>
<p>　　AccountDaoImpl</p>
<p>spring配置</p>
<p><img src="./images/Spring源码分析68.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;单元测试代码：</p>
<p><img src="./images/Spring源码分析69.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;配置事务管理的AOP</p>
<p>　　平台事务管理器：DataSourceTransactionManager</p>
<p><img src="./images/Spring源码分析70.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;事务通知：&lt;tx:advice id="" transaction-manager="" /&gt;</p>
<p><img src="./images/Spring源码分析71.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;AoP配置</p>
<p>　　&lt;aop:config&gt;</p>
<p>　　　　&lt;aop:advisor advice-ref="" pointcut="" /&gt;</p>
<p>　　&lt;/aop:config&gt;</p>
<p><img src="./images/Spring源码分析72.png" alt="" /></p>
<p>&nbsp;</p>
<h2>&nbsp;事务管理之基于AspectJ的注解方式(重点掌握)</h2>
<p>Service类上或者方法上加注解：</p>
<p>　　类上加@Transactional：表示该类中所有方法都被事务管理</p>
<p>　　方法上加@Transactional：表示只有改方法被事务管理</p>
<p>开始事务注解：</p>
<p><img src="./images/Spring源码分析73.png" alt="" /></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>