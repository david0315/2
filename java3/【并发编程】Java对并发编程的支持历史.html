<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【并发编程】Java对并发编程的支持历史' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【并发编程】Java对并发编程的支持历史</center></div><div class='banquan'>原文出处:本文由博客园博主写代码的木公提供。<br/>
原文连接:https://www.cnblogs.com/54chensongxia/p/11935356.html</div><br>
    <hr />
<p>本博客系列是学习并发编程过程中的记录总结。由于文章比较多，写的时间也比较散，所以我整理了个目录贴（传送门），方便查阅。</p>
<p><a href="https://www.cnblogs.com/54chensongxia/p/11935423.html">并发编程系列博客传送门</a></p>
<h2 id="本文转载原文请点击链接">本文转载，原文请点击<a href="https://blog.csdn.net/hanchao5272/article/details/79521731">链接</a></h2>
<p>本章主要对Java并发(Concurrent)在不同jdk版本中的发展简史进行学习。Java语言从第一版本至今，内置了对并发(Concurrent)的各种支持技术。为了能够让我们在学习Java并发(Concurrent)时，不被各种各样的并发技术弄得晕头转向，本章先对Java个版本中的主要并发技术进行简述。</p>
<h2 id="jdk1.4及之前">1. JDK1.4及之前</h2>
<p>在JDK1.4及之前的版本，主要提供的并发技术有：</p>
<ul>
<li>synchronized关键字</li>
<li>volatile关键字</li>
<li>不变模式</li>
</ul>
<h3 id="volatile关键字">1.1 volatile关键字</h3>
<p>引用百度百科的解释：</p>
<blockquote>
<p>volatile是一个类型修饰符（type specifier），就像大家更熟悉的const一样，它是被设计用来修饰被不同线程访问和修改的变量。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</p>
</blockquote>
<p>注：百度百科的解释并不是专门针对java语音中的volatile，而是C语音，不过其设计思想类型，可以拿来借鉴。</p>
<p>更通俗易懂的说法，在Java语音中，使用volatile关键字的目的：</p>
<ul>
<li>标识这个变量是易变型变量</li>
<li>保证这个变量的可见性</li>
<li>保证一定的有序性</li>
</ul>
<p>volatile关键字还涉及到JMM(Java内存模型,Java Memory Model)以及并发的三个特性(原子性、有序性和可见性)，关于volatile关键字的更多内容，计划在后续章节中进行更加详细的学习。</p>
<h3 id="synchronized关键字">1.2 synchronized关键字</h3>
<p>引用百度百科的一段解释：</p>
<blockquote>
<p>synchronized 关键字，代表这个方法(或代码块)加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法 和 synchronized 代码块 。</p>
</blockquote>
<p>简单来说，synchronized关键字以同步方法和同步代码块的方式，为方法和代码块上的对象加锁。使得同一时刻，在这个对象上的多个线程，只能由持有这个对象锁的单个线程进行代码的调用执行。</p>
<p>synchronized 关键字能够保证代码的原子性、可见性和有序性。</p>
<p>关于synchronized关键字的更多内容，计划在后续章节中进行更加详细的学习。</p>
<h3 id="不变模式">1.3 不变模式</h3>
<p>所谓不变模式，就是指：在并发编程中，为确保数据的一致性和正确性，使用一种不可改变的对象。依靠其不可变的性质，来确保在没有同步的情况下依旧保持一致性和正确性。</p>
<p>Java中不变模式相关技术有：</p>
<ul>
<li>final关键字</li>
<li>String类型</li>
</ul>
<p>关于不变模式，就简单进行这些介绍。如果感兴趣，可以自行学习。</p>
<h2 id="jdk5">2. JDK5</h2>
<p>众所周知，JDK5是Java发展的一个重要版本，提供了很多技术，如泛型 Generic、枚举类型 Enumeration、可变参数varargs、注解 Annotations等等。</p>
<p>在JDK1.5版本中，也提供了对并发编程极为重要的一个包：java.util.concurrent(并发包)</p>
<p>java.util.concurrent(并发包)提供了一些列较为给力的并发技术，主要有：</p>
<ul>
<li>原子(Atomic)类型：如AtomicInteger、AtomicReference等，保证变量的原子性和可见性。</li>
<li>显式锁(Lock)接口：对之前版本锁机制的重构，相较于synchronized 关键字，能够提供更加灵活的特性，如：能够指定锁定公平性、可以实现分组唤醒(Condition)、性能更好的锁。主要包括：Lock接口、ReadWriteLock接口和Condition接口。</li>
<li>计数器(CountDownLatch)：利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行。</li>
<li>回环栅栏(CyclicBarrier)：通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。</li>
<li>信号量(Semaphore)：Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</li>
<li>并发集合：即集合类在并发环境下的版本。主要有：BlockingQueue(Queue)、ConcurrentMap(Map)、ConcurrentHashMap(HashMap)、CopyOnWriteArrayList(ArrayList)。</li>
<li>Callable和Future接口：为了解决继承Thread类和实现Runnable接口存在的弊端(不允许声明检查型异常，不能定义返回值)，而引入的线程的新的定义方式。</li>
<li>执行器(Executor接口)：Executors相关类隐藏了如何处理Runnable的细节，提供了一组方法，能够创建拥有完善配置的线程池和executor。</li>
</ul>
<p>关于原子(Atomic)类型、显式锁(Lock)接口、并发集合、Callable和Future接口、执行器(Executor接口)的更多内容，计划在后续章节中进行更加详细的学习。</p>
<h2 id="jdk7">3. JDK7</h2>
<p>在JDK1.7版本中，主要提供的并发编程技术有：</p>
<ul>
<li>TransferQueue：比BlockingQueue性能更好的并发集合实现。</li>
<li>分支合并(Fork/Join)框架：运用分治法（divide-and-conquer）的思想，实现线程池中任务的自动调度，并且这种调度对用户来说是透明的，典型应用ForkJoinPool。</li>
</ul>
<p>关于分支合并(Fork/Join)框架的更多内容，计划在后续章节中进行更加详细的学习。</p>
<h2 id="jdk8">4.JDK8</h2>
<p>在JDK.18版本中，主要提供的并发编程技术有：</p>
<ul>
<li>加法器(Adder)和累加器(Accumulator)：原子类型的扩充与优化，主要有：LongAdder、LongAccumulator、DoubleAdder和DoubleAccumulator，比AtomicLong和AtomicDouble性能更优。</li>
<li>CompletableFuture：JDK5中Future的增强版。</li>
<li>StampedLock：JDK5中ReadWriteLock的改进版。</li>
</ul>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>