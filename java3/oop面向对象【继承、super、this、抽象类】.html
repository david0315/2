<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修oop面向对象【继承、super、this、抽象类】' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>oop面向对象【继承、super、this、抽象类】</center></div><div class='banquan'>原文出处:本文由博客园博主佩奇er提供。<br/>
原文连接:https://www.cnblogs.com/hxun/p/11725026.html</div><br>
    <p><strong><span style="font-family: 宋体;">今日内容</span></strong></p>
<p><span style="font-family: 宋体;">1.三大特性</span>&mdash;&mdash;<span style="font-family: 宋体;">继承</span></p>
<p><span style="font-family: 宋体;">2.方法重写</span></p>
<p>3.super<span style="font-family: 宋体;">关键字</span></p>
<p>4.this<span style="font-family: 宋体;">关键字</span></p>
<p><span style="font-family: 宋体;">5.抽象类</span></p>
<p><strong><span style="font-family: 宋体;">教学目标</span></strong></p>
<p><span style="font-family: 宋体;">1.能够解释类名作为参数和返回值类型</span></p>
<p><span style="font-family: 宋体;">2.能够写出类的继承格式</span></p>
<p><span style="font-family: 宋体;">3.能够说出继承的特点</span></p>
<p><span style="font-family: 宋体;">4.能够说出子类调用父类的成员特点</span></p>
<p><span style="font-family: 宋体;">5.能够说出方法重写的概念</span></p>
<p><span style="font-family: 宋体;">6.能够说出</span>super<span style="font-family: 宋体;">可以解决的问题</span></p>
<p><span style="font-family: 宋体;">7.描述抽象方法的概念</span></p>
<p><span style="font-family: 宋体;">8.写出抽象类的格式</span></p>
<p><span style="font-family: 宋体;">9.写出抽象方法的格式</span></p>
<p><span style="font-family: 宋体;">10.能够说出父类抽象方法的存在意义</span></p>
<p><span style="font-family: 宋体;">11.能够完成发红包案例的代码逻辑</span></p>
<h2><strong><span style="font-family: 宋体;">第一章</span> <span style="font-family: 宋体;">继承</span></strong></h2>
<p><strong>1.1 </strong><strong>&nbsp;<span style="font-family: 宋体;">概述</span></strong></p>
<p><strong><span style="font-family: 宋体;">由来</span></strong></p>
<p><span style="font-family: 宋体;">多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要</span></p>
<p><span style="font-family: 宋体;">继承那一个类即可。如图所示：</span></p>
<p><img src="./images/oop面向对象【继承、super、this、抽象类】0.png" alt="" /></p>
<p><span style="font-family: 宋体;">其中，多个类可以称为</span><strong><span style="font-family: 宋体;">子类</span></strong><span style="font-family: 宋体;">，单独那一个类称为</span><strong><span style="font-family: 宋体;">父类</span></strong><span style="font-family: 宋体;">、</span><strong><span style="font-family: 宋体;">超类（</span></strong><strong>superclass</strong><strong><span style="font-family: 宋体;">）</span></strong><span style="font-family: 宋体;">或者</span><strong><span style="font-family: 宋体;">基类</span></strong><span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">继承描述的是事物之间的所属关系，这种关系是：</span> <span style="color: #ff0000;">is-a</span> &nbsp;<span style="font-family: 宋体;">的关系。例如，图中兔子属于食草动物，食草动物属于动</span></p>
<p><span style="font-family: 宋体;">物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</span></p>
<p><strong><span style="font-family: 宋体;">定义</span></strong></p>
<p><strong><span style="font-family: 宋体;">继承</span></strong><span style="font-family: 宋体;">：就是子类继承父类的</span><strong><span style="font-family: 宋体;">属性</span></strong><span style="font-family: 宋体;">和</span><strong><span style="font-family: 宋体;">行为</span></strong><span style="font-family: 宋体;">，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接</span></p>
<p><span style="font-family: 宋体;">访问父类中的</span><strong><span style="font-family: 宋体;">非私有</span></strong><span style="font-family: 宋体;">的属性和行为。</span></p>
<p><strong><span style="font-family: 宋体;">好处</span></strong></p>
<p>1. <span style="font-family: 宋体;">提高</span><strong><span style="font-family: 宋体;">代码的复用性</span></strong><span style="font-family: 宋体;">。</span></p>
<p>2. <span style="font-family: 宋体;">类与类之间产生了关系，是</span><strong><span style="font-family: 宋体;">多态的前提</span></strong><span style="font-family: 宋体;">。</span></p>
<p><strong>1.2 </strong><strong>&nbsp;<span style="font-family: 宋体;">继承的格式</span></strong></p>
<p><span style="font-family: 宋体;">通过</span> &nbsp;<span style="color: #ff0000;">extends &nbsp;</span><span style="font-family: 宋体;">关键字，可以声明一个子类继承另外一个父类，定义格式如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> 父类 {
  ...
}
</span><span style="color: #0000ff;">class</span> 子类 <span style="color: #0000ff;">extends</span><span style="color: #000000;"> 父类 {
  ...
}</span></code></pre>

<p>&nbsp;</p>
<p><span style="font-family: 宋体;">继承演示，代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
*  定义员工类Employee，做为父类
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Employee {
    String name; </span><span style="color: #008000;">//</span><span style="color: #008000;"> 定义name属性
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  定义员工的工作方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> work() {
        System.out.println(</span>"尽心尽力地工作"<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">/*</span><span style="color: #008000;">
*  定义讲师类Teacher  继承 员工类Employee
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span> Teacher <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Employee {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  定义一个打印name的方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printName() {
        System.out.println(</span>"name=" +<span style="color: #000000;"> name);
    }
}

</span><span style="color: #008000;">/*</span><span style="color: #008000;">
*  定义测试类
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendDemo01 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建一个讲师类对象</span>
        Teacher t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Teacher();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  为该员工类的name属性进行赋值</span>
        t.name = "小明"<span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用该员工的printName()方法</span>
        t.printName(); <span style="color: #008000;">//</span><span style="color: #008000;">  name =  小明
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用Teacher类继承来的work()方法</span>
<span style="color: #000000;">        t.work();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  尽心尽力地工作</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p><strong>1.3 </strong><strong><span style="font-family: 宋体;">继承后的特点</span></strong><strong>&mdash;&mdash;</strong><strong><span style="font-family: 宋体;">成员变量</span></strong></p>
<p><span style="font-family: 宋体;">当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？</span></p>
<p><strong><span style="font-family: 宋体;">成员变量不重名</span></strong></p>
<p><span style="font-family: 宋体;">如果子类父类中出现</span><strong><span style="font-family: 宋体;">不重名</span></strong><span style="font-family: 宋体;">的成员变量，这时的访问是</span><strong><span style="font-family: 宋体;">没有影响的</span></strong><span style="font-family: 宋体;">。代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  Fu中的成员变量。</span>
    <span style="color: #0000ff;">int</span> num = 5<span style="color: #000000;">;
}<br />
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  Zi中的成员变量</span>
    <span style="color: #0000ff;">int</span> num2 = 6<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  Zi中的成员方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  访问父类中的num，</span>
        System.out.println("Fu  num=" + num); <span style="color: #008000;">//</span><span style="color: #008000;"> 继承而来，所以直接访问。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  访问子类中的num2</span>
        System.out.println("Zi  num2=" +<span style="color: #000000;"> num2);
    }
}

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendDemo02 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建子类对象</span>
        Zi z = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用子类中的show方法</span>
<span style="color: #000000;">        z.show();
    }
}

演示结果：
Fu num </span>= 5<span style="color: #000000;">
Zi num2 </span>= 6</code></pre>

<p><strong><span style="font-family: 宋体;">成员变量重名</span></strong></p>
<p><span style="font-family: 宋体;">如果子类父类中出现</span><strong><span style="font-family: 宋体;">重名</span></strong><span style="font-family: 宋体;">的成员变量，这时的访问是</span><strong><span style="font-family: 宋体;">有影响的</span></strong><span style="font-family: 宋体;">。代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  Fu中的成员变量。</span>
    <span style="color: #0000ff;">int</span> num = 5<span style="color: #000000;">;
}

</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  Zi中的成员变量</span>
    <span style="color: #0000ff;">int</span> num = 6<span style="color: #000000;">;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  访问父类中的num</span>
        System.out.println("Fu  num=" +<span style="color: #000000;"> num);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  访问子类中的num</span>
        System.out.println("Zi  num=" +<span style="color: #000000;"> num);
    }
}

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendsDemo03 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建子类对象</span>
        Zi z = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用子类中的show方法</span>
<span style="color: #000000;">        z.show();
    }
}

演示结果：
Fu num </span>= 6<span style="color: #000000;">
Zi num </span>= 6</code></pre>

<p><span style="font-family: 宋体;">子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用</span> <span style="color: #ff0000;">super &nbsp;</span><span style="font-family: 宋体;">关键字，修饰</span></p>
<p><span style="font-family: 宋体;">父类成员变量，类似于之前学过的</span> &nbsp;this &nbsp;<span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">使用格式：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">super</span>.父类成员变量名</code></pre>

<p><span style="font-family: 宋体;">子类方法需要修改，代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  Zi中的成员变量</span>
    <span style="color: #0000ff;">int</span> num = 6<span style="color: #000000;">;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">访问父类中的num</span>
        System.out.println("Fu  num=" + <span style="color: #0000ff;">super</span><span style="color: #000000;">.num);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">访问子类中的num</span>
        System.out.println("Zi  num=" + <span style="color: #0000ff;">this</span><span style="color: #000000;">.num);
    }
}

演示结果：
Fu num </span>= 5<span style="color: #000000;">
Zi num </span>= 6</code></pre>

<p>&nbsp;</p>
<p><span style="font-family: 宋体;"><span style="color: #ff9900;">小贴士</span>：</span><span style="font-size: 13px; font-family: 幼圆;">Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能</span></p>
<p><span style="font-size: 13px; font-family: 幼圆;">直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员</span></p>
<p><span style="font-size: 13px; font-family: 幼圆;">变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</span></p>
<p><strong>1.4 </strong><strong><span style="font-family: 宋体;">继承后的特点</span></strong><strong>&mdash;&mdash;</strong><strong><span style="font-family: 宋体;">成员方法</span></strong></p>
<p><span style="font-family: 宋体;">当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</span></p>
<p><strong><span style="font-family: 宋体;">成员方法不重名</span></strong></p>
<p><span style="font-family: 宋体;">如果子类父类中出现</span><strong><span style="font-family: 宋体;">不重名</span></strong><span style="font-family: 宋体;">的成员方法，这时的调用是</span><strong><span style="font-family: 宋体;">没有影响的</span></strong><span style="font-family: 宋体;">。对象调用方法时，会先在子类中查找有没有对</span></p>
<p><span style="font-family: 宋体;">应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        System.out.println(</span>"Fu类中的show方法执行"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show2() {
        System.out.println(</span>"Zi类中的show2方法执行"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">public</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendsDemo04 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Zi z </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">子类中没有show方法，但是可以找到父类方法去执行</span>
<span style="color: #000000;">        z.show();
        z.show2();
    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong><span style="font-family: 宋体;">成员方法重名</span></strong><strong>&mdash;&mdash;</strong><strong><span style="font-family: 宋体;">重写</span></strong><strong>(Override)</strong></p>
<p><span style="font-family: 宋体;">如果子类父类中出现</span><strong><span style="font-family: 宋体;">重名</span></strong><span style="font-family: 宋体;">的成员方法，这时的访问是一种特殊情况，叫做</span><strong><span style="font-family: 宋体;">方法重写</span></strong>&nbsp;(Override)<span style="font-family: 宋体;">。</span></p>
<p><strong><span style="font-family: 宋体;">方法重写</span> </strong>&nbsp;<span style="font-family: 宋体;">：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效</span></p>
<p><span style="font-family: 宋体;">果，也称为重写或者复写。</span><strong><span style="font-family: 宋体;">声明不变，重新实现</span></strong><span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        System.out.println(</span>"Fu  show"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">子类重写了父类的show方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        System.out.println(</span>"Zi  show"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendsDemo05 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Zi z </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  子类中有show方法，只执行重写后的show方法</span>
<span style="color: #000000;">        z.show();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  Zi  show</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p>&nbsp;</p>
<p><strong><span style="font-family: 宋体;">重写的应用</span></strong></p>
<p><span style="font-family: 宋体;">子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从</span></p>
<p><span style="font-family: 宋体;">而进行扩展增强。比如新的手机增加来电显示头像的功能，代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Phone {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> sendMessage() {
        System.out.println(</span>"发短信"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> call() {
        System.out.println(</span>"打电话"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showNum() {
        System.out.println(</span>"来电显示号码"<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">智能手机类</span>
<span style="color: #0000ff;">class</span> NewPhone <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Phone {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showNum() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用父类已经存在的功能使用super</span>
        <span style="color: #0000ff;">super</span><span style="color: #000000;">.showNum();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">增加自己特有显示姓名和图片功能</span>
        System.out.println("显示来电姓名"<span style="color: #000000;">);
        System.out.println(</span>"显示头像"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendsDemo06 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建子类对象</span>
        NewPhone np = <span style="color: #0000ff;">new</span><span style="color: #000000;"> NewPhone()；
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用父类继承而来的方法</span>
<span style="color: #000000;">        np.call();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用子类重写的方法</span>
<span style="color: #000000;">        np.showNum();
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">小贴士：这里重写时，用到</span>super.<span style="font-family: 宋体;">父类成员方法，表示调用父类的成员方法。</span></p>
<p><strong><span style="font-family: 宋体;">注意事项</span></strong></p>
<p>1. <span style="font-family: 宋体;">子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</span></p>
<p>2. <span style="font-family: 宋体;">子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</span></p>
<p><strong>1.5 </strong><strong><span style="font-family: 宋体;">继承后的特点</span></strong><strong>&mdash;&mdash;</strong><strong><span style="font-family: 宋体;">构造方法</span></strong></p>
<p><span style="font-family: 宋体;">当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？</span></p>
<p><span style="font-family: 宋体;">首先我们要回忆两个事情，构造方法的定义格式和作用。</span></p>
<p>1. <span style="font-family: 宋体;">构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</span></p>
<p>2. <span style="font-family: 宋体;">构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构</span></p>
<p><span style="font-family: 宋体;">造方法中默认有一个</span> <span style="color: #ff0000;">super()</span> &nbsp;<span style="font-family: 宋体;">，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代</span></p>
<p><span style="font-family: 宋体;">码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    Fu() {
        System.out.println(</span>"Fu()"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu {
    Zi() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  super（），调用父类构造方法</span>
        <span style="color: #0000ff;">super</span><span style="color: #000000;">();
        System.out.println(</span>"Zi（）"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendsDemo07 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String args[]) {
        Zi zi </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
    }
}

输出结果：
Fu（）
Zi（）</span></code></pre>

<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>1.6 super</strong><strong><span style="font-family: 宋体;">和</span></strong><strong>this</strong></span></p>
<p><strong><span style="font-family: 宋体;">父类空间优先于子类对象产生</span></strong></p>
<p><span style="font-family: 宋体;">在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空</span></p>
<p><span style="font-family: 宋体;">间，便可以包含其父类的成员，如果父类成员非</span>private<span style="font-family: 宋体;">修饰，则子类可以随意使用父类成员。代码体现在子类的构</span></p>
<p><span style="font-family: 宋体;">造方法调用时，一定先调用父类的构造方法。理解图解如下：</span></p>
<p><span style="font-family: 宋体;"><img src="./images/oop面向对象【继承、super、this、抽象类】1.png" alt="" /></span></p>
<p><strong>super</strong><strong><span style="font-family: 宋体;">和</span></strong><strong>this</strong><strong><span style="font-family: 宋体;">的含义</span></strong></p>
<p><strong>super </strong><span style="font-family: 宋体;">：代表父类的</span><strong><span style="font-family: 宋体;">存储空间标识</span></strong>(<span style="font-family: 宋体;">可以理解为父亲的引用</span>)<span style="font-family: 宋体;">。</span></p>
<p><strong>this </strong><span style="font-family: 宋体;">：代表</span><strong><span style="font-family: 宋体;">当前对象的引用</span></strong>(<span style="font-family: 宋体;">谁调用就代表谁</span>)<span style="font-family: 宋体;">。</span></p>
<p><strong>super</strong><strong><span style="font-family: 宋体;">和</span></strong><strong>this</strong><strong><span style="font-family: 宋体;">的用法</span></strong></p>
<p>1. <span style="font-family: 宋体;">访问成员</span></p>
<p>&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">this</span><span style="color: #000000;">.成员变量 ‐‐ 本类的
</span><span style="color: #0000ff;">super</span><span style="color: #000000;">.成员变量 ‐‐ 父类的

</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.成员方法名() ‐‐ 本类的
</span><span style="color: #0000ff;">super</span>.成员方法名() ‐‐ 父类的</code></pre>

<p><span style="font-family: 宋体;">用法演示，代码如下：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"animal  :  eat"<span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">class</span> Cat <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eat() {
        System.out.println(</span>"cat  :  eat"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> eatTest() {
        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.eat();
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.eat();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  this</span>
<span style="color: #000000;">        调用本类的方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  super  调用父类的方法</span>
<span style="color: #000000;">    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ExtendsDemo08 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Animal a </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Animal();
        a.eat();
        Cat c </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
        c.eatTest();
    }
}

输出结果为：
animal: eat
cat: eat
animal: eat</span></code></pre>

<p>&nbsp;</p>
<p>2. <span style="font-family: 宋体;">访问构造方法</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">this</span><span style="color: #000000;">(...) ‐‐ 本类的构造方法
</span><span style="color: #0000ff;">super</span>(...) ‐‐ 父类的构造方法</code></pre>

<p><span style="font-family: 宋体;">子类的每个构造方法中均有默认的</span><span style="color: #ff0000;">super()</span><span style="font-family: 宋体;">，调用父类的空参构造。<span style="color: #ff0000;">手动调用</span>父类构造会<span style="color: #ff0000;">覆盖</span>默认的</span>super()<span style="font-family: 宋体;">。</span></p>
<p>super() <span style="font-family: 宋体;">和</span>&nbsp;this() <span style="font-family: 宋体;">都必须是在构造方法的第一行，所以不能同时出现。</span></p>
<p><strong>1.7 </strong><strong>&nbsp;<span style="font-family: 宋体;">继承的特点</span></strong></p>
<p>1. Java<span style="font-family: 宋体;">只支持单继承，不支持多继承。</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">一个类只能有一个父类，不可以有多个父类。</span>
<span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">extends</span> A {} <span style="color: #008000;">//</span><span style="color: #008000;">ok</span>
<span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">extends</span> A， B... <span style="color: #008000;">//</span><span style="color: #008000;">error</span></code></pre>

<p>2. Java<span style="font-family: 宋体;">支持多层继承</span>(<span style="font-family: 宋体;">继承体系</span>)<span style="font-family: 宋体;">。</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> A {}
</span><span style="color: #0000ff;">class</span> B <span style="color: #0000ff;">extends</span><span style="color: #000000;"> A {}
</span><span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">extends</span> B {}</code></pre>

<p><span style="font-family: 宋体;">顶层父类是</span>Object<span style="font-family: 宋体;">类。所有的类默认继承</span>Object<span style="font-family: 宋体;">，作为父类。</span></p>
<p>3. <span style="font-family: 宋体;">子类和父类是一种相对的概念。</span></p>
<p>&nbsp;</p>
<h2><strong><span style="font-family: 宋体;">第二章</span> <span style="font-family: 宋体;">抽象类</span></strong></h2>
<p><strong>2.1 </strong><strong>&nbsp;<span style="font-family: 宋体;">概述</span></strong></p>
<p><strong><span style="font-family: 宋体;">由来</span></strong></p>
<p><span style="font-family: 宋体;">父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有</span></p>
<p><span style="font-family: 宋体;">意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为</span><strong><span style="font-family: 宋体;">抽象方法</span></strong><span style="font-family: 宋体;">。</span>Java<span style="font-family: 宋体;">语法规定，包含抽象方法</span></p>
<p><span style="font-family: 宋体;">的类就是</span><strong><span style="font-family: 宋体;">抽象类</span></strong><span style="font-family: 宋体;">。</span></p>
<p><strong><span style="font-family: 宋体;">定义</span></strong></p>
<p><strong><span style="font-family: 宋体;">抽象方法</span> </strong><span style="font-family: 宋体;">：</span> <span style="font-family: 宋体;">没有方法体的方法。</span></p>
<p><strong><span style="font-family: 宋体;">抽象类</span></strong><span style="font-family: 宋体;">：包含抽象方法的类。</span></p>
<p><strong>2.2 abstract</strong><strong><span style="font-family: 宋体;">使用格式</span></strong></p>
<p><strong><span style="font-family: 宋体;">抽象方法</span></strong></p>
<p><span style="font-family: 宋体;">使用</span> <span style="color: #ff0000;">abstract &nbsp;</span><span style="font-family: 宋体;">关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</span></p>
<p><span style="font-family: 宋体;">定义格式：</span></p>
<src class="cnblogs_code">
<pre><code>修饰符 <span style="color: #0000ff;">abstract</span> 返回值类型 方法名 (参数列表)；</code></pre>

<p><span style="font-family: 宋体;">代码举例：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span> run();</code></pre>

<p>&nbsp;</p>
<p><strong><span style="font-family: 宋体;">抽象类</span></strong></p>
<p><span style="font-family: 宋体;">如果一个类包含抽象方法，那么该类必须是抽象类。</span></p>
<p><span style="font-family: 宋体;">定义格式：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名字 {

}</span></code></pre>

<p><span style="font-family: 宋体;">代码举例：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run()；
}</span></code></pre>

<p><strong><span style="font-family: 宋体;">抽象的使用</span></strong></p>
<p><span style="font-family: 宋体;">继承抽象类的子类</span><span style="color: #ff0000;"><strong><span style="font-family: 宋体;">必须重写父类所有的抽象方法</span></strong></span><span style="font-family: 宋体;">。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父</span></p>
<p><span style="font-family: 宋体;">类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</span></p>
<p><span style="font-family: 宋体;">代码举例：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Cat <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Animal {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        System.out.println(</span>"小猫在墙头走~~~"<span style="color: #000000;">)；
    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CatTest {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建子类对象</span>
        Cat c = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  调用run方法</span>
<span style="color: #000000;">        c.run();
    }
}

输出结果：
小猫在墙头走</span>~~~</code></pre>

<p><span style="font-family: 宋体;">此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做</span><strong><span style="font-family: 宋体;">实现方法</span></strong><span style="font-family: 宋体;">。</span></p>
<p><strong>2.3 </strong><strong>&nbsp;<span style="font-family: 宋体;">注意事项</span></strong></p>
<p><span style="font-family: 宋体;">关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</span></p>
<p><span style="color: #ff0000;">1. <span style="font-family: 宋体;">抽象类</span><strong><span style="font-family: 宋体;">不能创建对象</span></strong><span style="font-family: 宋体;">，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</span></span></p>
<p><span style="font-family: 宋体;">理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</span></p>
<p><span style="color: #ff0000;">2. <span style="font-family: 宋体;">抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</span></span></p>
<p><span style="font-size: 12px;"><span style="font-family: 宋体;">理解：子类的构造方法中，有默认的</span>super()<span style="font-family: 宋体;">，需要访问父类构造方法。</span></span></p>
<p><span style="color: #ff0000;">3. <span style="font-family: 宋体;">抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</span></span></p>
<p><span style="font-family: 宋体; font-size: 12px;">理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设</span><span style="font-family: 宋体; font-size: 12px;">计。</span></p>
<p><span style="color: #ff0000;">4. <span style="font-family: 宋体;">抽象类的子类，必须重写抽象父类中</span><strong><span style="font-family: 宋体;">所有的</span></strong><span style="font-family: 宋体;">抽象方法，否则，编译无法通过而报错。除非该子类也是抽象</span></span><span style="font-family: 宋体; color: #ff0000;">类。</span></p>
<p><span style="font-family: 宋体; font-size: 12px;">理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有</span><span style="font-family: 宋体; font-size: 12px;">意义。</span></p>
<p>&nbsp;</p>
<h2><strong><span style="font-family: 宋体;">第三章</span> <span style="font-family: 宋体;">继承的综合案例</span></strong></h2>
<p><strong>3.1 </strong><strong>&nbsp;<span style="font-family: 宋体;">综合案例：群主发普通红包</span></strong></p>
<p><span style="font-family: 宋体;">群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则：</span></p>
<p>1. <span style="font-family: 宋体;">群主的一笔金额，从群主余额中扣除，平均分成</span>n<span style="font-family: 宋体;">等份，让成员领取。</span></p>
<p>2. <span style="font-family: 宋体;">成员领取红包后，保存到成员余额中。</span></p>
<p><span style="font-family: 宋体;">请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。</span></p>
<p><strong>3.2 </strong><strong>&nbsp;<span style="font-family: 宋体;">案例分析</span></strong></p>
<p><span style="font-family: 宋体;">根据描述分析，得出如下继承体系：</span></p>
<p><span style="font-family: 宋体;"><img src="./images/oop面向对象【继承、super、this、抽象类】2.png" alt="" /></span></p>
<p><strong>3.3 </strong><strong>&nbsp;<span style="font-family: 宋体;">案例实现</span></strong></p>
<p><span style="font-family: 宋体;">定义用户类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> User {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  成员变量</span>
    <span style="color: #0000ff;">private</span> String username;<span style="color: #008000;">//</span><span style="color: #008000;">  用户名</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">double</span> leftMoney;<span style="color: #008000;">//</span><span style="color: #008000;">  余额
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  构造方法</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> User() {}
    </span><span style="color: #0000ff;">public</span> User(String username, <span style="color: #0000ff;">double</span><span style="color: #000000;"> leftMoney) {
            </span><span style="color: #0000ff;">this</span>.username =<span style="color: #000000;"> username;
            </span><span style="color: #0000ff;">this</span>.leftMoney =<span style="color: #000000;"> leftMoney;
        }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  get/set方法</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> String getUsername() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> username;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setUsername(String username) {
        </span><span style="color: #0000ff;">this</span>.username =<span style="color: #000000;"> username;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span><span style="color: #000000;"> getLeftMoney() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> leftMoney;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setLeftMoney(<span style="color: #0000ff;">double</span><span style="color: #000000;"> leftMoney) {
            </span><span style="color: #0000ff;">this</span>.leftMoney =<span style="color: #000000;"> leftMoney;
        }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  展示信息的方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show() {
        System.out.println(</span>"用户名:" + username + " ,  余额为:" + leftMoney + "元"<span style="color: #000000;">);
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义群主类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> QunZhu <span style="color: #0000ff;">extends</span><span style="color: #000000;"> User {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">  添加构造方法</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> QunZhu() {}
    </span><span style="color: #0000ff;">public</span> QunZhu(String username, <span style="color: #0000ff;">double</span><span style="color: #000000;"> leftMoney) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  通过super  调用父类构造方法</span>
            <span style="color: #0000ff;">super</span><span style="color: #000000;">(username, leftMoney);
    }
        
    </span><span style="color: #008000;">/*</span><span style="color: #008000;"> 群主发红包，就是把一个整数的金额，分层若干等份。

      1.获取群主余额,是否够发红包.

          不能则返回null,并提示.

          能则继续.

      2.修改群主余额.

      3.拆分红包.

          3.1.如果能整除，那么就平均分。

          3.2.如果不能整除，那么就把余数分给最后一份。
    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> ArrayList &lt; Double &gt; send(<span style="color: #0000ff;">int</span> money, <span style="color: #0000ff;">int</span><span style="color: #000000;"> count) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  获取群主余额</span>
        <span style="color: #0000ff;">double</span> leftMoney =<span style="color: #000000;"> getLeftMoney();
        </span><span style="color: #0000ff;">if</span>(money &gt;<span style="color: #000000;"> leftMoney) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  修改群主余额的</span>
<span style="color: #000000;">        setLeftMoney(leftMoney‐ money);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  创建一个集合,保存等份金额</span>
        ArrayList &lt; Double &gt; list = <span style="color: #0000ff;">new</span> ArrayList &lt; &gt;<span style="color: #000000;"> ();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  扩大100倍,相当于折算成'分'为单位,避免小数运算损失精度的问题</span>
        money = money * 100<span style="color: #000000;">;
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  每份的金额</span>
        <span style="color: #0000ff;">int</span> m = money /<span style="color: #000000;"> count;
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  不能整除的余数</span>
        <span style="color: #0000ff;">int</span> l = money %<span style="color: #000000;"> count;
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  无论是否整除,n‐1份,都是每份的等额金额</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0; i &lt; count‐ 1; i++<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  缩小100倍,折算成  '元'</span>
            list.add(m / 100.0<span style="color: #000000;">);
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  判断是否整除</span>
        <span style="color: #0000ff;">if</span>(l == 0<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  能整除,  最后一份金额,与之前每份金额一致</span>
            list.add(m / 100.0<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">  不能整除,  最后一份的金额,是之前每份金额+余数金额</span>
            list.add((m + l) / 100.00<span style="color: #000000;">);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">  返回集合</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> list;
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">定义成员类：</span></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Member <span style="color: #0000ff;">extends</span><span style="color: #000000;"> User {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Member() {}
    </span><span style="color: #0000ff;">public</span> Member(String username, <span style="color: #0000ff;">double</span><span style="color: #000000;"> leftMoney) {
            </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(username, leftMoney);
    }
  
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 打开红包,就是从集合中,随机取出一份,保存到自己的余额中</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> openHongbao(ArrayList &lt; Double &gt;<span style="color: #000000;"> list) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建Random对象</span>
        Random r = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 随机生成一个角标</span>
        <span style="color: #0000ff;">int</span> index =<span style="color: #000000;"> r.nextInt(list.size());
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 移除一个金额</span>
        北京市昌平区建材城西路金燕龙办公楼一层 电话： 400 - 618 - 9090<span style="color: #000000;">
        定义测试类：
        课后请同学自己思考并完成扩展需求。
        案例扩展：
        </span>1<span style="color: #000000;">. 如果成员的余额不为0呢， 将如何处理？
        Double money </span>=<span style="color: #000000;"> list.remove(index);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 直接调用父类方法,设置到余额</span>
<span style="color: #000000;">        setLeftMoney(money);
    }
}</span></code></pre>

<p>定义测试类：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建一个群主对象</span>
        QunZhu qz = <span style="color: #0000ff;">new</span> QunZhu("群主", 200<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建一个键盘录入</span>
        Scanner sc = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner();
        System.out.println(</span>"请输入金额:"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> money =<span style="color: #000000;"> sc.nextInt();
        System.out.println(</span>"请输入个数:"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> count =<span style="color: #000000;"> sc.nextInt();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 发送红包</span>
        ArrayList &lt; Double &gt; sendList =<span style="color: #000000;"> s.send(money, count);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 判断,如果余额不足</span>
        <span style="color: #0000ff;">if</span>(sendList == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            System.out.println(</span>" 余额不足..."<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建三个成员</span>
        Member m = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Member();
        Member m2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Member();
        Member m3 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Member();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 打开红包</span>
<span style="color: #000000;">        m.openHongbao(sendList);
        m2.openHongbao(sendList);
        m3.openHongbao(sendList);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 展示信息</span>
<span style="color: #000000;">        qz.show();
        m.show();
        m2.show();
        m3.show();
    }
}</span></code></pre>

<p><span style="font-family: 宋体;">请大家自己思考并完成扩展需求。</span></p>
<p><span style="font-family: 宋体;">案例扩展：</span></p>
<p>1. <span style="font-family: 宋体;">如果成员的余额不为</span>0<span style="font-family: 宋体;">呢，将如何处理？</span></p>
<p>2. <span style="font-family: 宋体;">如果群主想输入带小数的金额呢，将如何处理？</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体; color: #ff0000;">ending...</span></p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>