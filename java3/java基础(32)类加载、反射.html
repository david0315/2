<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(32)类加载、反射' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(32)类加载、反射</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11661479.html</div><br>
    <h1>1.&nbsp;<strong>类加载器</strong></h1>
<h2><!--[if !supportLists]-->1.1&nbsp;<!--[endif]--><strong>类的加载</strong></h2>
<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p>
<p class="16"><span style="font-family: 宋体;">加载</span></p>
<p>　　就是指将class文件读入内存，并为之创建一个Class对象。</p>
<p>　　任何类被使用时系统都会建立一个Class对象</p>
<p class="16">连接</p>
<p><span style="font-family: 宋体;">　　验证</span> <span style="font-family: 宋体;">是否有正确的内部结构，并和其他类协调一致</span></p>
<p><span style="font-family: 宋体;">　　准备</span> <span style="font-family: 宋体;">负责为类的静态成员分配内存，并设置默认初始化值</span></p>
<p><span style="font-family: 宋体;">　　解析</span> <span style="font-family: 宋体;">将类的二进制数据中的符号引用替换为直接引用</span></p>
<p class="16"><span style="font-family: 宋体;">初始化</span></p>
<p>　　就是我们以前讲过的初始化步骤</p>
<h2><!--[if !supportLists]-->1.2&nbsp;<!--[endif]--><strong><span style="font-family: 华文楷体;">类初始化时机</span></strong></h2>
<p class="16">1. 创建类的实例</p>
<p class="16">2. 类的静态变量，或者为静态变量赋值</p>
<p class="16">3. 类的静态方法</p>
<p class="16">4. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p class="16">5. 初始化某个类的子类</p>
<p class="16">6. 直接使用java.exe命令来运行某个主类</p>
<h2><!--[if !supportLists]-->1.3&nbsp;<!--[endif]--><strong>类加载器</strong></h2>
<p class="16">负责将.class文件加载到内在中，并为之生成对应的Class对象。</p>
<p>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</p>
<h2><!--[if !supportLists]-->1.4&nbsp;<!--[endif]--><strong>类加载器的组成</strong></h2>
<p class="16">Bootstrap ClassLoader 根类加载器</p>
<p>　　也被称为引导类加载器，负责Java核心类的加载</p>
<p>　　比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</p>
<p class="16">Extension ClassLoader 扩展类加载器</p>
<p>　　负责JRE的扩展目录中jar包的加载。</p>
<p>　　在JDK中JRE的lib目录下ext目录</p>
<p class="16">System ClassLoader 系统类加载器</p>
<p>　　负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。</p>
<p>&nbsp;</p>
<p>通过这些描述就可以知道我们常用的类，都是由谁来加载完成的。</p>
<p>到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢?</p>
<p>这就是我们反射要研究的内容。</p>
<h1>2.&nbsp;<strong>反射</strong></h1>
<p>JAVA<span style="font-family: 宋体;">反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为</span><span style="font-family: Calibri;">java</span><span style="font-family: 宋体;">语言的反射机制。</span></p>
<p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。</p>
<h2><!--[if !supportLists]-->2.1&nbsp;<!--[endif]--><strong>Class<span style="font-family: 华文楷体;">类</span></strong></h2>
<p><span style="font-family: 宋体;">阅读</span>API的Class类得知，Class&nbsp;<span style="font-family: 宋体;">没有公共构造方法。</span>Class&nbsp;<span style="font-family: 宋体;">对象是在加载类时由</span> Java <span style="font-family: 宋体;">虚拟机以及通过调用类加载器中的 </span>defineClass&nbsp;<span style="font-family: 宋体;">方法自动构造的</span></p>
<p>&nbsp;</p>
<p class="17">获取Class对象的三种方式</p>
<p>方式<span style="font-family: 宋体;">一</span>: <span style="font-family: 宋体;">通过</span><span style="font-family: Calibri;">Object</span><span style="font-family: 宋体;">类中的</span><span style="font-family: Calibri;">getObject()</span><span style="font-family: 宋体;">方法</span></p>
<src class="cnblogs_code">
<pre><code>Person p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
Class c </span>= p.getClass();</code></pre>

<p>方式二:&nbsp;<span style="font-family: 宋体;">通过</span> <span style="font-family: 宋体;">类名</span>.class <span style="font-family: 宋体;">获取到字节码文件对象（任意数据类型都具备一个</span>class静态属性,看上去要比第一种方式简单）。</p>
<src class="cnblogs_code">
<pre><code>Class c2 = Person.<span style="color: #0000ff;">class</span>;</code></pre>

<p><span style="font-family: 宋体;">方式三</span>:&nbsp;<span style="font-family: 宋体;">通过</span>Class<span style="font-family: 宋体;">类中的方法（将类名作为字符串传递给</span>Class类中的静态方法forName即可）。</p>
<src class="cnblogs_code">
<pre><code>Class c3 = Class.forName("Person");</code></pre>

<p class="16">注意：第三种和前两种的区别</p>
<p>前两种你必须明确Person类型.</p>
<p>后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了</p>
<p class="16">代码演示</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * 获取.class字节码文件对象的方式
 *         1：通过Object类中的getObject()方法
 *         2: 通过 类名.class 获取到字节码文件对象
 *         3: 反射中的方法,
 *             public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException
 *             返回与带有给定字符串名的类或接口相关联的 Class 对象 
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ReflectDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 1： 通过Object类中的getObject()方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Person p1 = new Person();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Class c1 = p1.getClass();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> System.out.println("c1 = "+ c1);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 2: 通过 类名.class 获取到字节码文件对象
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Class c2 = Person.class;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> System.out.println("c2 = "+ c2);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 3: 反射中的方法</span>
        Class c3 = Class.forName("cn.itcast_01_Reflect.Person");<span style="color: #008000;">//</span><span style="color: #008000;"> 包名.类名</span>
        System.out.println("c3 = " +<span style="color: #000000;"> c3);
    }
}</span></code></pre>

<p class="16">Person类</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> cn.itcast_01_Reflect;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Person {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">成员变量</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> String name;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String address;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">构造方法</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Person() {
        System.out.println(</span>"空参数构造方法"<span style="color: #000000;">);
    }
    
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Person(String name) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        System.out.println(</span>"带有String的构造方法"<span style="color: #000000;">);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">私有的构造方法</span>
    <span style="color: #0000ff;">private</span> Person(String name, <span style="color: #0000ff;">int</span><span style="color: #000000;"> age){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
        System.out.println(</span>"带有String，int的构造方法"<span style="color: #000000;">);
    }
    
    </span><span style="color: #0000ff;">public</span> Person(String name, <span style="color: #0000ff;">int</span><span style="color: #000000;"> age, String address){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
        </span><span style="color: #0000ff;">this</span>.address =<span style="color: #000000;"> address;
        System.out.println(</span>"带有String, int, String的构造方法"<span style="color: #000000;">);
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">成员方法
    </span><span style="color: #008000;">//</span><span style="color: #008000;">没有返回值没有参数的方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method1(){
        System.out.println(</span>"没有返回值没有参数的方法"<span style="color: #000000;">);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">没有返回值，有参数的方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method2(String name){
        System.out.println(</span>"没有返回值，有参数的方法 name= "+<span style="color: #000000;"> name);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">有返回值，没有参数</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> method3(){
        System.out.println(</span>"有返回值，没有参数的方法"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> 123<span style="color: #000000;">;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">有返回值，有参数的方法</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> String method4(String name){
        System.out.println(</span>"有返回值，有参数的方法"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> "哈哈" +<span style="color: #000000;"> name;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">私有方法</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method5(){
        System.out.println(</span>"私有方法"<span style="color: #000000;">);
    }

    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
        </span><span style="color: #0000ff;">return</span> "Person [name=" + name + ", age=" + age + ", address=" + address+ "]"<span style="color: #000000;">;
    }
}</span></code></pre>

<h2><!--[if !supportLists]-->2.2&nbsp;<!--[endif]--><strong><span style="font-family: 华文楷体;">通过反射获取构造方法并使用</span></strong></h2>
<p>在反射机制中，把类中的成员（构造方法、成员方法、成员变量）都封装成了对应的类进行表示。其中，<span style="font-family: 宋体;">构造方法使用类</span>Constructor<span style="font-family: 宋体;">表示</span><span style="font-family: 宋体;">。可通过</span>Class<span style="font-family: 宋体;">类中提供的方法获取构造方法：</span></p>
<p class="16">返回一个构造方法</p>
<p class="16">　　public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取public修饰, 指定参数类型所对应的构造方法</p>
<p class="16">　　public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取指定参数类型所对应的构造方法(包含私有的)</p>
<p class="16">返回多个构造方法</p>
<p class="16">　　public Constructor&lt;?&gt;[] getConstructors() 获取所有的public 修饰的构造方法</p>
<p class="16">　　public Constructor&lt;?&gt;[] getDeclaredConstructors() 获取所有的构造方法(包含私有的)</p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">获取构造方法的代码演示</span>：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ReflectDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person");<span style="color: #008000;">//</span><span style="color: #008000;">包名.类名
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取所有的构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Constructor[] cons = c.getConstructors();</span>
        Constructor[] cons =<span style="color: #000000;"> c.getDeclaredConstructors();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Constructor con : cons) {
            System.out.println(con);
        }
        
        System.out.println(</span>"------------------------"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取一个构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person() </span>
        Constructor con1 = c.getConstructor(<span style="color: #0000ff;">null</span><span style="color: #000000;">);
        System.out.println(con1);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person(String name)</span>
        Constructor con2 = c.getConstructor(String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        System.out.println(con2);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">private Person(String name, int age)</span>
        Constructor con3 = c.getDeclaredConstructor(String.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        System.out.println(con3);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person(String name, int age, String address)</span>
        Constructor con4 = c.getDeclaredConstructor(String.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span>, String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        System.out.println(con4);
    }
}</span></code></pre>

<h3><!--[if !supportLists]-->2.2.1&nbsp;<!--[endif]--><strong>通过反射方式，获取构造方法，创建对象</strong></h3>
<p>获取构造方法，步骤如下：</p>
<p>1. <span style="font-family: 宋体;">获取到</span><span style="font-family: Calibri;">Class</span><span style="font-family: 宋体;">对象</span></p>
<p>2. <span style="font-family: 宋体;">获取指定的构造方法</span></p>
<p>3. <span style="font-family: 宋体;">通过构造方法类</span>Constructor中的方法，创建对象</p>
<p>　　public T newInstance(Object... initargs)</p>
<p class="16">代码演示</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ConstructorDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,获取到Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person");<span style="color: #008000;">//</span><span style="color: #008000;">包名.类名
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,获取指定的构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person()
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Constructor con = c.getConstructor(null);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person(String name, int age, String address)</span>
        Constructor con = c.getConstructor(String.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span>, String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3,通过构造方法类中Constructor的方法，创建对象
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Object obj = con.newInstance(null);</span>
        Object obj = con.newInstance("小明", 22, "哈尔滨"<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">显示</span>
<span style="color: #000000;">        System.out.println(obj);
    }
}</span></code></pre>

<h3><!--[if !supportLists]-->2.2.2&nbsp;<!--[endif]--><strong>通过反射方式，获取私有构造方法，创建对象</strong></h3>
<p>AccessibleObject <span style="font-family: 宋体;">类是 </span><span style="font-family: Calibri;">Field</span><span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">Method </span><span style="font-family: 宋体;">和 </span><span style="font-family: Calibri;">Constructor </span><span style="font-family: 宋体;">对象的</span>父<span style="font-family: 宋体;">类。它提供了将反射的对象标记为在使用时取消默认</span> Java <span style="font-family: 宋体;">语言访问控制检查的能力。</span></p>
<p><span style="font-family: 宋体;">对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用</span> Field<span style="font-family: 宋体;">、</span><span style="font-family: Calibri;">Method </span><span style="font-family: 宋体;">或 </span><span style="font-family: Calibri;">Constructor </span><span style="font-family: 宋体;">对象来设置或获取字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。常用方法如下</span>：</p>
<p class="17">public void <strong>setAccessible</strong>(boolean&nbsp;flag)&nbsp;throws <a title="java.lang 中的类" href="mk:@MSITStore:D:\传智基础班\JDK_API_1_6_zh_CN.CHM::/java/lang/SecurityException.html"><span style="text-decoration: underline;">SecurityException</span></a>&nbsp;</p>
<p><span style="font-family: 宋体;">参数值为</span> true&nbsp;<span style="font-family: 宋体;">则指示反射的对象在使用时应该取消</span> Java <span style="font-family: 宋体;">语言访问检查。参数值为 </span>false&nbsp;<span style="font-family: 宋体;">则指示反射的对象应该实施</span> Java <span style="font-family: 宋体;">语言访问检查。</span></p>
<p>&nbsp;</p>
<p>获取私有构造方法，步骤如下：</p>
<p>1. <span style="font-family: 宋体;">获取到</span><span style="font-family: Calibri;">Class</span><span style="font-family: 宋体;">对象</span></p>
<p>2. <span style="font-family: 宋体;">获取指定的构造方法</span></p>
<p>3. <span style="font-family: 宋体;">暴力访问</span><span style="font-family: Calibri;">, </span><span style="font-family: 宋体;">通过</span><strong>setAccessible</strong>(boolean&nbsp;flag)方法</p>
<p>4. <span style="font-family: 宋体;">通过构造方法类</span>Constructor中的方法，创建对象</p>
<p>　　public T newInstance(Object... initargs)</p>
<p class="17">代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ConstructorDemo2 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,获取到Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person");<span style="color: #008000;">//</span><span style="color: #008000;">包名.类名
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,获取指定的构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">private Person(String name, int age)</span>
        Constructor con = c.getDeclaredConstructor(String.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3,暴力反射 </span>
        con.setAccessible(<span style="color: #0000ff;">true</span>);<span style="color: #008000;">//</span><span style="color: #008000;">取消 Java 语言访问检查
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4,通过构造方法类中的功能，创建对象</span>
        Object obj = con.newInstance("小明", 23<span style="color: #000000;">);
        System.out.println(obj);
        
    }
}</span></code></pre>

<h2><!--[if !supportLists]-->2.3&nbsp;<!--[endif]--><strong><span style="font-family: 华文楷体;">通过反射获取成员变量并使用</span></strong></h2>
<p><span style="font-family: 宋体;">在反射机制中，把类中的成员变量使用类</span>Field<span style="font-family: 宋体;">表示</span><span style="font-family: 宋体;">。可通过</span>Class<span style="font-family: 宋体;">类中提供的方法获取成员变量：</span></p>
<p class="16">返回一个成员变量</p>
<p class="16">　　public Field getField(String name) 获取指定的 public修饰的变量</p>
<p class="16">　　public Field getDeclaredField(String name) 获取指定的任意变量</p>
<p class="16">返回多个成员变量</p>
<p class="16">　　public Field[] getFields() 获取所有public 修饰的变量</p>
<p class="16">　　public Field[] getDeclaredFields() 获取所有的 变量 (包含私有)</p>
<p class="16">&nbsp;</p>
<p class="16">获取成员变量的代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FieldDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchFieldException, SecurityException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person"<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取成员变量
        </span><span style="color: #008000;">//</span><span style="color: #008000;">多个变量
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Field[] fields = c.getFields();</span>
        Field[] fields =<span style="color: #000000;">  c.getDeclaredFields();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Field field : fields) {
            System.out.println(field);
        }
        System.out.println(</span>"-----------------"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">一个变量
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public int age;</span>
        Field ageField = c.getField("age"<span style="color: #000000;">);
        System.out.println(ageField);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">private String address</span>
        Field addressField = c.getDeclaredField("address"<span style="color: #000000;">);
        System.out.println(addressField);
    }
}</span></code></pre>

<h3><!--[if !supportLists]-->2.3.1&nbsp;<!--[endif]--><strong>通过反射，创建对象，获取指定的成员变量，进行赋值与获取值操作</strong></h3>
<p>获取成员变量，步骤如下：</p>
<p>1. <span style="font-family: 宋体;">获取</span><span style="font-family: Calibri;">Class</span><span style="font-family: 宋体;">对象</span></p>
<p>2. <span style="font-family: 宋体;">获取构造方法</span></p>
<p>3. <span style="font-family: 宋体;">通过构造方法，创建对象</span></p>
<p>4. <span style="font-family: 宋体;">获取指定的成员变量（私有成员变量，通过</span><strong>setAccessible</strong>(boolean&nbsp;flag)方法暴力访问）</p>
<p>5. <span style="font-family: 宋体;">通过方法，给指定对象的指定成员变量赋值或者获取值</span></p>
<p class="16">　　public void set(Object obj, Object value)</p>
<p><span style="font-family: 宋体;">　　　　在指定对象</span>obj<span style="font-family: 宋体;">中，将此 </span><span style="font-family: Calibri;">Field </span><span style="font-family: 宋体;">对象表示的成员变量设置为指定的新值</span></p>
<p class="16">　　public Object get(Object obj)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　<span style="font-family: 宋体;">返回指定对象</span>obj<span style="font-family: 宋体;">中，此 </span><span style="font-family: Calibri;">Field </span><span style="font-family: 宋体;">对象表示的成员变量的值</span></p>
<p class="16">代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FieldDemo2 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1,获取Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2，获取构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person(String name) </span>
        Constructor con = c.getConstructor(String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3，通过构造方法，创建对象</span>
        Object obj = con.newInstance("小明"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4，获取指定的成员变量
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public String name;</span>
        Field nameField = c.getField("name"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public int age;</span>
        Field ageField = c.getField("age"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">private String address;</span>
        Field addressField = c.getDeclaredField("address"<span style="color: #000000;">);
        addressField.setAccessible(</span><span style="color: #0000ff;">true</span>); <span style="color: #008000;">//</span><span style="color: #008000;">取消 Java 语言访问检查
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5，通过方法，给指定对象的指定成员变量赋值或者获取值</span>
        System.out.println("name = "+<span style="color: #000000;"> nameField.get(obj));
        System.out.println(</span>"age = "+<span style="color: #000000;"> ageField.get(obj));
        System.out.println(</span>"address = "+<span style="color: #000000;"> addressField.get(obj));
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">赋值</span>
        ageField.set(obj, 23<span style="color: #000000;">);
        addressField.set(obj, </span>"凯利广场"<span style="color: #000000;">);
        
        System.out.println(</span>"------------------------"<span style="color: #000000;">);
        System.out.println(</span>"name = "+<span style="color: #000000;"> nameField.get(obj));
        System.out.println(</span>"age = "+<span style="color: #000000;"> ageField.get(obj));
        System.out.println(</span>"address = "+<span style="color: #000000;"> addressField.get(obj));
    }
}</span></code></pre>

<h2><!--[if !supportLists]-->2.4&nbsp;<!--[endif]--><strong><span style="font-family: 华文楷体;">通过反射获取成员方法并使用</span></strong></h2>
<p><span style="font-family: 宋体;">在反射机制中，把类中的成员方法使用类</span>Method<span style="font-family: 宋体;">表示</span><span style="font-family: 宋体;">。可通过</span>Class<span style="font-family: 宋体;">类中提供的方法获取成员方法：</span></p>
<p class="16">返回获取一个方法：</p>
<p class="16">　　public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</p>
<p>&nbsp; 　　　<span style="font-family: 宋体;">获取</span>public <span style="font-family: 宋体;">修饰的方法</span></p>
<p class="16">　　public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</p>
<p>　　　　获取任意的方法，包含私有的</p>
<p><span style="font-family: 宋体;">　　　　参数</span>1: name <span style="font-family: 宋体;">要查找的方法名称； 参数</span><span style="font-family: Calibri;">2</span><span style="font-family: 宋体;">： </span><span style="font-family: Calibri;">parameterTypes </span><span style="font-family: 宋体;">该方法的参数类型</span></p>
<p class="16">返回获取多个方法：</p>
<p class="16">　　public Method[] getMethods() 获取本类与父类中所有public 修饰的方法</p>
<p class="16">　　public Method[] getDeclaredMethods() 获取本类中所有的方法(包含私有的)</p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体;">获取成员</span>方法<span style="font-family: 宋体;">的代码演示</span>：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MethodDemo {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person"<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取多个方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Method[] methods = c.getMethods();</span>
        Method[] methods =<span style="color: #000000;"> c.getDeclaredMethods();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Method method : methods) {
            System.out.println(method);
        }
        
        System.out.println(</span>"-----------------------"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取一个方法：
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public void method1()</span>
        Method method = c.getMethod("method1", <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        System.out.println(method);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public String method4(String name){</span>
        method = c.getMethod("method4", String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        System.out.println(method);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">私有方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">private void method5()</span>
        method = c.getDeclaredMethod("method5", <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        System.out.println(method);
    }
}</span></code></pre>

<h3><!--[if !supportLists]-->2.4.1&nbsp;<!--[endif]--><strong>通过反射，创建对象，调用指定的方法</strong></h3>
<p>获取成员方法，步骤如下：</p>
<p>1. <span style="font-family: 宋体;">获取</span><span style="font-family: Calibri;">Class</span><span style="font-family: 宋体;">对象</span></p>
<p>2. <span style="font-family: 宋体;">获取构造方法</span></p>
<p>3. <span style="font-family: 宋体;">通过构造方法，创建对象</span></p>
<p>4. <span style="font-family: 宋体;">获取指定的方法</span></p>
<p>5. <span style="font-family: 宋体;">执行找到的方法</span></p>
<p class="16">　　public Object invoke(Object obj, &nbsp;Object... args)&nbsp;</p>
<p><span style="font-family: 宋体;">　　　　执行指定对象</span>obj<span style="font-family: 宋体;">中，当前</span><span style="font-family: Calibri;">Method</span><span style="font-family: 宋体;">对象所代表的方法，方法要传入的参数通过</span><span style="font-family: Calibri;">args</span><span style="font-family: 宋体;">指定。</span></p>
<p class="16">代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MethodDemo2 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1， 获取Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,获取构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person(String name, int age, String address){</span>
        Constructor con = c.getConstructor(String.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span>, String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3，通过构造方法，创建对象</span>
        Object obj = con.newInstance("小明", 23, "哈尔滨"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4，获取指定的方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public void method1()  没有返回值没有参数的方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Method m1 = c.getMethod("method1", null);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public String method4(String name)</span>
        Method m4 = c.getMethod("method4", String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5，执行找到的方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">m1.invoke(obj, null);</span>
<span style="color: #000000;">        
        Object result </span>= m4.invoke(obj, "itcast"<span style="color: #000000;">);
        System.out.println(</span>"result = " +<span style="color: #000000;"> result);
    }
}</span></code></pre>

<h3><!--[if !supportLists]-->2.4.2&nbsp;<!--[endif]--><strong><span style="font-family: 黑体;">通过反射，创建对象，调用指定的</span>private <span style="font-family: 黑体;">方法</span></strong></h3>
<p>获取私有成员方法，步骤如下：</p>
<p>1. <span style="font-family: 宋体;">获取</span><span style="font-family: Calibri;">Class</span><span style="font-family: 宋体;">对象</span></p>
<p>2. <span style="font-family: 宋体;">获取构造方法</span></p>
<p>3. <span style="font-family: 宋体;">通过构造方法，创建对象</span></p>
<p>4. <span style="font-family: 宋体;">获取指定的方法</span></p>
<p>5. <span style="font-family: 宋体;">开启暴力访问</span></p>
<p>6. <span style="font-family: 宋体;">执行找到的方法</span></p>
<p class="16">　　public Object invoke(Object obj, &nbsp;Object... args)</p>
<p><span style="font-family: 宋体;">　　　　执行指定对象</span>obj<span style="font-family: 宋体;">中，当前</span><span style="font-family: Calibri;">Method</span><span style="font-family: 宋体;">对象所代表的方法，方法要传入的参数通过</span><span style="font-family: Calibri;">args</span><span style="font-family: 宋体;">指定。</span></p>
<p class="16">代码演示：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MethodDemo3 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1， 获取Class对象</span>
        Class c = Class.forName("cn.itcast_01_Reflect.Person"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2,获取构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public Person(String name, int age, String address){</span>
        Constructor con = c.getConstructor(String.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span>, String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3，通过构造方法，创建对象</span>
        Object obj = con.newInstance("小明", 23, "哈尔滨"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4，获取指定的方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">private void method5(){</span>
        Method m5 = c.getDeclaredMethod("method5", <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5,开启暴力访问</span>
        m5.setAccessible(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">6，执行找到的方法</span>
        m5.invoke(obj, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }
}</span></code></pre>

<h1>3.&nbsp;<strong>反射练习</strong></h1>
<h2><!--[if !supportLists]-->3.1&nbsp;<!--[endif]--><strong>泛型擦除</strong></h2>
<p><span style="font-family: 宋体;">思考，将已存在的</span>ArrayList&lt;Integer&gt;<span style="font-family: 宋体;">集合中添加一个字符串数据，如何实现呢？</span></p>
<p>我来告诉大家，<span style="font-family: 宋体;">其实程序编译后产生的</span>.class<span style="font-family: 宋体;">文件中是没有泛型约束的，这种现象我们称为泛型的擦除。</span>那么，我们可以通过反射技术，来完成向有泛型约束的集合中，添加任意类型的元素</p>
<p class="16"><span style="font-family: 宋体;">代码如下</span>：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ReflectTest {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ClassNotFoundException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        ArrayList</span>&lt;Integer&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;Integer&gt;<span style="color: #000000;">();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">添加元素到集合</span>
        list.add(<span style="color: #0000ff;">new</span> Integer(30<span style="color: #000000;">));
        list.add(</span><span style="color: #0000ff;">new</span> Integer("12345"<span style="color: #000000;">));
        list.add(</span>123<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">list.add("哈哈");</span><span style="color: #008000;">//</span><span style="color: #008000;">因为有泛型类型的约束</span>
<span style="color: #000000;">        System.out.println(list);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">通过反射技术，实现添加任意类型的元素
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1, 获取字节码文件对象
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Class c = list.getClass();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Class c = ArrayList.class;</span>
        Class c = Class.forName("java.util.ArrayList"<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2, 找到add()方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> public boolean add(E e)</span>
        Method addMethod = c.getMethod("add", Object.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3，  执行add()方法</span>
        addMethod.invoke(list, "哈哈");<span style="color: #008000;">//</span><span style="color: #008000;"> list.add("哈哈");</span>
<span style="color: #000000;">        System.out.println(list);
    }
}</span></code></pre>

<h2><!--[if !supportLists]-->3.2&nbsp;<!--[endif]--><strong>反射配置文件</strong></h2>
<p>通过反射配置文件，运行配置文件中指定类的对应方法</p>
<p><span style="font-family: 宋体;">读取</span>Peoperties.txt<span style="font-family: 宋体;">文件中的数据，通过反射技术，来完成</span><span style="font-family: Calibri;">Person</span><span style="font-family: 宋体;">对象的创建</span></p>
<p>Peoperties.txt<span style="font-family: 宋体;">文件内容如下：</span></p>
<src class="cnblogs_code">
<pre><code>className=<span style="color: #000000;">cn.itcast_01_Reflect.Person
methodName</span>=method5</code></pre>

<p class="16">读取配置文件，调用指定类中的对应方法</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ReflectTest2 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)
            </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> FileNotFoundException, IOException, ClassNotFoundException, NoSuchMethodException, SecurityException,
            InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 通过Properties集合从文件中读取数据</span>
        Properties prop = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Properties();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 读取文件中的数据到集合中</span>
        prop.load(<span style="color: #0000ff;">new</span> FileInputStream("properties.txt"<span style="color: #000000;">));
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取键所对应的值</span>
        String className = prop.getProperty("className"<span style="color: #000000;">);
        System.out.println(className);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 1，获取Person.class 字节码文件对象</span>
        Class c =<span style="color: #000000;"> Class.forName(className);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 2，获取构造方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> public Person(String name, int age, String address)</span>
        Constructor con = c.getConstructor(String.<span style="color: #0000ff;">class</span>, <span style="color: #0000ff;">int</span>.<span style="color: #0000ff;">class</span>, String.<span style="color: #0000ff;">class</span><span style="color: #000000;">);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 3,创建对象</span>
        Object obj = con.newInstance("小明", 20, "中国"<span style="color: #000000;">);
        System.out.println(obj);

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 4，获取指定的方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> private void method5(){}</span>
        String methodName = prop.getProperty("methodName"<span style="color: #000000;">);
        Method m5 </span>= c.getDeclaredMethod(methodName, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 5,开启暴力访问</span>
        m5.setAccessible(<span style="color: #0000ff;">true</span><span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 6，执行找到的方法</span>
        m5.invoke(obj, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }
}</span></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>